{"meta":{"title":"tBlog","subtitle":"","description":"","author":"Mr.T","url":"https://sirius-tblog.github.io","root":"/"},"pages":[{"title":"","date":"2023-05-23T14:32:16.460Z","updated":"2023-05-23T14:32:16.460Z","comments":true,"path":"manifest.json","permalink":"https://sirius-tblog.github.io/manifest.json","excerpt":"","text":"{\"name\":\"Ariasakaã®å°çª\",\"short_name\":\"Ariasakaã®å°çª\",\"theme_color\":\"var(--lyx-theme)\",\"background_color\":\"var(--lyx-theme)\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"/img/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"/img/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/img/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/180.png\",\"sizes\":\"180X180\",\"type\":\"image/png\"},{\"src\":\"/img/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/img/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"/img/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2023-05-23T14:32:16.475Z","updated":"2023-05-23T14:32:16.475Z","comments":true,"path":"package.json","permalink":"https://sirius-tblog.github.io/package.json","excerpt":"","text":"{\"name\":\"ariasakablog\",\"version\":\"1.0.17\",\"description\":\"SpeedUp!\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"author\":\"\",\"license\":\"ISC\"}"},{"title":"å…³äº","date":"2021-03-30T07:57:51.000Z","updated":"2023-05-23T14:32:16.202Z","comments":true,"path":"about/index.html","permalink":"https://sirius-tblog.github.io/about/index.html","excerpt":"","text":""},{"title":"åˆ†ç±»","date":"2022-07-03T12:48:08.000Z","updated":"2023-05-23T14:32:16.217Z","comments":true,"path":"categories/index.html","permalink":"https://sirius-tblog.github.io/categories/index.html","excerpt":"","text":""},{"title":"fontawesomeå¯¹ç…§","date":"2022-11-25T00:16:09.000Z","updated":"2023-05-23T14:32:16.223Z","comments":true,"path":"fontawesome/index.html","permalink":"https://sirius-tblog.github.io/fontawesome/index.html","excerpt":"","text":"window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"æ ‡ç­¾","date":"2022-07-03T12:51:29.000Z","updated":"2023-05-23T14:32:16.485Z","comments":true,"path":"tags/index.html","permalink":"https://sirius-tblog.github.io/tags/index.html","excerpt":"","text":""},{"title":"å·¥å…·","date":"2022-07-13T07:23:02.000Z","updated":"2023-05-23T14:32:16.488Z","comments":true,"path":"tools/index.html","permalink":"https://sirius-tblog.github.io/tools/index.html","excerpt":"","text":"é•œåƒç«™å¸¸ç”¨çš„PyPi/npm/SDKé•œåƒç«™ TUNA æ¸…åå¤§å­¦å¼€æºé•œåƒç«™ è±†ç“£PYPIæº è±†ç“£PYPIé•œåƒç«™ jsDelivr jsDelivré™æ€èµ„æºåŠ é€Ÿï¼ˆGFWå·²å¢™ï¼‰ unpkg å¦ä¸€ä¸ªé™æ€èµ„æºåŠ é€ŸCDNï¼ˆæ²¡å¢™ï¼‰ èµ„æºä¸‹è½½ç±»å¥½ç”¨çš„èµ„æºä¸‹è½½/æ”¶å½•ç«™ MSDN,æˆ‘å‘Šè¯‰ä½  å¾®è½¯MSDNED2Ké•œåƒæ”¶å½•ç«™ å”§å”§Down ä¸‹è½½Bç«™è§†é¢‘ æ— æŸç”Ÿæ´» å…è´¹ä¸‹è½½å…¨ç½‘ç»å¤§éƒ¨åˆ†æ— æŸéŸ³ä¹ ç™¾åº¦ç½‘ç›˜ç®€æ˜“ä¸‹è½½åŠ©æ‰‹ ç‰¹åˆ«å¥½ç”¨çš„bdç½‘ç›˜ç ´è§£å™¨ï¼ˆä¸çŸ¥é“ä¸ºä»€ä¹ˆå…¬ä¼—å·åˆ†äº«å¾ˆæ€•æ•æ„Ÿè¯ï¼‰ æ—¥å¸¸å·¥å…·å¸¸ç”¨æ—¥å¸¸å·¥å…· è®¡æ—¶å™¨ é—¹é’Ÿç½‘è®¡æ—¶å™¨ å›¾ç‰‡ç³»åˆ—å…³äºå›¾ç‰‡çš„å·¥å…· Bigjpg é«˜æ¸…ä¿®å¤å›¾ç‰‡ä¸é™å™ª waifu2x é«˜æ¸…ä¿®å¤å›¾ç‰‡ä¸é™å™ªï¼Œæ€§èƒ½è²Œä¼¼å¥½ä¸€ç‚¹ jpgrm é«˜æ¸…ä¿®å¤å›¾ç‰‡ä¸é™å™ª Sheilds åˆ¶ä½œGithubé¡¹ç›®å¾½ç«  æç®€å£çº¸ æµ·é‡é«˜æ¸…å£çº¸ç¾å›¾&äºŒæ¬¡å…ƒå›¾ç‰‡ å¸¸ç”¨æµ‹è¯•ç½‘ç«™æµ‹è¯•ä¸€äº›åŸºç¡€åŠŸèƒ½ è¿˜æ²¡åšå®Œå‘¢ ä½ ç…å•¥ï¼Ÿè¿˜å¦¹åšå®Œå‘¢ï¼"},{"title":"å…³äº","date":"2021-03-30T07:57:51.000Z","updated":"2023-04-07T04:25:38.321Z","comments":true,"path":"more/about/index.html","permalink":"https://sirius-tblog.github.io/more/about/index.html","excerpt":"","text":""},{"title":"ç¾å‘³ç®€é¤","date":"2023-05-27T16:50:02.451Z","updated":"2023-05-27T16:50:02.379Z","comments":true,"path":"more/foods/index.html","permalink":"https://sirius-tblog.github.io/more/foods/index.html","excerpt":"","text":""},{"title":"é˜…è¯»æ‰‹æŠ„","date":"2023-05-27T12:57:05.215Z","updated":"2023-05-27T12:57:05.204Z","comments":true,"path":"more/readbook/index.html","permalink":"https://sirius-tblog.github.io/more/readbook/index.html","excerpt":"","text":"æˆ‘çš„ä¿¡æ¯Butterfly & MengDfluidvolantishtml12345- name: Ariasakaã®å°çª link: https://yisous.xyz avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg descr: äººæœ‰æ‚²æ¬¢ç¦»åˆ æœˆæœ‰é˜´æ™´åœ†ç¼º siteshot: https://vercel.yisous.xyz/img/siteshot.png123456- &#123; title: &#x27;Ariasakaã®å°çª&#x27;, intro: &#x27;äººæœ‰æ‚²æ¬¢ç¦»åˆ æœˆæœ‰é˜´æ™´åœ†ç¼º&#x27;, link: &#x27;https://yisous.xyz/&#x27;, image: &#x27;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&#x27;&#125;123456- title: Ariasakaã®å°çª avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg url: https://yisous.xyz/ screenshot: https://yisous.xyz/img/siteshot.png keywords: ä¸ªäººåšå®¢ description: äººæœ‰æ‚²æ¬¢ç¦»åˆ æœˆæœ‰é˜´æ™´åœ†ç¼º1&lt;a href=&quot;https://yisous.xyz&quot;&gt;&lt;img src=&quot;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&quot; alt=&quot;avatar&quot;&gt;Ariasakaã®å°çª&lt;/a&gt; æ¨èæ ‡ç­¾è¡¡é‡æ ‡å‡†1.ç½‘ç«™æ²¡æœ‰ä¸è‰¯å†…å®¹ 2.æ–‡ç« è´¨é‡è¾ƒé«˜ 3.æ–‡ç« è¾ƒå¤š/æˆ–è€…è´¨é‡è¿‡ç¡¬"},{"title":"åˆ†ç«™","date":"2022-08-04T03:38:05.000Z","updated":"2023-04-07T04:25:38.611Z","comments":true,"path":"more/othersite/index.html","permalink":"https://sirius-tblog.github.io/more/othersite/index.html","excerpt":"","text":"ä¸€äº›åšä¸»æ­å»ºçš„å…¶å®ƒçš„ç«™ç‚¹ï¼š PSï¼šåˆ’æ‰çš„è¡¨ç¤ºå·²æŒ‚ åŸŸå ç”¨å¤„ æ­å»ºåŸå›  yisous.xyz åšå®¢ï¼Œä¹Ÿæ˜¯ä¸»ç«™ï¼ˆé»˜è®¤æ— wwwï¼‰ åˆ†äº«ä¸€äº›ä¸œè¥¿ oj.yisous.xyz OnlineJudgeç³»ç»Ÿ ç”¨äºè‡ªå·±ç»ƒä¹ ä¿¡å¥¥èµ›é¢˜ç›®å…¶å®æ˜¯ææ¥è±¡å¾æ„ä¹‰çš„ status.yisous.xyz ç½‘ç«™çŠ¶æ€ç›‘æ§ ç”¨äºç›‘æ§ç½‘ç«™çš„çŠ¶æ€ï¼ŒåŸºäºuptimeRobot mc.yisous.xyz MinecraftæœåŠ¡å™¨ ç”¨æ¥è”æœºç©ï¼Œç±»ä¼¼äºç²‰ä¸æœé‚£ç§ï¼Œè¿˜æ²¡å¼„å¥½ tc.yisous.xyz Typechoæµ‹è¯•ç«™ çœ‹çœ‹typechoæ€ä¹ˆæ ·ï¼Œææ¥ç©çš„ï¼Œå·²ç»ç”±Wordpressè¿ç§»è‡³å½“å‰çš„Typechoï¼Œæœªæ¥æœåŠ¡å™¨æ–‡æ¡£ä¹‹åå¯èƒ½ä¼šæ¢ç”¨ yisous.tk/lyxop.xyz çŸ­é“¾æ¥ç”Ÿæˆå™¨ åˆ¶ä½œçŸ­é“¾æ¥ï¼Œä½¿ç”¨æœ¬ç«™åŸŸåï¼ŒæŠ€æœ¯æœ‰é™ï¼Œæ‰€ä»¥å¾ˆä¸‘ bbs.yisous.xyz LYXã®è®ºå› äº¤æµä¸€äº›äº‹æƒ…ï¼Œä¹Ÿå¯ä»¥é—²èŠï¼Œè¿˜æ²¡å¼„è¯´æ˜¯äº¤æµå…¶å®è¿˜æ˜¯ææ¥è±¡å¾æ„ä¹‰ææ¥ç©çš„ åšä¸»çš„ä¸€äº›åŸŸå åŸŸå ç”¨å¤„ yisous.xyz ä¸»è¦ä½¿ç”¨çš„åŸŸåï¼Œå½“æ—¶çœ‹åˆ°dynadot14å—ä¸€å¹´å°±ä¹°äº†ï¼Œè¿™ä¸ªåå­—å°±æ˜¯å¿µèµ·æ¥é¡ºå£ lyxop.xyz æ³¨å†Œæ‹¿æ¥ç»™å‰¯ç«™ç”¨çš„ï¼Œä½¿ç”¨blog.lyxop.xyzè¿›å…¥ä¸»ç«™ã€‚ç”±äºåŸŸåç»­è´¹å¤ªè´µï¼Œæ‰€ä»¥æ‰“ç®—ä»¥åæ¢æˆyisous.tkï¼Œå…¶ä½™ä¸€æ · ariasaka.top åœ¨ç¡…äº‘ç™½å«–çš„ä¸€ä¸ªåŸŸåï¼Œåç»­å¯èƒ½ä¼šä½œä¸ºä¸»åŸŸåä½¿ç”¨ lyxoff2233.eu.org ä»¥å‰çš„eu.orgåŸŸåï¼Œè¿˜ä¸é”™ï¼Œåé¢è¦æ‹¿æ¥æƒ³åŠæ³•ç”¨ä¸€ç”¨ lyxofficial.eu.org å›¾ä¸€ä¹åŸŸå yisous.tk 20å¹´ä¸ºäº†æ­æ ‘è“æ´¾æœæçš„åŸŸåï¼Œå¯æ˜¯æ ‘è“æ´¾æ²¡å¤šä¹…å°±è¢«æˆ‘è¶…åäº†ï¼Œç°åœ¨å°±ä¹°ä¸èµ·äº†ï¼Œåæ¥è¿™ä¸ªåŸŸåè¿‡æœŸï¼Œç°åœ¨åˆå¼„å›æ¥ä½œä¸ºå‰¯ç«™ä½¿ç”¨ï¼Œä½¿ç”¨blog.yisous.tkè¿›å…¥ä¸»ç«™ï¼Œwwwå’Œæ ¹åŸŸåä¸»ç«™ç”¨äºæä¾›çŸ­åŸŸåæœåŠ¡ï¼ˆå·²æŒ‚ï¼‰ã€‚ æ³¨æ„ï¼šæœ¬åšå®¢å¼ºåˆ¶HTTPSï¼Œæ—§ç”µè„‘å¯èƒ½ä¼šå‡ºç°é—®é¢˜ã€‚ #article-container a:not(.post-meta__tags):not(img):not(a[data-fancybox]):hover{ border-radius: 6px; background-color: #425aef; text-decoration: none!important; color:#fff!important; border:none; box-shadow: #dadada 0 0 8px 2px; } #article-container a:not(.post-meta__tags):not(.headerlink):not(a[data-fancybox]){ /* padding:0 2px; */ /* text-decoration: 1px solid #425aef; */ /* text-decoration: underline; */ border-bottom: 2px solid #425aef; color:var(--font-color); padding:4px }"},{"title":"æœ‹å‹åœˆ","date":"2022-01-29T07:23:17.000Z","updated":"2023-04-07T04:25:38.352Z","comments":true,"path":"solution/fcircle/index.html","permalink":"https://sirius-tblog.github.io/solution/fcircle/index.html","excerpt":"","text":"ğŸ£ é’“é±¼ ä¸ä¸»æœºé€šè®¯ä¸­â€¦â€¦ var fdataUser = { apiurl: '' }"},{"title":"ICç”µè·¯è§£å†³æ–¹æ¡ˆ","date":"2023-05-28T03:16:20.958Z","updated":"2023-05-27T06:34:25.163Z","comments":true,"path":"solution/ic/index.html","permalink":"https://sirius-tblog.github.io/solution/ic/index.html","excerpt":"","text":""},{"title":"ITæŠ€æœ¯è§£å†³æ–¹æ¡ˆ","date":"2023-05-27T06:37:08.691Z","updated":"2023-05-27T06:37:08.686Z","comments":true,"path":"solution/it/index.html","permalink":"https://sirius-tblog.github.io/solution/it/index.html","excerpt":"","text":""},{"title":"å¥½å¬çš„éŸ³ä¹","date":"2022-07-14T08:37:40.000Z","updated":"2023-04-07T04:25:38.600Z","comments":true,"path":"solution/musics/index.html","permalink":"https://sirius-tblog.github.io/solution/musics/index.html","excerpt":"","text":"å¥½å¬çš„æ­Œ æ­Œæ›²æ’è¡Œæ¦œ åšä¸»ä¼šæ¯éš”ä¸€æ®µæ—¶é—´å°†è‡ªå·±è¿‘æœŸçˆ±å¬çš„æ­Œæ’è¡Œåœ¨ä¸‹é¢ 2022-7 å’•å’•å’•â€¦"},{"title":"å£°æ˜","date":"2022-07-10T03:13:49.000Z","updated":"2023-05-27T01:09:45.290Z","comments":true,"path":"solution/ic/arm/index.html","permalink":"https://sirius-tblog.github.io/solution/ic/arm/index.html","excerpt":"","text":""},{"title":"","date":"2023-05-13T07:05:21.157Z","updated":"2023-05-13T07:05:21.156Z","comments":true,"path":"solution/ic/circuit/index.html","permalink":"https://sirius-tblog.github.io/solution/ic/circuit/index.html","excerpt":"","text":"è¯´è¯´ä½ çš„å»ºè®®å§... ä½ ä¹Ÿå¯ä»¥ç§å‘æˆ‘çš„é‚®ä»¶lyxof2010@yisous.xyzå¯»æ±‚å¸®åŠ©æˆ–è€…æä¾›å»ºè®®ã€‚ éšè—/æ˜¾ç¤ºå¼¹å¹•ï¼ˆç¼“è§£å¡é¡¿ï¼‰"},{"title":"è¯´è¯´","date":"2023-05-26T15:54:03.007Z","updated":"2023-05-26T15:54:03.003Z","comments":true,"path":"solution/ic/dsp/index.html","permalink":"https://sirius-tblog.github.io/solution/ic/dsp/index.html","excerpt":"","text":"function doSpeaks() { bbtalk.init({ appId: \"\", appKey: \"\", serverURLs: '', pageSize:1919810 }) } document.addEventListener('DOMContentLoaded', (e) => { doSpeaks(); }) document.addEventListener('pjax:complete', (e) => { doSpeaks(); })"},{"title":"ç½‘ç«™æ›´æ–°æ—¥å¿—","date":"2022-07-02T11:56:00.000Z","updated":"2023-05-26T15:54:13.447Z","comments":true,"path":"solution/ic/fpga/index.html","permalink":"https://sirius-tblog.github.io/solution/ic/fpga/index.html","excerpt":"","text":"Acryple v1.0.0 2022-10-23 ç»è¿‡äº†æ·±æ€ç†Ÿè™‘ï¼Œåšå®¢ä¸»é¢˜ç‹¬ç«‹å•¦ï¼ ç°åœ¨çš„ä¸»é¢˜å«åšAcrypleï¼Œå…·ä½“è§ï¼š å¼•ç”¨ç«™å¤–åœ°å€ åšå®¢æ­£å¼ç‹¬ç«‹ä¸»é¢˜å•¦ï¼ Ariasakaã®å°çª ç›®å‰åšå®¢æœ‰ï¼š æ›´å¥½çš„å³é”®èœå• ç•™è¨€å¼¹å¹• åšå®¢è®¾ç½®ï¼ˆåŠŸèƒ½è´¼å¤šå¤§å®¶è‡ªå·±çœ‹ï¼‰ ä¸é”™çš„UIï¼Œè‡³ä»Šä¸ºæ­¢ä¸»css(style.css)æœ‰3kè¡Œ ä¸€äº›å°åŠŸèƒ½æ¯”å¦‚å…¬ç¥­æ—¥å¼¹çª—è‡ªåŠ¨æ¬¢è¿ç­‰ å¤§æ¦‚å°±æ˜¯è¿™äº›äº†ã€‚ Acryple v1.0.110 2022-12-13 åŠ å…¥pwa å…¨ç«™é‡‡ç”¨å­˜å‚¨æ¡¶åŠ é€Ÿï¼Œå¯æƒœå¹¶æ²¡æœ‰åµç”¨ å¾ˆå¤šèµ„æºè½¬ä¸ºäº†ç™½å«–eleme æŠ›å¼ƒmetingjsï¼Œç›®å‰aplayerçš„æ­Œæ›²æ‰˜ç®¡åœ¨eleme npmé•œåƒä¸­ å‹é“¾æ·»åŠ éšæœºå¤´åƒ åšå®¢è®¾ç½®ç”»é¥¼çš„ä¸‰ä¸ªåŠŸèƒ½ä»æœªä¿®å¤ qwq ä¿®å¤ä¸€äº›bug å¤§æ”¹swiperï¼Œå‚è€ƒè‡ªLeonus å®ŒæˆBuild101çš„å¤§éƒ¨åˆ†é¥¼ ä¿®å¤äº†æœ‹å‹åœˆçˆ¬å–bug swæ¢å›cyfan å¥—ä¸Šäº†çµå¤©ç›¾äºšå¤ªCDN å› ä¸ºæ€§èƒ½é—®é¢˜ï¼Œç§»é™¤äº†æ–‡ç« æ—¥å† ç»™å¯¼èˆªæ åŠ ä¸Šæ»šåŠ¨åŠ¨ç”»ï¼ˆç”»é¥¼ï¼‰ bbå¸ƒå±€é‡æ„ï¼ˆç”»é¥¼ï¼‰ åˆ†ç±»æ ‡ç­¾æ bugä¿®å¤ï¼ˆç”»é¥¼ï¼‰ è¯­é›€äº‘ç«¯å†™ä½œï¼ˆå› bugå·²å›æ»šï¼‰ gulpï¼ˆå› bugå·²å›æ»šï¼‰ æ–‡ç« è¿›åº¦æ˜¾ç¤ºï¼ˆç”»é¥¼ï¼‰ ä¿®å¤pjaxçš„bug å³é”®èœå•åŠŸèƒ½å®Œå–„ Acryple v1.0.101 2022-12-06 ï¼ˆPSï¼šéƒ¨åˆ†ç”»å¤§é¥¼ å£®ä¸¾ï¼šé€‚é…pjaxï¼ï¼ï¼ ä¿®å¤é»‘å¹•çš„bug ä¿®å¤è¯„è®ºå¼¹å¹•domé”™è¯¯ï¼Œæº¢å‡ºçš„bug å¼¹å¹•æ¢ç”¨swiperæ–¹æ¡ˆï¼Œå¹¶ä¸”ä¼˜åŒ–æ ·å¼ é¦–é¡µbbå¢åŠ å¤©æ•°æ˜¾ç¤ºï¼Œä»¥åŠæ¢ç”¨swiper(é¢„è®¡) ä¿®å¤ä¸€äº›bugï¼ˆe.g.aplayerã€åšå®¢è®¾ç½® ä¼˜åŒ–éƒ¨åˆ†åŠ¨ç”»/æ ·å¼ å®Œå–„åšå®¢æ§åˆ¶é¢æ¿ï¼Œä»æœ‰éƒ¨åˆ†æœªå®Œå·¥ ä¿®å¤éƒ¨åˆ†æ–‡ç« é¡µé¢æº¢å‡ºçš„bug æ‚¼å¿µæŸäººï¼Œbanneræ¢å›¾ paceæ¢ç”¨xlencoçš„èƒ¶å›Šæ–¹æ¡ˆ ç”±äºæœªçŸ¥ç‰¹æ€§åˆ é™¤äº†pjaxçš„åŠ è½½åŠ¨ç”»ï¼Œé¦–æ¬¡ä¿ç•™ éƒ¨åˆ†èµ„æºæ¢ç”¨ç¼¤çº·äº‘ æ¢ç”¨ç©ºæ¢¦çš„sw ä¸æ–­ä¼˜åŒ–åŠ è½½é€Ÿåº¦ingâ€¦ ä¿®å¤é¦–é¡µè½®æ’­bug(é¢„è®¡) è¯„è®ºæ ·å¼ä¿®æ”¹ï¼Œé¢„è®¡æ·»åŠ ç”¨æˆ·tagåŠŸèƒ½ æ›´æ¢èƒŒæ™¯æ²¡æœ‰æ—¶æ•ˆé™åˆ¶äº† æ¬¢è¿æ–‡æœ¬ å·¦å³æ åˆ‡æ¢ å¼¹å¹•å¼€å…³è®¾ç½®è‡ªåŠ¨æ˜¾éš è½æ¨±ç‰¹æ•ˆ aplayeræ˜¾éšåŠŸèƒ½ æ˜æš—æ¨¡å¼è‡ªåŠ¨åˆ‡æ¢ã€å›ºå®šå¯¼èˆªæ åŠŸèƒ½ï¼ˆé¢„è®¡ï¼‰ è¾¹æ æ ·å¼ä¿®æ”¹ ä¿®å¤ç‚¹èµç¬¬ä¸€èµæ²¡ååº”çš„bug ä¿®å¤ghactionséƒ¨ç½²æ²¡æœ‰npmç¼“å­˜çš„bugtnndæˆ‘ç­‰åå‡ åˆ†é’Ÿå®‰è£…ä¾èµ–ç­‰å‡ ä¸ªæœˆäº†ï¼Œç»“æœæ˜¯é¡ºåºåäº† ç›®å‰æœ‹å‹åœˆåç«¯å‡ºç°äº†bugï¼Œå¯¼è‡´ä¸æ›´æ–°ï¼Œè¯·é™å¾…ä¿®å¤ Acryple v1.0.100 2022-12-04 ä¿®å¤éƒ¨åˆ†bugï¼ˆä¸ï¼Œç‰¹æ€§ ä¼˜åŒ–éƒ¨åˆ†åŠ¨ç”»/æ ·å¼ ä¿®æ”¹å³é”®èœå• é‡å†™åšå®¢è®¾ç½®ï¼Œå¹¶å°† rightside çš„éƒ¨åˆ†åŠŸèƒ½ç§»åŠ¨åˆ°åšå®¢è®¾ç½®ä¸­ï¼Œçµæ„Ÿæ¥æºäºichikaï¼ˆæœªå®Œå·¥ æ”¯æŒéšè— ASide äº† çŸ­æš‚å˜ç° ä¿®å¤å…¬ç¥­æ—¥jsçš„bug ä¿®å¤å³é”®èœå•åœ¨ä¸»é¡µä¹Ÿèƒ½å¼€å¯é˜…è¯»æ¨¡å¼çš„bug ä¼˜åŒ–æ‰‹æœºç«¯é˜…è¯»ä½“éªŒï¼Œå»å¡ç‰‡åŒ– ä¼˜åŒ–latexæ ·å¼ ä¿®å¤éƒ¨åˆ†åˆ†è¾¨ç‡ä¸‹æ— å¯¼èˆªæ çš„bug aplayerçš„ä½“éªŒæ›´å¥½äº† ä¼˜åŒ–éƒ¨åˆ†æ ·å¼ï¼Œé€‚é…éƒ¨åˆ†è¿˜æœªé€‚é…çš„é»‘æš—æ¨¡å¼ åŠ äº†ä¸€ä¸ªå­—ä½“ é‡å†™åˆ†ç±»å’Œæ ‡ç­¾ã€å½’æ¡£é¡µçš„æ ·å¼ï¼Œæ¥æºäºichika ä¼˜åŒ–é¡µè„šæŸ¥çœ‹ä½“éªŒ ä¼˜åŒ–ç½‘ç«™æ€§èƒ½ æ”¯æŒå…¨å± css 5k+ qpzc è§£å°è¾£ï¼ï¼ï¼ ç©¶æè·³å·ï¼Ÿï¼CRT18:?! Acryple v1.0.92 ä¿®å¤éƒ¨åˆ†bugï¼ˆä¸ï¼Œç‰¹æ€§ ä¼˜åŒ–éƒ¨åˆ†æ ·å¼ æ›´æ”¹äº†åšå®¢è®¾ç½®çš„éƒ¨åˆ†ä¸»é¢˜è‰² pagesé¡µé¢åœ¨Acrylicä¸»é¢˜ä¸‹çš„èƒŒæ™¯å¾—åˆ°äº†æ”¹å–„ æ›´æ”¹åŠ è½½é¡µé¢èƒŒæ™¯ é‡æ–°è¿›è¡Œéƒ¨åˆ†æ–­ç‚¹ æŠŠåšå®¢api\\æœåŠ¡å…¨éƒ¨è¿ç§»åˆ°äº†å¦ä¸€ä¸ªgithubè´¦å·~~(åƒåœ¾æ¡¶)~~ä¸Š ä¼˜åŒ–æœç´¢UI å¯¹butterfly4.5.1è¿›è¡Œäº†é€‰æ‹©æ€§åŒæ­¥(ä¼˜åŒ–ç¹ä½“å­—åº“) ç–«æƒ…é€€é€€é€€awa Acryple v1.0.91 ä¿®å¤éƒ¨åˆ†bugï¼ˆä¸ï¼Œç‰¹æ€§ ä¸ºAPlayerè¿›è¡Œå®Œå–„ æ·»åŠ æ—©æŠ¥ã€æœ¨é±¼ã€ç©ºè°ƒé¡µé¢ï¼Œå‚è€ƒChuckle æ›´æ”¹å…³äºé¡µé¢ï¼Œå‚è€ƒå®‰çŸ¥é±¼çš„æ•™ç¨‹ å°è¯•npmå…¨ç«™é™æ€åŒ–ï¼Œæœ€ç»ˆå¤±è´¥æ”¾å¼ƒqwq ä¼˜åŒ–swï¼ŒåŠ è½½é€Ÿåº¦ç•¥æœ‰æå‡ æ–°å¢æ–‡ç« ç»Ÿè®¡ ä¼˜åŒ–éƒ¨åˆ†æ ·å¼ Acryple v1.0.81 2022-11-23 ä¿®å¤éƒ¨åˆ†bugï¼ˆä¸ï¼Œç‰¹æ€§ ä¼˜åŒ–æ€§èƒ½é—®é¢˜ï¼Œå¯¹å¼¹å¹•è¿›è¡Œäº†èŠ‚æµ æ·»åŠ APlayerï¼Œå¯æƒœæ²¡æœ‰pjax qwq ä¼˜åŒ–å¼¹å¹•ï¼ˆæ›´æ´ªåŒ–äº†ï¼‰ è°ƒæ•´ç½‘ç«™å¸ƒå±€ ä¿®æ”¹ä¸€äº›æ ·å¼ PSï¼šåœ¨1.0.51å·å·åŠ äº†ä¸€å·å­—å·ä½ ä»¬å‘ç°æ²¡æœ‰(doge) Acryple v1.0.51 ä¿®å¤éƒ¨åˆ†bugï¼ˆä¸ï¼Œç‰¹æ€§ ä¼˜åŒ–æ€§èƒ½é—®é¢˜ï¼ˆä½†æ˜¯å¥½åƒè¿˜æ˜¯æ²¡æ¯›æå‡ æ¢ç”¨Twikoo-magicè¡¨æƒ…åŒ… ä¸ºäº†OIæ·»åŠ  KaTeX\\textbf{ \\KaTeX} KATEâ€‹X ä¿®å¤è·³è½¬é“¾æ¥å› åŸæœ‰bugè¢«è¿«ä½¿åŸé¡µé¢åˆ·æ–°çš„bug Acryple v1.0.14 2022-11-10 ä¿®å¤éƒ¨åˆ†bugï¼ˆä¸ï¼Œç‰¹æ€§ ä¼˜åŒ–æ€§èƒ½é—®é¢˜ï¼ˆä½†æ˜¯å¥½åƒè¿˜æ˜¯æ²¡æ¯›æå‡ å¢åŠ æµè§ˆå™¨è¿‡æœŸæé†’ä»¥åŠbanIEï¼Œå‚è€ƒchuckleä»¥åŠbç«™ å¢åŠ fpsæ˜¾ç¤º è¯„è®ºè¡¨æƒ…æ·»åŠ é¢œæ–‡å­— ä¿®å¤æ‰‹æœºç«¯ä¾§è¾¹æ bug PSï¼šä½œä¸ºä¸€ä¸ªèŒæ–°OIerä¾ç„¶æ²¡æœ‰è€ƒè™‘å‘oiæ–‡ â•®(â•¯â–½â•°)â•­ ä»¥å‰çš„æ›´æ–°æ—¥å¿—å“”å“©å“”å“© (ã‚œ-ã‚œ)ã¤ãƒ­ å¹²æ¯ï¼ 2022 07-02 ç»ˆäºå¼„å¥½ç½‘ç«™äº†ï¼Œåº†ç¥ä¸€ä¸‹ğŸ‰ Gitalkä¸çŸ¥é“ä¸ºä»€ä¹ˆä¸æ˜¾ç¤ºå‡ºæ¥â€¦ 07-03 å°æ›´æ–°ï¼Œä¿®æ”¹ç»†èŠ‚ ä½œè€…çš„Htmlå®åœ¨å¤ªèœäº†ï¼Œæ•ˆæœå¹¶ä¸å¥½ 07-04 å¤§æ›´æ–° ä¿®æ”¹äº†å¾ˆå¤šui 07-05 å¤§æ›´æ–° ä¿®æ”¹ç»†èŠ‚UIå’Œå‹é“¾éƒ¨åˆ†ï¼Œå¢åŠ åæ§½éƒ¨åˆ† 07-06 å°æ›´æ–°ï¼Œåšå¥½ä¸€äº›åŠŸèƒ½å¹¶ä¸”å†™äº†ç¬¬ä¸€ç¯‡æ–‡ç«  07-08 å¤§æ›´æ–°ï¼Œæ›´æ”¹é¦–é¡µå¸ƒå±€ï¼Œå¢åŠ é¦–é¡µåˆ†åŒº 07-09 å°æ›´æ–°ï¼Œä¿®æ”¹ç»†èŠ‚ï¼Œé€‚é…æ‰‹æœºç«¯ï¼Œä¿®å¤bugï¼Œè¯´è¯´ç”±Artitalkæ¢ä¸ºBBtalk 07-14 å‰é¢å‡ å¤©å¿˜è®°å†™æ›´æ–°äº†ï¼Œæ›´æ–°äº†å¾ˆå¤šUIå’ŒåŠŸèƒ½ã€‚ã€‚ã€‚ 07-18 å‰é¢å‡ å¤©åˆå¿˜è®°å†™æ›´æ–°äº†å°å°ä¿®æ”¹äº†ä¸€äº›å¸ƒå±€ï¼ŒæŠŠé¸½äº†å¾ˆä¹…çš„åšå®¢å†™å®Œäº†å¹¶ä¸”è¿˜åŠ äº†èŒç™¾çš„é»‘å¹•ï¼Œæ²¡æœ‰ä½ çŸ¥é“çš„å¤ªå¤šäº†å·®è¯„ 07-22 å‰é¢å‡ å¤©åˆåŒå¿˜è®°å†™æ›´æ–°äº†æŠ˜è…¾äº†å¾ˆå¤šï¼ŒåŠ äº†è‡ªå·±çš„åŸŸåï¼ŒæŠŠä½ çŸ¥é“çš„å¤ªå¤šäº†å¼„å‡ºæ¥äº†ï¼Œå¹¶ä¸”ä¿®å¤äº†å¾ˆå¤šjsçš„bugï¼ŒæŠŠunpkgæ¢æˆfastly.jsdelivræˆ–è€…elemecdnï¼Œæå‡é€Ÿåº¦ï¼ˆç«Ÿç„¶æœ‰äººåŠ äº†æˆ‘å‹é“¾ï¼Œæ€ä¹ˆçŸ¥é“è¿™ä¸ªç½‘ç«™çš„ï¼Ÿï¼‰ 08-12 å‰é¢å‡ å¤©åˆåŒå’å¿˜è®°å†™æ›´æ–°äº†è¿˜æ˜¯æŠ˜è…¾äº†å¾ˆå¤šï¼ŒæŒ‰ç…§å†°ç³–çº¢èŒ¶å¤§ä½¬ä»¬çš„æ–¹æ³•åŠ äº†ä¸å°‘ä¸œè¥¿ï¼Œæ¯”å¦‚é‚£ä¸ªäººæ½®æ±¹æ¶Œæ¨¡æ‹Ÿå™¨ï¼ˆä¸»é¡µçš„ï¼‰ã€æ–‡ç« ç‚¹èµã€æ— ç¼è·³è½¬ç­‰ç­‰ï¼Œæ¢æˆjsdelivråŠ é€Ÿï¼ŒåŒæ—¶ä¹Ÿåœ¨æœ€å¤§åŒ–åˆ©ç”¨GoormIDEï¼Œä¸è¿‡åœ¨é™©äº›æ²¡æœ‰æ•°æ®ä¹‹åå°±å°½å¯èƒ½è¿ç§»åˆ°äº†å…¶å®ƒæ²¡æœ‰é£é™©çš„å¹³å°ã€‚ 08-25 æœ€è¿‘åœ¨ç³–æœå±‹ç¾¤å‹ä»¬çš„å»ºè®®å’Œå¸®åŠ©ä¸‹ä¿®æ”¹äº†å¾ˆå¤šåŠŸèƒ½,ä»¥åæ¯éš”ä¸€æ®µæ—¶é—´éƒ½ä¼šå†™è¯¦ç»†çš„æ—¥å¿—è€Œä¸æ˜¯åƒå‰é¢ç®€å•æ¦‚æ‹¬äº†ã€‚ ç•™è¨€æ¿çš„å¼¹å¹•æ˜¯çœŸçš„åƒbç«™è§†é¢‘å¼¹å¹•äº†ï¼Œè¿‡ä¸€æ®µæ—¶é—´ä¿®å¤äº†bugä¹‹åæ”¾æ•™ç¨‹ æ–°å¢åšå®¢è®¾ç½®ï¼Œåšäº†ä¸€ä¸ªæç®€é£çš„ä¸»é¢˜ï¼Œæ”¯æŒæ›´æ¢ä¸»é¢˜è‰²ï¼Œä¹Ÿå¯ä»¥æ¢å›ä¹‹å‰çš„ä¸»é¢˜ï¼Œå¯ä»¥ç¦ç”¨æ¨¡ç³Šæ•ˆæœå’Œå¼€å¯ç¡¬ä»¶åŠ é€Ÿæå‡æ€§èƒ½ ä¿®å¤äº†éƒ¨åˆ†æ’ç‰ˆbugï¼Œå¯¹safariè¿›è¡Œäº†ä¸€äº›é€‚åº”ï¼Œæ„Ÿè°¢Apple Storeå’Œæ´ªå“¥çš„å¸®åŠ©ã€‚ å¢åŠ äº†hoverçš„ç¼©æ”¾æ•ˆæœï¼Œæœ‰å±‚æ¬¡æ„Ÿ ä¼˜åŒ–åŠ¨ç”» ä¿®å¤ç•™è¨€å¼¹å¹•ã€å³é”®èœå•çš„bugå¹¶ä¸”æŠŠæ–°ç‰ˆçš„ä»£ç æ›´æ–°åˆ°æ–‡ç« ä¸­ ä¼˜åŒ–ç»†èŠ‚æ ·å¼ æ–°å¢æœ€æ–°æ–‡ç« æ ‡è®° æ€»ç®—éƒ¨ç½²å¥½æœ‹å‹åœˆäº†ï¼leancloudå›½å†…ç‰ˆåƒåœ¾ï¼"},{"title":"bangumis","date":"2022-07-16T02:35:32.000Z","updated":"2023-05-20T12:14:03.343Z","comments":true,"path":"solution/it/plat_internet/index.html","permalink":"https://sirius-tblog.github.io/solution/it/plat_internet/index.html","excerpt":"","text":""},{"title":"æ•²æœ¨é±¼","date":"2022-11-25T00:16:09.000Z","updated":"2023-04-07T04:25:38.605Z","comments":true,"path":"solution/it/plat_linux/index.html","permalink":"https://sirius-tblog.github.io/solution/it/plat_linux/index.html","excerpt":"","text":"åŠŸå¾·ï¼š0 åŠŸå¾·+100 .muyu-layout { background: black; display: flex; width: 100%; border-radius: 20px; position: relative; justify-content: center; height: 90vh; align-items: center; } #muyu-box img { width: 250px; } #jishu-box{ top: 55px; position: absolute; } #muyu-box p { color: white; opacity: 0; font-size: 25px; } #jishu-box p { color: white; font-size: 30px; } var gongde = document.getElementById(\"gongde\"); var muyu = document.getElementById(\"muyu\"); var jishu = document.getElementById(\"jishu-box\"); var mp3Url = \"/music/muyu.mp3\"; var player = new Audio(mp3Url); var num = 0; muyu.addEventListener(\"click\", function () { num+=100; player.load(); player.play(); muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500); gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600); jishu.innerHTML = \"åŠŸå¾·ï¼š\"+num+\"\"; });"},{"title":"å°ç©ºè°ƒ","date":"2022-11-24T23:37:35.000Z","updated":"2023-04-07T04:25:38.576Z","comments":true,"path":"solution/it/plat_windows/index.html","permalink":"https://sirius-tblog.github.io/solution/it/plat_windows/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2023-05-23T14:32:16.198Z","updated":"2023-05-23T14:32:16.199Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://sirius-tblog.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ16ï¼‰å¾…æœºå”¤é†’","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-016","date":"2022-11-08T04:09:18.000Z","updated":"2023-04-05T14:20:22.643Z","comments":true,"path":"posts/1201734687.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1201734687.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ wkup.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// wkup.c#include &quot;wkup.h&quot;#include &quot;led.h&quot;#include &quot;delay.h&quot; void Sys_Standby(void)&#123; RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); //ä½¿èƒ½PWRå¤–è®¾æ—¶é’Ÿ PWR_WakeUpPinCmd(ENABLE); //ä½¿èƒ½å”¤é†’ç®¡è„šåŠŸèƒ½ PWR_EnterSTANDBYMode(); //è¿›å…¥å¾…å‘½ï¼ˆSTANDBYï¼‰æ¨¡å¼ &#125;//ç³»ç»Ÿè¿›å…¥å¾…æœºæ¨¡å¼void Sys_Enter_Standby(void)&#123; RCC_APB2PeriphResetCmd(0X01FC,DISABLE); //å¤ä½æ‰€æœ‰IOå£ Sys_Standby();&#125;//æ£€æµ‹WKUPè„šçš„ä¿¡å·//è¿”å›å€¼1:è¿ç»­æŒ‰ä¸‹3sä»¥ä¸Š// 0:é”™è¯¯çš„è§¦å‘ u8 Check_WKUP(void) &#123; u8 t=0; //è®°å½•æŒ‰ä¸‹çš„æ—¶é—´ LED0=0; //äº®ç¯DS0 while(1) &#123; if(WKUP_KD) &#123; t++; //å·²ç»æŒ‰ä¸‹äº† delay_ms(30); if(t&gt;=100) //æŒ‰ä¸‹è¶…è¿‡3ç§’é’Ÿ &#123; LED0=0; //ç‚¹äº®DS0 return 1; //æŒ‰ä¸‹3sä»¥ä¸Šäº† &#125; &#125;else &#123; LED0=1; return 0; //æŒ‰ä¸‹ä¸è¶³3ç§’ &#125; &#125;&#125; //ä¸­æ–­,æ£€æµ‹åˆ°PA0è„šçš„ä¸€ä¸ªä¸Šå‡æ²¿. //ä¸­æ–­çº¿0çº¿ä¸Šçš„ä¸­æ–­æ£€æµ‹void EXTI0_IRQHandler(void)&#123; EXTI_ClearITPendingBit(EXTI_Line0); // æ¸…é™¤LINE10ä¸Šçš„ä¸­æ–­æ ‡å¿—ä½ if(Check_WKUP())//å…³æœº? &#123; Sys_Enter_Standby(); &#125;&#125; //PA0 WKUPå”¤é†’åˆå§‹åŒ–void WKUP_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; EXTI_InitTypeDef EXTI_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);//ä½¿èƒ½GPIOAå’Œå¤ç”¨åŠŸèƒ½æ—¶é’Ÿ GPIO_InitStructure.GPIO_Pin =GPIO_Pin_0; //PA.0 GPIO_InitStructure.GPIO_Mode =GPIO_Mode_IPD;//ä¸Šæ‹‰è¾“å…¥ GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //åˆå§‹åŒ–IO //ä½¿ç”¨å¤–éƒ¨ä¸­æ–­æ–¹å¼ GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); //ä¸­æ–­çº¿0è¿æ¥GPIOA.0 EXTI_InitStructure.EXTI_Line = EXTI_Line0; //è®¾ç½®æŒ‰é”®æ‰€æœ‰çš„å¤–éƒ¨çº¿è·¯ EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; //è®¾å¤–å¤–éƒ¨ä¸­æ–­æ¨¡å¼:EXTIçº¿è·¯ä¸ºä¸­æ–­è¯·æ±‚ EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; //ä¸Šå‡æ²¿è§¦å‘ EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); // åˆå§‹åŒ–å¤–éƒ¨ä¸­æ–­ NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; //ä½¿èƒ½æŒ‰é”®æ‰€åœ¨çš„å¤–éƒ¨ä¸­æ–­é€šé“ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; //å…ˆå ä¼˜å…ˆçº§2çº§ NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; //ä»ä¼˜å…ˆçº§2çº§ NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //ä½¿èƒ½å¤–éƒ¨ä¸­æ–­é€šé“ NVIC_Init(&amp;NVIC_InitStructure); //æ ¹æ®NVIC_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾NVICå¯„å­˜å™¨ if(Check_WKUP()==0) Sys_Standby(); //ä¸æ˜¯å¼€æœº,è¿›å…¥å¾…æœºæ¨¡å¼ &#125;/******************* END OF FILE *********/ rtc.h 12345678910111213// wkup.h#ifndef __WKUP_H#define __WKUP_H #include &quot;sys.h&quot;#define WKUP_KD PAin(0) //PA0 æ£€æµ‹æ˜¯å¦å¤–éƒ¨WK_UPæŒ‰é”®æŒ‰ä¸‹ u8 Check_WKUP(void); //æ£€æµ‹WKUPè„šçš„ä¿¡å·void WKUP_Init(void); //PA0 WKUPå”¤é†’åˆå§‹åŒ–void Sys_Enter_Standby(void); //ç³»ç»Ÿè¿›å…¥å¾…æœºæ¨¡å¼#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;lcd.h&quot;#include &quot;usart.h&quot; #include &quot;wkup.h&quot; int main(void) &#123; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§åˆ†ç»„ä¸ºç»„2ï¼š2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //LEDç«¯å£åˆå§‹åŒ– WKUP_Init(); //å¾…æœºå”¤é†’åˆå§‹åŒ– LCD_Init(); //LCDåˆå§‹åŒ– POINT_COLOR=RED; LCD_ShowString(30,50,200,16,16,&quot;Elite STM32&quot;); LCD_ShowString(30,70,200,16,16,&quot;WKUP TEST&quot;); LCD_ShowString(30,90,200,16,16,&quot;ATOM@ALIENTEK&quot;); LCD_ShowString(30,110,200,16,16,&quot;2015/1/14&quot;); while(1) &#123; LED0=!LED0; delay_ms(250); &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ15ï¼‰RTCèŠ¯ç‰‡","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-015","date":"2022-11-08T03:59:18.000Z","updated":"2023-04-05T14:20:13.456Z","comments":true,"path":"posts/53287182.html","link":"","permalink":"https://sirius-tblog.github.io/posts/53287182.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ rtc.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250// rtc.c#include &quot;sys.h&quot;#include &quot;delay.h&quot;#include &quot;usart.h&quot;#include &quot;rtc.h&quot; _calendar_obj calendar;//æ—¶é’Ÿç»“æ„ä½“ static void RTC_NVIC_Config(void)&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn; //RTCå…¨å±€ä¸­æ–­ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //å…ˆå ä¼˜å…ˆçº§1ä½,ä»ä¼˜å…ˆçº§3ä½ NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; //å…ˆå ä¼˜å…ˆçº§0ä½,ä»ä¼˜å…ˆçº§4ä½ NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //ä½¿èƒ½è¯¥é€šé“ä¸­æ–­ NVIC_Init(&amp;NVIC_InitStructure); //æ ¹æ®NVIC_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾NVICå¯„å­˜å™¨&#125;//å®æ—¶æ—¶é’Ÿé…ç½®//åˆå§‹åŒ–RTCæ—¶é’Ÿ,åŒæ—¶æ£€æµ‹æ—¶é’Ÿæ˜¯å¦å·¥ä½œæ­£å¸¸//BKP-&gt;DR1ç”¨äºä¿å­˜æ˜¯å¦ç¬¬ä¸€æ¬¡é…ç½®çš„è®¾ç½®//è¿”å›0:æ­£å¸¸//å…¶ä»–:é”™è¯¯ä»£ç u8 RTC_Init(void)&#123; //æ£€æŸ¥æ˜¯ä¸æ˜¯ç¬¬ä¸€æ¬¡é…ç½®æ—¶é’Ÿ u8 temp=0; RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); //ä½¿èƒ½PWRå’ŒBKPå¤–è®¾æ—¶é’Ÿ PWR_BackupAccessCmd(ENABLE); //ä½¿èƒ½åå¤‡å¯„å­˜å™¨è®¿é—® if (BKP_ReadBackupRegister(BKP_DR1) != 0x5050) //ä»æŒ‡å®šçš„åå¤‡å¯„å­˜å™¨ä¸­è¯»å‡ºæ•°æ®:è¯»å‡ºäº†ä¸å†™å…¥çš„æŒ‡å®šæ•°æ®ä¸ç›¸ä¹ &#123; BKP_DeInit(); //å¤ä½å¤‡ä»½åŒºåŸŸ RCC_LSEConfig(RCC_LSE_ON); //è®¾ç½®å¤–éƒ¨ä½é€Ÿæ™¶æŒ¯(LSE),ä½¿ç”¨å¤–è®¾ä½é€Ÿæ™¶æŒ¯ while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET&amp;&amp;temp&lt;250) //æ£€æŸ¥æŒ‡å®šçš„RCCæ ‡å¿—ä½è®¾ç½®ä¸å¦,ç­‰å¾…ä½é€Ÿæ™¶æŒ¯å°±ç»ª &#123; temp++; delay_ms(10); &#125; if(temp&gt;=250)return 1;//åˆå§‹åŒ–æ—¶é’Ÿå¤±è´¥,æ™¶æŒ¯æœ‰é—®é¢˜ RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE); //è®¾ç½®RTCæ—¶é’Ÿ(RTCCLK),é€‰æ‹©LSEä½œä¸ºRTCæ—¶é’Ÿ RCC_RTCCLKCmd(ENABLE); //ä½¿èƒ½RTCæ—¶é’Ÿ RTC_WaitForLastTask(); //ç­‰å¾…æœ€è¿‘ä¸€æ¬¡å¯¹RTCå¯„å­˜å™¨çš„å†™æ“ä½œå®Œæˆ RTC_WaitForSynchro(); //ç­‰å¾…RTCå¯„å­˜å™¨åŒæ­¥ RTC_ITConfig(RTC_IT_SEC, ENABLE); //ä½¿èƒ½RTCç§’ä¸­æ–­ RTC_WaitForLastTask(); //ç­‰å¾…æœ€è¿‘ä¸€æ¬¡å¯¹RTCå¯„å­˜å™¨çš„å†™æ“ä½œå®Œæˆ RTC_EnterConfigMode();/// å…è®¸é…ç½® RTC_SetPrescaler(32767); //è®¾ç½®RTCé¢„åˆ†é¢‘çš„å€¼ RTC_WaitForLastTask(); //ç­‰å¾…æœ€è¿‘ä¸€æ¬¡å¯¹RTCå¯„å­˜å™¨çš„å†™æ“ä½œå®Œæˆ RTC_Set(2015,1,14,17,42,55); //è®¾ç½®æ—¶é—´ RTC_ExitConfigMode(); //é€€å‡ºé…ç½®æ¨¡å¼ BKP_WriteBackupRegister(BKP_DR1, 0X5050); //å‘æŒ‡å®šçš„åå¤‡å¯„å­˜å™¨ä¸­å†™å…¥ç”¨æˆ·ç¨‹åºæ•°æ® &#125; else//ç³»ç»Ÿç»§ç»­è®¡æ—¶ &#123; RTC_WaitForSynchro(); //ç­‰å¾…æœ€è¿‘ä¸€æ¬¡å¯¹RTCå¯„å­˜å™¨çš„å†™æ“ä½œå®Œæˆ RTC_ITConfig(RTC_IT_SEC, ENABLE); //ä½¿èƒ½RTCç§’ä¸­æ–­ RTC_WaitForLastTask(); //ç­‰å¾…æœ€è¿‘ä¸€æ¬¡å¯¹RTCå¯„å­˜å™¨çš„å†™æ“ä½œå®Œæˆ &#125; RTC_NVIC_Config();//RCTä¸­æ–­åˆ†ç»„è®¾ç½® RTC_Get();//æ›´æ–°æ—¶é—´ return 0; //ok&#125; //RTCæ—¶é’Ÿä¸­æ–­//æ¯ç§’è§¦å‘ä¸€æ¬¡ //extern u16 tcnt; void RTC_IRQHandler(void)&#123; if (RTC_GetITStatus(RTC_IT_SEC) != RESET)//ç§’é’Ÿä¸­æ–­ &#123; RTC_Get();//æ›´æ–°æ—¶é—´ &#125; if(RTC_GetITStatus(RTC_IT_ALR)!= RESET)//é—¹é’Ÿä¸­æ–­ &#123; RTC_ClearITPendingBit(RTC_IT_ALR); //æ¸…é—¹é’Ÿä¸­æ–­ RTC_Get(); //æ›´æ–°æ—¶é—´ printf(&quot;Alarm Time:%d-%d-%d %d:%d:%d\\n&quot;,calendar.w_year,calendar.w_month,calendar.w_date,calendar.hour,calendar.min,calendar.sec);//è¾“å‡ºé—¹é“ƒæ—¶é—´ &#125; RTC_ClearITPendingBit(RTC_IT_SEC|RTC_IT_OW); //æ¸…é—¹é’Ÿä¸­æ–­ RTC_WaitForLastTask(); &#125;//åˆ¤æ–­æ˜¯å¦æ˜¯é—°å¹´å‡½æ•°//æœˆä»½ 1 2 3 4 5 6 7 8 9 10 11 12//é—°å¹´ 31 29 31 30 31 30 31 31 30 31 30 31//éé—°å¹´ 31 28 31 30 31 30 31 31 30 31 30 31//è¾“å…¥:å¹´ä»½//è¾“å‡º:è¯¥å¹´ä»½æ˜¯ä¸æ˜¯é—°å¹´.1,æ˜¯.0,ä¸æ˜¯u8 Is_Leap_Year(u16 year)&#123; if(year%4==0) //å¿…é¡»èƒ½è¢«4æ•´é™¤ &#123; if(year%100==0) &#123; if(year%400==0)return 1;//å¦‚æœä»¥00ç»“å°¾,è¿˜è¦èƒ½è¢«400æ•´é™¤ else return 0; &#125;else return 1; &#125;else return 0; &#125; //è®¾ç½®æ—¶é’Ÿ//æŠŠè¾“å…¥çš„æ—¶é’Ÿè½¬æ¢ä¸ºç§’é’Ÿ//ä»¥1970å¹´1æœˆ1æ—¥ä¸ºåŸºå‡†//1970~2099å¹´ä¸ºåˆæ³•å¹´ä»½//è¿”å›å€¼:0,æˆåŠŸ;å…¶ä»–:é”™è¯¯ä»£ç .//æœˆä»½æ•°æ®è¡¨ u8 const table_week[12]=&#123;0,3,3,6,1,4,6,2,5,0,3,5&#125;; //æœˆä¿®æ­£æ•°æ®è¡¨ //å¹³å¹´çš„æœˆä»½æ—¥æœŸè¡¨const u8 mon_table[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;u8 RTC_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)&#123; u16 t; u32 seccount=0; if(syear&lt;1970||syear&gt;2099)return 1; for(t=1970;t&lt;syear;t++) //æŠŠæ‰€æœ‰å¹´ä»½çš„ç§’é’Ÿç›¸åŠ  &#123; if(Is_Leap_Year(t))seccount+=31622400;//é—°å¹´çš„ç§’é’Ÿæ•° else seccount+=31536000; //å¹³å¹´çš„ç§’é’Ÿæ•° &#125; smon-=1; for(t=0;t&lt;smon;t++) //æŠŠå‰é¢æœˆä»½çš„ç§’é’Ÿæ•°ç›¸åŠ  &#123; seccount+=(u32)mon_table[t]*86400;//æœˆä»½ç§’é’Ÿæ•°ç›¸åŠ  if(Is_Leap_Year(syear)&amp;&amp;t==1)seccount+=86400;//é—°å¹´2æœˆä»½å¢åŠ ä¸€å¤©çš„ç§’é’Ÿæ•° &#125; seccount+=(u32)(sday-1)*86400;//æŠŠå‰é¢æ—¥æœŸçš„ç§’é’Ÿæ•°ç›¸åŠ  seccount+=(u32)hour*3600;//å°æ—¶ç§’é’Ÿæ•° seccount+=(u32)min*60; //åˆ†é’Ÿç§’é’Ÿæ•° seccount+=sec;//æœ€åçš„ç§’é’ŸåŠ ä¸Šå» RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); //ä½¿èƒ½PWRå’ŒBKPå¤–è®¾æ—¶é’Ÿ PWR_BackupAccessCmd(ENABLE); //ä½¿èƒ½RTCå’Œåå¤‡å¯„å­˜å™¨è®¿é—® RTC_SetCounter(seccount); //è®¾ç½®RTCè®¡æ•°å™¨çš„å€¼ RTC_WaitForLastTask(); //ç­‰å¾…æœ€è¿‘ä¸€æ¬¡å¯¹RTCå¯„å­˜å™¨çš„å†™æ“ä½œå®Œæˆ return 0; &#125;//åˆå§‹åŒ–é—¹é’Ÿ //ä»¥1970å¹´1æœˆ1æ—¥ä¸ºåŸºå‡†//1970~2099å¹´ä¸ºåˆæ³•å¹´ä»½//syear,smon,sday,hour,min,secï¼šé—¹é’Ÿçš„å¹´æœˆæ—¥æ—¶åˆ†ç§’ //è¿”å›å€¼:0,æˆåŠŸ;å…¶ä»–:é”™è¯¯ä»£ç .u8 RTC_Alarm_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)&#123; u16 t; u32 seccount=0; if(syear&lt;1970||syear&gt;2099)return 1; for(t=1970;t&lt;syear;t++) //æŠŠæ‰€æœ‰å¹´ä»½çš„ç§’é’Ÿç›¸åŠ  &#123; if(Is_Leap_Year(t))seccount+=31622400;//é—°å¹´çš„ç§’é’Ÿæ•° else seccount+=31536000; //å¹³å¹´çš„ç§’é’Ÿæ•° &#125; smon-=1; for(t=0;t&lt;smon;t++) //æŠŠå‰é¢æœˆä»½çš„ç§’é’Ÿæ•°ç›¸åŠ  &#123; seccount+=(u32)mon_table[t]*86400;//æœˆä»½ç§’é’Ÿæ•°ç›¸åŠ  if(Is_Leap_Year(syear)&amp;&amp;t==1)seccount+=86400;//é—°å¹´2æœˆä»½å¢åŠ ä¸€å¤©çš„ç§’é’Ÿæ•° &#125; seccount+=(u32)(sday-1)*86400;//æŠŠå‰é¢æ—¥æœŸçš„ç§’é’Ÿæ•°ç›¸åŠ  seccount+=(u32)hour*3600;//å°æ—¶ç§’é’Ÿæ•° seccount+=(u32)min*60; //åˆ†é’Ÿç§’é’Ÿæ•° seccount+=sec;//æœ€åçš„ç§’é’ŸåŠ ä¸Šå» //è®¾ç½®æ—¶é’Ÿ RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); //ä½¿èƒ½PWRå’ŒBKPå¤–è®¾æ—¶é’Ÿ PWR_BackupAccessCmd(ENABLE); //ä½¿èƒ½åå¤‡å¯„å­˜å™¨è®¿é—® //ä¸Šé¢ä¸‰æ­¥æ˜¯å¿…é¡»çš„! RTC_SetAlarm(seccount); RTC_WaitForLastTask(); //ç­‰å¾…æœ€è¿‘ä¸€æ¬¡å¯¹RTCå¯„å­˜å™¨çš„å†™æ“ä½œå®Œæˆ return 0; &#125;//å¾—åˆ°å½“å‰çš„æ—¶é—´//è¿”å›å€¼:0,æˆåŠŸ;å…¶ä»–:é”™è¯¯ä»£ç .u8 RTC_Get(void)&#123; static u16 daycnt=0; u32 timecount=0; u32 temp=0; u16 temp1=0; timecount=RTC_GetCounter(); temp=timecount/86400; //å¾—åˆ°å¤©æ•°(ç§’é’Ÿæ•°å¯¹åº”çš„) if(daycnt!=temp)//è¶…è¿‡ä¸€å¤©äº† &#123; daycnt=temp; temp1=1970; //ä»1970å¹´å¼€å§‹ while(temp&gt;=365) &#123; if(Is_Leap_Year(temp1))//æ˜¯é—°å¹´ &#123; if(temp&gt;=366)temp-=366;//é—°å¹´çš„ç§’é’Ÿæ•° else &#123;temp1++;break;&#125; &#125; else temp-=365; //å¹³å¹´ temp1++; &#125; calendar.w_year=temp1;//å¾—åˆ°å¹´ä»½ temp1=0; while(temp&gt;=28)//è¶…è¿‡äº†ä¸€ä¸ªæœˆ &#123; if(Is_Leap_Year(calendar.w_year)&amp;&amp;temp1==1)//å½“å¹´æ˜¯ä¸æ˜¯é—°å¹´/2æœˆä»½ &#123; if(temp&gt;=29)temp-=29;//é—°å¹´çš„ç§’é’Ÿæ•° else break; &#125; else &#123; if(temp&gt;=mon_table[temp1])temp-=mon_table[temp1];//å¹³å¹´ else break; &#125; temp1++; &#125; calendar.w_month=temp1+1; //å¾—åˆ°æœˆä»½ calendar.w_date=temp+1; //å¾—åˆ°æ—¥æœŸ &#125; temp=timecount%86400; //å¾—åˆ°ç§’é’Ÿæ•° calendar.hour=temp/3600; //å°æ—¶ calendar.min=(temp%3600)/60; //åˆ†é’Ÿ calendar.sec=(temp%3600)%60; //ç§’é’Ÿ calendar.week=RTC_Get_Week(calendar.w_year,calendar.w_month,calendar.w_date);//è·å–æ˜ŸæœŸ return 0;&#125; //è·å¾—ç°åœ¨æ˜¯æ˜ŸæœŸå‡ //åŠŸèƒ½æè¿°:è¾“å…¥å…¬å†æ—¥æœŸå¾—åˆ°æ˜ŸæœŸ(åªå…è®¸1901-2099å¹´)//è¾“å…¥å‚æ•°ï¼šå…¬å†å¹´æœˆæ—¥ //è¿”å›å€¼ï¼šæ˜ŸæœŸå· u8 RTC_Get_Week(u16 year,u8 month,u8 day)&#123; u16 temp2; u8 yearH,yearL; yearH=year/100; yearL=year%100; // å¦‚æœä¸º21ä¸–çºª,å¹´ä»½æ•°åŠ 100 if (yearH&gt;19)yearL+=100; // æ‰€è¿‡é—°å¹´æ•°åªç®—1900å¹´ä¹‹åçš„ temp2=yearL+yearL/4; temp2=temp2%7; temp2=temp2+day+table_week[month-1]; if (yearL%4==0&amp;&amp;month&lt;3)temp2--; return(temp2%7);&#125; /******************* END OF FILE *********/ rtc.h 12345678910111213141516171819202122232425262728293031// rtc.h#ifndef __RTC_H#define __RTC_H //æ—¶é—´ç»“æ„ä½“typedef struct &#123; vu8 hour; vu8 min; vu8 sec; //å…¬å†æ—¥æœˆå¹´å‘¨ vu16 w_year; vu8 w_month; vu8 w_date; vu8 week; &#125;_calendar_obj; extern _calendar_obj calendar; //æ—¥å†ç»“æ„ä½“extern u8 const mon_table[12]; //æœˆä»½æ—¥æœŸæ•°æ®è¡¨void Disp_Time(u8 x,u8 y,u8 size);//åœ¨åˆ¶å®šä½ç½®å¼€å§‹æ˜¾ç¤ºæ—¶é—´void Disp_Week(u8 x,u8 y,u8 size,u8 lang);//åœ¨æŒ‡å®šä½ç½®æ˜¾ç¤ºæ˜ŸæœŸu8 RTC_Init(void); //åˆå§‹åŒ–RTC,è¿”å›0,å¤±è´¥;1,æˆåŠŸ;u8 Is_Leap_Year(u16 year);//å¹³å¹´,é—°å¹´åˆ¤æ–­u8 RTC_Alarm_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec);u8 RTC_Get(void); //æ›´æ–°æ—¶é—´ u8 RTC_Get_Week(u16 year,u8 month,u8 day);u8 RTC_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec);//è®¾ç½®æ—¶é—´ #endif/******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;lcd.h&quot;#include &quot;usart.h&quot; #include &quot;usmart.h&quot; #include &quot;rtc.h&quot; int main(void) &#123; u8 t=0; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§åˆ†ç»„ä¸ºç»„2ï¼š2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //LEDç«¯å£åˆå§‹åŒ– LCD_Init(); usmart_dev.init(SystemCoreClock/1000000); //åˆå§‹åŒ–USMART RTC_Init(); //RTCåˆå§‹åŒ– POINT_COLOR=RED;//è®¾ç½®å­—ä½“ä¸ºçº¢è‰² LCD_ShowString(60,50,200,16,16,&quot;Elite STM32&quot;); LCD_ShowString(60,70,200,16,16,&quot;RTC TEST&quot;); LCD_ShowString(60,90,200,16,16,&quot;ATOM@ALIENTEK&quot;); LCD_ShowString(60,110,200,16,16,&quot;2015/1/14&quot;); //æ˜¾ç¤ºæ—¶é—´ POINT_COLOR=BLUE;//è®¾ç½®å­—ä½“ä¸ºè“è‰² LCD_ShowString(60,130,200,16,16,&quot; - - &quot;); LCD_ShowString(60,162,200,16,16,&quot; : : &quot;); while(1) &#123; if(t!=calendar.sec) &#123; t=calendar.sec; LCD_ShowNum(60,130,calendar.w_year,4,16); LCD_ShowNum(100,130,calendar.w_month,2,16); LCD_ShowNum(124,130,calendar.w_date,2,16); switch(calendar.week) &#123; case 0: LCD_ShowString(60,148,200,16,16,&quot;Sunday &quot;); break; case 1: LCD_ShowString(60,148,200,16,16,&quot;Monday &quot;); break; case 2: LCD_ShowString(60,148,200,16,16,&quot;Tuesday &quot;); break; case 3: LCD_ShowString(60,148,200,16,16,&quot;Wednesday&quot;); break; case 4: LCD_ShowString(60,148,200,16,16,&quot;Thursday &quot;); break; case 5: LCD_ShowString(60,148,200,16,16,&quot;Friday &quot;); break; case 6: LCD_ShowString(60,148,200,16,16,&quot;Saturday &quot;); break; &#125; LCD_ShowNum(60,162,calendar.hour,2,16); LCD_ShowNum(84,162,calendar.min,2,16); LCD_ShowNum(108,162,calendar.sec,2,16); LED0=!LED0; &#125; delay_ms(10); &#125;; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ14ï¼‰USMARTè°ƒè¯•","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-014","date":"2022-11-08T03:39:18.000Z","updated":"2023-04-05T14:20:04.871Z","comments":true,"path":"posts/3783971557.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3783971557.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ usmart.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385// usmart.c#include &quot;usmart.h&quot;#include &quot;usart.h&quot;#include &quot;sys.h&quot;//ç³»ç»Ÿå‘½ä»¤u8 *sys_cmd_tab[]=&#123; &quot;?&quot;, &quot;help&quot;, &quot;list&quot;, &quot;id&quot;, &quot;hex&quot;, &quot;dec&quot;, &quot;runtime&quot;, &#125;; //å¤„ç†ç³»ç»ŸæŒ‡ä»¤//0,æˆåŠŸå¤„ç†;å…¶ä»–,é”™è¯¯ä»£ç ;u8 usmart_sys_cmd_exe(u8 *str)&#123; u8 i; u8 sfname[MAX_FNAME_LEN];//å­˜æ”¾æœ¬åœ°å‡½æ•°å u8 pnum; u8 rval; u32 res; res=usmart_get_cmdname(str,sfname,&amp;i,MAX_FNAME_LEN);//å¾—åˆ°æŒ‡ä»¤åŠæŒ‡ä»¤é•¿åº¦ if(res)return USMART_FUNCERR;//é”™è¯¯çš„æŒ‡ä»¤ str+=i; for(i=0;i&lt;sizeof(sys_cmd_tab)/4;i++)//æ”¯æŒçš„ç³»ç»ŸæŒ‡ä»¤ &#123; if(usmart_strcmp(sfname,sys_cmd_tab[i])==0)break; &#125; switch(i) &#123; case 0: case 1://å¸®åŠ©æŒ‡ä»¤ printf(&quot;\\r\\n&quot;);#if USMART_USE_HELP printf(&quot;------------------------USMART V3.1------------------------ \\r\\n&quot;); printf(&quot; USMARTæ˜¯ç”±ALIENTEKå¼€å‘çš„ä¸€ä¸ªçµå·§çš„ä¸²å£è°ƒè¯•äº’äº¤ç»„ä»¶,é€šè¿‡ \\r\\n&quot;); printf(&quot;å®ƒ,ä½ å¯ä»¥é€šè¿‡ä¸²å£åŠ©æ‰‹è°ƒç”¨ç¨‹åºé‡Œé¢çš„ä»»ä½•å‡½æ•°,å¹¶æ‰§è¡Œ.å› æ­¤,ä½ å¯\\r\\n&quot;); printf(&quot;ä»¥éšæ„æ›´æ”¹å‡½æ•°çš„è¾“å…¥å‚æ•°(æ”¯æŒæ•°å­—(10/16è¿›åˆ¶)ã€å­—ç¬¦ä¸²ã€å‡½æ•°å…¥\\r\\n&quot;); printf(&quot;å£åœ°å€ç­‰ä½œä¸ºå‚æ•°),å•ä¸ªå‡½æ•°æœ€å¤šæ”¯æŒ10ä¸ªè¾“å…¥å‚æ•°,å¹¶æ”¯æŒå‡½æ•°è¿” \\r\\n&quot;); printf(&quot;å›å€¼æ˜¾ç¤º.æ–°å¢å‚æ•°æ˜¾ç¤ºè¿›åˆ¶è®¾ç½®åŠŸèƒ½,æ–°å¢è¿›åˆ¶è½¬æ¢åŠŸèƒ½.\\r\\n&quot;); printf(&quot;æŠ€æœ¯æ”¯æŒ:www.openedv.com\\r\\n&quot;); printf(&quot;USMARTæœ‰7ä¸ªç³»ç»Ÿå‘½ä»¤:\\r\\n&quot;); printf(&quot;?: è·å–å¸®åŠ©ä¿¡æ¯\\r\\n&quot;); printf(&quot;help: è·å–å¸®åŠ©ä¿¡æ¯\\r\\n&quot;); printf(&quot;list: å¯ç”¨çš„å‡½æ•°åˆ—è¡¨\\r\\n\\n&quot;); printf(&quot;id: å¯ç”¨å‡½æ•°çš„IDåˆ—è¡¨\\r\\n\\n&quot;); printf(&quot;hex: å‚æ•°16è¿›åˆ¶æ˜¾ç¤º,åè·Ÿç©ºæ ¼+æ•°å­—å³æ‰§è¡Œè¿›åˆ¶è½¬æ¢\\r\\n\\n&quot;); printf(&quot;dec: å‚æ•°10è¿›åˆ¶æ˜¾ç¤º,åè·Ÿç©ºæ ¼+æ•°å­—å³æ‰§è¡Œè¿›åˆ¶è½¬æ¢\\r\\n\\n&quot;); printf(&quot;runtime:1,å¼€å¯å‡½æ•°è¿è¡Œè®¡æ—¶;0,å…³é—­å‡½æ•°è¿è¡Œè®¡æ—¶;\\r\\n\\n&quot;); printf(&quot;è¯·æŒ‰ç…§ç¨‹åºç¼–å†™æ ¼å¼è¾“å…¥å‡½æ•°ååŠå‚æ•°å¹¶ä»¥å›è½¦é”®ç»“æŸ.\\r\\n&quot;); printf(&quot;--------------------------ALIENTEK------------------------- \\r\\n&quot;);#else printf(&quot;æŒ‡ä»¤å¤±æ•ˆ\\r\\n&quot;);#endif break; case 2://æŸ¥è¯¢æŒ‡ä»¤ printf(&quot;\\r\\n&quot;); printf(&quot;-------------------------å‡½æ•°æ¸…å•--------------------------- \\r\\n&quot;); for(i=0;i&lt;usmart_dev.fnum;i++)printf(&quot;%s\\r\\n&quot;,usmart_dev.funs[i].name); printf(&quot;\\r\\n&quot;); break; case 3://æŸ¥è¯¢ID printf(&quot;\\r\\n&quot;); printf(&quot;-------------------------å‡½æ•° ID --------------------------- \\r\\n&quot;); for(i=0;i&lt;usmart_dev.fnum;i++) &#123; usmart_get_fname((u8*)usmart_dev.funs[i].name,sfname,&amp;pnum,&amp;rval);//å¾—åˆ°æœ¬åœ°å‡½æ•°å printf(&quot;%s id is:\\r\\n0X%08X\\r\\n&quot;,sfname,usmart_dev.funs[i].func); //æ˜¾ç¤ºID &#125; printf(&quot;\\r\\n&quot;); break; case 4://hexæŒ‡ä»¤ printf(&quot;\\r\\n&quot;); usmart_get_aparm(str,sfname,&amp;i); if(i==0)//å‚æ•°æ­£å¸¸ &#123; i=usmart_str2num(sfname,&amp;res); //è®°å½•è¯¥å‚æ•° if(i==0) //è¿›åˆ¶è½¬æ¢åŠŸèƒ½ &#123; printf(&quot;HEX:0X%X\\r\\n&quot;,res); //è½¬ä¸º16è¿›åˆ¶ &#125;else if(i!=4)return USMART_PARMERR;//å‚æ•°é”™è¯¯. else //å‚æ•°æ˜¾ç¤ºè®¾å®šåŠŸèƒ½ &#123; printf(&quot;16è¿›åˆ¶å‚æ•°æ˜¾ç¤º!\\r\\n&quot;); usmart_dev.sptype=SP_TYPE_HEX; &#125; &#125;else return USMART_PARMERR; //å‚æ•°é”™è¯¯. printf(&quot;\\r\\n&quot;); break; case 5://decæŒ‡ä»¤ printf(&quot;\\r\\n&quot;); usmart_get_aparm(str,sfname,&amp;i); if(i==0)//å‚æ•°æ­£å¸¸ &#123; i=usmart_str2num(sfname,&amp;res); //è®°å½•è¯¥å‚æ•° if(i==0) //è¿›åˆ¶è½¬æ¢åŠŸèƒ½ &#123; printf(&quot;DEC:%lu\\r\\n&quot;,res); //è½¬ä¸º10è¿›åˆ¶ &#125;else if(i!=4)return USMART_PARMERR;//å‚æ•°é”™è¯¯. else //å‚æ•°æ˜¾ç¤ºè®¾å®šåŠŸèƒ½ &#123; printf(&quot;10è¿›åˆ¶å‚æ•°æ˜¾ç¤º!\\r\\n&quot;); usmart_dev.sptype=SP_TYPE_DEC; &#125; &#125;else return USMART_PARMERR; //å‚æ•°é”™è¯¯. printf(&quot;\\r\\n&quot;); break; case 6://runtimeæŒ‡ä»¤,è®¾ç½®æ˜¯å¦æ˜¾ç¤ºå‡½æ•°æ‰§è¡Œæ—¶é—´ printf(&quot;\\r\\n&quot;); usmart_get_aparm(str,sfname,&amp;i); if(i==0)//å‚æ•°æ­£å¸¸ &#123; i=usmart_str2num(sfname,&amp;res); //è®°å½•è¯¥å‚æ•° if(i==0) //è¯»å–æŒ‡å®šåœ°å€æ•°æ®åŠŸèƒ½ &#123; if(USMART_ENTIMX_SCAN==0)printf(&quot;\\r\\nError! \\r\\nTo EN RunTime function,Please set USMART_ENTIMX_SCAN = 1 first!\\r\\n&quot;);//æŠ¥é”™ else &#123; usmart_dev.runtimeflag=res; if(usmart_dev.runtimeflag)printf(&quot;Run Time Calculation ON\\r\\n&quot;); else printf(&quot;Run Time Calculation OFF\\r\\n&quot;); &#125; &#125;else return USMART_PARMERR; //æœªå¸¦å‚æ•°,æˆ–è€…å‚æ•°é”™è¯¯ &#125;else return USMART_PARMERR; //å‚æ•°é”™è¯¯. printf(&quot;\\r\\n&quot;); break; default://éæ³•æŒ‡ä»¤ return USMART_FUNCERR; &#125; return 0;&#125;//////////////////////////////////////////////////////////////////////////////////////////ç§»æ¤æ³¨æ„:æœ¬ä¾‹æ˜¯ä»¥stm32ä¸ºä¾‹,å¦‚æœè¦ç§»æ¤åˆ°å…¶ä»–mcu,è¯·åšç›¸åº”ä¿®æ”¹.//usmart_reset_runtime,æ¸…é™¤å‡½æ•°è¿è¡Œæ—¶é—´,è¿åŒå®šæ—¶å™¨çš„è®¡æ•°å¯„å­˜å™¨ä»¥åŠæ ‡å¿—ä½ä¸€èµ·æ¸…é›¶.å¹¶è®¾ç½®é‡è£…è½½å€¼ä¸ºæœ€å¤§,ä»¥æœ€å¤§é™åº¦çš„å»¶é•¿è®¡æ—¶æ—¶é—´.//usmart_get_runtime,è·å–å‡½æ•°è¿è¡Œæ—¶é—´,é€šè¿‡è¯»å–CNTå€¼è·å–,ç”±äºusmartæ˜¯é€šè¿‡ä¸­æ–­è°ƒç”¨çš„å‡½æ•°,æ‰€ä»¥å®šæ—¶å™¨ä¸­æ–­ä¸å†æœ‰æ•ˆ,æ­¤æ—¶æœ€å¤§é™åº¦//åªèƒ½ç»Ÿè®¡2æ¬¡CNTçš„å€¼,ä¹Ÿå°±æ˜¯æ¸…é›¶å+æº¢å‡ºä¸€æ¬¡,å½“æº¢å‡ºè¶…è¿‡2æ¬¡,æ²¡æ³•å¤„ç†,æ‰€ä»¥æœ€å¤§å»¶æ—¶,æ§åˆ¶åœ¨:2*è®¡æ•°å™¨CNT*0.1ms.å¯¹STM32æ¥è¯´,æ˜¯:13.1så·¦å³//å…¶ä»–çš„:TIM4_IRQHandlerå’ŒTimer2_Init,éœ€è¦æ ¹æ®MCUç‰¹ç‚¹è‡ªè¡Œä¿®æ”¹.ç¡®ä¿è®¡æ•°å™¨è®¡æ•°é¢‘ç‡ä¸º:10Khzå³å¯.å¦å¤–,å®šæ—¶å™¨ä¸è¦å¼€å¯è‡ªåŠ¨é‡è£…è½½åŠŸèƒ½!!#if USMART_ENTIMX_SCAN==1//å¤ä½runtime//éœ€è¦æ ¹æ®æ‰€ç§»æ¤åˆ°çš„MCUçš„å®šæ—¶å™¨å‚æ•°è¿›è¡Œä¿®æ”¹void usmart_reset_runtime(void)&#123; TIM_ClearFlag(TIM4,TIM_FLAG_Update);//æ¸…é™¤ä¸­æ–­æ ‡å¿—ä½ TIM_SetAutoreload(TIM4,0XFFFF);//å°†é‡è£…è½½å€¼è®¾ç½®åˆ°æœ€å¤§ TIM_SetCounter(TIM4,0); //æ¸…ç©ºå®šæ—¶å™¨çš„CNT usmart_dev.runtime=0; &#125;//è·å¾—runtimeæ—¶é—´//è¿”å›å€¼:æ‰§è¡Œæ—¶é—´,å•ä½:0.1ms,æœ€å¤§å»¶æ—¶æ—¶é—´ä¸ºå®šæ—¶å™¨CNTå€¼çš„2å€*0.1ms//éœ€è¦æ ¹æ®æ‰€ç§»æ¤åˆ°çš„MCUçš„å®šæ—¶å™¨å‚æ•°è¿›è¡Œä¿®æ”¹u32 usmart_get_runtime(void)&#123; if(TIM_GetFlagStatus(TIM4,TIM_FLAG_Update)==SET)//åœ¨è¿è¡ŒæœŸé—´,äº§ç”Ÿäº†å®šæ—¶å™¨æº¢å‡º &#123; usmart_dev.runtime+=0XFFFF; &#125; usmart_dev.runtime+=TIM_GetCounter(TIM4); return usmart_dev.runtime; //è¿”å›è®¡æ•°å€¼&#125;//ä¸‹é¢è¿™ä¸¤ä¸ªå‡½æ•°,éUSMARTå‡½æ•°,æ”¾åˆ°è¿™é‡Œ,ä»…ä»…æ–¹ä¾¿ç§»æ¤. //å®šæ—¶å™¨4ä¸­æ–­æœåŠ¡ç¨‹åº void TIM4_IRQHandler(void)&#123; if(TIM_GetITStatus(TIM4,TIM_IT_Update)==SET)//æº¢å‡ºä¸­æ–­ &#123; usmart_dev.scan(); //æ‰§è¡Œusmartæ‰«æ TIM_SetCounter(TIM4,0); //æ¸…ç©ºå®šæ—¶å™¨çš„CNT TIM_SetAutoreload(TIM4,100);//æ¢å¤åŸæ¥çš„è®¾ç½® &#125; TIM_ClearITPendingBit(TIM4,TIM_IT_Update); //æ¸…é™¤ä¸­æ–­æ ‡å¿—ä½ &#125;//ä½¿èƒ½å®šæ—¶å™¨4,ä½¿èƒ½ä¸­æ–­.void Timer4_Init(u16 arr,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE); //TIM4æ—¶é’Ÿä½¿èƒ½ //TIM4åˆå§‹åŒ–è®¾ç½® TIM_TimeBaseStructure.TIM_Period = arr; //è®¾ç½®åœ¨ä¸‹ä¸€ä¸ªæ›´æ–°äº‹ä»¶è£…å…¥æ´»åŠ¨çš„è‡ªåŠ¨é‡è£…è½½å¯„å­˜å™¨å‘¨æœŸçš„å€¼ è®¡æ•°åˆ°5000ä¸º500ms TIM_TimeBaseStructure.TIM_Prescaler =psc; //è®¾ç½®ç”¨æ¥ä½œä¸ºTIMxæ—¶é’Ÿé¢‘ç‡é™¤æ•°çš„é¢„åˆ†é¢‘å€¼ 10Khzçš„è®¡æ•°é¢‘ç‡ TIM_TimeBaseStructure.TIM_ClockDivision = 0; //è®¾ç½®æ—¶é’Ÿåˆ†å‰²:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIMå‘ä¸Šè®¡æ•°æ¨¡å¼ TIM_TimeBaseInit(TIM4, &amp;TIM_TimeBaseStructure); //æ ¹æ®TIM_TimeBaseInitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–TIMxçš„æ—¶é—´åŸºæ•°å•ä½ TIM_ITConfig( TIM4, TIM_IT_Update|TIM_IT_Trigger, ENABLE );//TIM4 å…è®¸æ›´æ–°ï¼Œè§¦å‘ä¸­æ–­ //TIM4ä¸­æ–­åˆ†ç»„é…ç½® NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn; //TIM3ä¸­æ–­ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //å…ˆå ä¼˜å…ˆçº§03çº§ NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //ä»ä¼˜å…ˆçº§3çº§ NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQé€šé“è¢«ä½¿èƒ½ NVIC_Init(&amp;NVIC_InitStructure); //æ ¹æ®NVIC_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾NVICå¯„å­˜å™¨ TIM_Cmd(TIM4, ENABLE); //ä½¿èƒ½TIM4 &#125;#endif//////////////////////////////////////////////////////////////////////////////////////////åˆå§‹åŒ–ä¸²å£æ§åˆ¶å™¨//sysclk:ç³»ç»Ÿæ—¶é’Ÿï¼ˆMhzï¼‰void usmart_init(u8 sysclk)&#123;#if USMART_ENTIMX_SCAN==1 Timer4_Init(1000,(u32)sysclk*100-1);//åˆ†é¢‘,æ—¶é’Ÿä¸º10K ,100msä¸­æ–­ä¸€æ¬¡,æ³¨æ„,è®¡æ•°é¢‘ç‡å¿…é¡»ä¸º10Khz,ä»¥å’Œruntimeå•ä½(0.1ms)åŒæ­¥.#endif usmart_dev.sptype=1; //åå…­è¿›åˆ¶æ˜¾ç¤ºå‚æ•°&#125; //ä»strä¸­è·å–å‡½æ•°å,id,åŠå‚æ•°ä¿¡æ¯//*str:å­—ç¬¦ä¸²æŒ‡é’ˆ.//è¿”å›å€¼:0,è¯†åˆ«æˆåŠŸ;å…¶ä»–,é”™è¯¯ä»£ç .u8 usmart_cmd_rec(u8*str) &#123; u8 sta,i,rval;//çŠ¶æ€ u8 rpnum,spnum; u8 rfname[MAX_FNAME_LEN];//æš‚å­˜ç©ºé—´,ç”¨äºå­˜æ”¾æ¥æ”¶åˆ°çš„å‡½æ•°å u8 sfname[MAX_FNAME_LEN];//å­˜æ”¾æœ¬åœ°å‡½æ•°å sta=usmart_get_fname(str,rfname,&amp;rpnum,&amp;rval);//å¾—åˆ°æ¥æ”¶åˆ°çš„æ•°æ®çš„å‡½æ•°ååŠå‚æ•°ä¸ªæ•° if(sta)return sta;//é”™è¯¯ for(i=0;i&lt;usmart_dev.fnum;i++) &#123; sta=usmart_get_fname((u8*)usmart_dev.funs[i].name,sfname,&amp;spnum,&amp;rval);//å¾—åˆ°æœ¬åœ°å‡½æ•°ååŠå‚æ•°ä¸ªæ•° if(sta)return sta;//æœ¬åœ°è§£ææœ‰è¯¯ if(usmart_strcmp(sfname,rfname)==0)//ç›¸ç­‰ &#123; if(spnum&gt;rpnum)return USMART_PARMERR;//å‚æ•°é”™è¯¯(è¾“å…¥å‚æ•°æ¯”æºå‡½æ•°å‚æ•°å°‘) usmart_dev.id=i;//è®°å½•å‡½æ•°ID. break;//è·³å‡º. &#125; &#125; if(i==usmart_dev.fnum)return USMART_NOFUNCFIND; //æœªæ‰¾åˆ°åŒ¹é…çš„å‡½æ•° sta=usmart_get_fparam(str,&amp;i); //å¾—åˆ°å‡½æ•°å‚æ•°ä¸ªæ•° if(sta)return sta; //è¿”å›é”™è¯¯ usmart_dev.pnum=i; //å‚æ•°ä¸ªæ•°è®°å½• return USMART_OK;&#125;//usamrtæ‰§è¡Œå‡½æ•°//è¯¥å‡½æ•°ç”¨äºæœ€ç»ˆæ‰§è¡Œä»ä¸²å£æ”¶åˆ°çš„æœ‰æ•ˆå‡½æ•°.//æœ€å¤šæ”¯æŒ10ä¸ªå‚æ•°çš„å‡½æ•°,æ›´å¤šçš„å‚æ•°æ”¯æŒä¹Ÿå¾ˆå®¹æ˜“å®ç°.ä¸è¿‡ç”¨çš„å¾ˆå°‘.ä¸€èˆ¬5ä¸ªå·¦å³çš„å‚æ•°çš„å‡½æ•°å·²ç»å¾ˆå°‘è§äº†.//è¯¥å‡½æ•°ä¼šåœ¨ä¸²å£æ‰“å°æ‰§è¡Œæƒ…å†µ.ä»¥:&quot;å‡½æ•°å(å‚æ•°1ï¼Œå‚æ•°2...å‚æ•°N)=è¿”å›å€¼&quot;.çš„å½¢å¼æ‰“å°.//å½“æ‰€æ‰§è¡Œçš„å‡½æ•°æ²¡æœ‰è¿”å›å€¼çš„æ—¶å€™,æ‰€æ‰“å°çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªæ— æ„ä¹‰çš„æ•°æ®.void usmart_exe(void)&#123; u8 id,i; u32 res; u32 temp[MAX_PARM];//å‚æ•°è½¬æ¢,ä½¿ä¹‹æ”¯æŒäº†å­—ç¬¦ä¸² u8 sfname[MAX_FNAME_LEN];//å­˜æ”¾æœ¬åœ°å‡½æ•°å u8 pnum,rval; id=usmart_dev.id; if(id&gt;=usmart_dev.fnum)return;//ä¸æ‰§è¡Œ. usmart_get_fname((u8*)usmart_dev.funs[id].name,sfname,&amp;pnum,&amp;rval);//å¾—åˆ°æœ¬åœ°å‡½æ•°å,åŠå‚æ•°ä¸ªæ•° printf(&quot;\\r\\n%s(&quot;,sfname);//è¾“å‡ºæ­£è¦æ‰§è¡Œçš„å‡½æ•°å for(i=0;i&lt;pnum;i++)//è¾“å‡ºå‚æ•° &#123; if(usmart_dev.parmtype&amp;(1&lt;&lt;i))//å‚æ•°æ˜¯å­—ç¬¦ä¸² &#123; printf(&quot;%c&quot;,&#x27;&quot;&#x27;); printf(&quot;%s&quot;,usmart_dev.parm+usmart_get_parmpos(i)); printf(&quot;%c&quot;,&#x27;&quot;&#x27;); temp[i]=(u32)&amp;(usmart_dev.parm[usmart_get_parmpos(i)]); &#125;else //å‚æ•°æ˜¯æ•°å­— &#123; temp[i]=*(u32*)(usmart_dev.parm+usmart_get_parmpos(i)); if(usmart_dev.sptype==SP_TYPE_DEC)printf(&quot;%lu&quot;,temp[i]);//10è¿›åˆ¶å‚æ•°æ˜¾ç¤º else printf(&quot;0X%X&quot;,temp[i]);//16è¿›åˆ¶å‚æ•°æ˜¾ç¤º &#125; if(i!=pnum-1)printf(&quot;,&quot;); &#125; printf(&quot;)&quot;); usmart_reset_runtime(); //è®¡æ—¶å™¨æ¸…é›¶,å¼€å§‹è®¡æ—¶ switch(usmart_dev.pnum) &#123; case 0://æ— å‚æ•°(voidç±»å‹) res=(*(u32(*)())usmart_dev.funs[id].func)(); break; case 1://æœ‰1ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0]); break; case 2://æœ‰2ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1]); break; case 3://æœ‰3ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2]); break; case 4://æœ‰4ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3]); break; case 5://æœ‰5ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4]); break; case 6://æœ‰6ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5]); break; case 7://æœ‰7ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5],temp[6]); break; case 8://æœ‰8ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5],temp[6],temp[7]); break; case 9://æœ‰9ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5],temp[6],temp[7],temp[8]); break; case 10://æœ‰10ä¸ªå‚æ•° res=(*(u32(*)())usmart_dev.funs[id].func)(temp[0],temp[1],temp[2],temp[3],temp[4],\\ temp[5],temp[6],temp[7],temp[8],temp[9]); break; &#125; usmart_get_runtime();//è·å–å‡½æ•°æ‰§è¡Œæ—¶é—´ if(rval==1)//éœ€è¦è¿”å›å€¼. &#123; if(usmart_dev.sptype==SP_TYPE_DEC)printf(&quot;=%lu;\\r\\n&quot;,res);//è¾“å‡ºæ‰§è¡Œç»“æœ(10è¿›åˆ¶å‚æ•°æ˜¾ç¤º) else printf(&quot;=0X%X;\\r\\n&quot;,res);//è¾“å‡ºæ‰§è¡Œç»“æœ(16è¿›åˆ¶å‚æ•°æ˜¾ç¤º) &#125;else printf(&quot;;\\r\\n&quot;); //ä¸éœ€è¦è¿”å›å€¼,ç›´æ¥è¾“å‡ºç»“æŸ if(usmart_dev.runtimeflag) //éœ€è¦æ˜¾ç¤ºå‡½æ•°æ‰§è¡Œæ—¶é—´ &#123; printf(&quot;Function Run Time:%d.%1dms\\r\\n&quot;,usmart_dev.runtime/10,usmart_dev.runtime%10);//æ‰“å°å‡½æ•°æ‰§è¡Œæ—¶é—´ &#125; &#125;//usmartæ‰«æå‡½æ•°//é€šè¿‡è°ƒç”¨è¯¥å‡½æ•°,å®ç°usmartçš„å„ä¸ªæ§åˆ¶.è¯¥å‡½æ•°éœ€è¦æ¯éš”ä¸€å®šæ—¶é—´è¢«è°ƒç”¨ä¸€æ¬¡//ä»¥åŠæ—¶æ‰§è¡Œä»ä¸²å£å‘è¿‡æ¥çš„å„ä¸ªå‡½æ•°.//æœ¬å‡½æ•°å¯ä»¥åœ¨ä¸­æ–­é‡Œé¢è°ƒç”¨,ä»è€Œå®ç°è‡ªåŠ¨ç®¡ç†.//å¦‚æœéALIENTEKç”¨æˆ·,åˆ™USART_RX_STAå’ŒUSART_RX_BUF[]éœ€è¦ç”¨æˆ·è‡ªå·±å®ç°void usmart_scan(void)&#123; u8 sta,len; if(USART_RX_STA&amp;0x8000)//ä¸²å£æ¥æ”¶å®Œæˆï¼Ÿ &#123; len=USART_RX_STA&amp;0x3fff; //å¾—åˆ°æ­¤æ¬¡æ¥æ”¶åˆ°çš„æ•°æ®é•¿åº¦ USART_RX_BUF[len]=&#x27;\\0&#x27;; //åœ¨æœ«å°¾åŠ å…¥ç»“æŸç¬¦. sta=usmart_dev.cmd_rec(USART_RX_BUF);//å¾—åˆ°å‡½æ•°å„ä¸ªä¿¡æ¯ if(sta==0)usmart_dev.exe(); //æ‰§è¡Œå‡½æ•° else &#123; len=usmart_sys_cmd_exe(USART_RX_BUF); if(len!=USMART_FUNCERR)sta=len; if(sta) &#123; switch(sta) &#123; case USMART_FUNCERR: printf(&quot;å‡½æ•°é”™è¯¯!\\r\\n&quot;); break; case USMART_PARMERR: printf(&quot;å‚æ•°é”™è¯¯!\\r\\n&quot;); break; case USMART_PARMOVER: printf(&quot;å‚æ•°å¤ªå¤š!\\r\\n&quot;); break; case USMART_NOFUNCFIND: printf(&quot;æœªæ‰¾åˆ°åŒ¹é…çš„å‡½æ•°!\\r\\n&quot;); break; &#125; &#125; &#125; USART_RX_STA=0;//çŠ¶æ€å¯„å­˜å™¨æ¸…ç©º &#125;&#125;#if USMART_USE_WRFUNS==1 //å¦‚æœä½¿èƒ½äº†è¯»å†™æ“ä½œ//è¯»å–æŒ‡å®šåœ°å€çš„å€¼ u32 read_addr(u32 addr)&#123; return *(u32*)addr;// &#125;//åœ¨æŒ‡å®šåœ°å€å†™å…¥æŒ‡å®šçš„å€¼ void write_addr(u32 addr,u32 val)&#123; *(u32*)addr=val; &#125;#endif/******************* END OF FILE *********/ usmart.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// usmart.h#ifndef __USMART_H#define __USMART_H #include &quot;usmart_str.h&quot;//USMARTèµ„æºå ç”¨æƒ…å†µ@MDK 3.80A@2.0ç‰ˆæœ¬ï¼š//FLASH:4K~Kå­—èŠ‚(é€šè¿‡USMART_USE_HELPå’ŒUSMART_USE_WRFUNSè®¾ç½®)//SRAM:72å­—èŠ‚(æœ€å°‘çš„æƒ…å†µä¸‹)//SRAMè®¡ç®—å…¬å¼: SRAM=PARM_LEN+72-4 å…¶ä¸­PARM_LENå¿…é¡»å¤§äºç­‰äº4.//åº”è¯¥ä¿è¯å †æ ˆä¸å°äº100ä¸ªå­—èŠ‚.////////////////////////////////////////////ç”¨æˆ·é…ç½®å‚æ•°//////////////////////////////////////////////////// #define MAX_FNAME_LEN 30 //å‡½æ•°åæœ€å¤§é•¿åº¦ï¼Œåº”è¯¥è®¾ç½®ä¸ºä¸å°äºæœ€é•¿å‡½æ•°åçš„é•¿åº¦ã€‚ #define MAX_PARM 10 //æœ€å¤§ä¸º10ä¸ªå‚æ•° ,ä¿®æ”¹æ­¤å‚æ•°,å¿…é¡»ä¿®æ”¹usmart_exeä¸ä¹‹å¯¹åº”.#define PARM_LEN 200 //æ‰€æœ‰å‚æ•°ä¹‹å’Œçš„é•¿åº¦ä¸è¶…è¿‡PARM_LENä¸ªå­—èŠ‚,æ³¨æ„ä¸²å£æ¥æ”¶éƒ¨åˆ†è¦ä¸ä¹‹å¯¹åº”(ä¸å°äºPARM_LEN)#define USMART_ENTIMX_SCAN 1 //ä½¿ç”¨TIMçš„å®šæ—¶ä¸­æ–­æ¥æ‰«æSCANå‡½æ•°,å¦‚æœè®¾ç½®ä¸º0,éœ€è¦è‡ªå·±å®ç°éš”ä¸€æ®µæ—¶é—´æ‰«æä¸€æ¬¡scanå‡½æ•°. //æ³¨æ„:å¦‚æœè¦ç”¨runtimeç»Ÿè®¡åŠŸèƒ½,å¿…é¡»è®¾ç½®USMART_ENTIMX_SCANä¸º1!!!! #define USMART_USE_HELP 1 //ä½¿ç”¨å¸®åŠ©ï¼Œè¯¥å€¼è®¾ä¸º0ï¼Œå¯ä»¥èŠ‚çœè¿‘700ä¸ªå­—èŠ‚ï¼Œä½†æ˜¯å°†å¯¼è‡´æ— æ³•æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯ã€‚#define USMART_USE_WRFUNS 1 //ä½¿ç”¨è¯»å†™å‡½æ•°,ä½¿èƒ½è¿™é‡Œ,å¯ä»¥è¯»å–ä»»ä½•åœ°å€çš„å€¼,è¿˜å¯ä»¥å†™å¯„å­˜å™¨çš„å€¼.///////////////////////////////////////////////END///////////////////////////////////////////////////////////#define USMART_OK 0 //æ— é”™è¯¯#define USMART_FUNCERR 1 //å‡½æ•°é”™è¯¯#define USMART_PARMERR 2 //å‚æ•°é”™è¯¯#define USMART_PARMOVER 3 //å‚æ•°æº¢å‡º#define USMART_NOFUNCFIND 4 //æœªæ‰¾åˆ°åŒ¹é…å‡½æ•°#define SP_TYPE_DEC 0 //10è¿›åˆ¶å‚æ•°æ˜¾ç¤º#define SP_TYPE_HEX 1 //16è¿›åˆ¶å‚æ•°æ˜¾ç¤º //å‡½æ•°ååˆ—è¡¨ struct _m_usmart_nametab&#123; void* func; //å‡½æ•°æŒ‡é’ˆ const u8* name; //å‡½æ•°å(æŸ¥æ‰¾ä¸²) &#125;;//usmartæ§åˆ¶ç®¡ç†å™¨struct _m_usmart_dev&#123; struct _m_usmart_nametab *funs; //å‡½æ•°åæŒ‡é’ˆ void (*init)(u8); //åˆå§‹åŒ– u8 (*cmd_rec)(u8*str); //è¯†åˆ«å‡½æ•°ååŠå‚æ•° void (*exe)(void); //æ‰§è¡Œ void (*scan)(void); //æ‰«æ u8 fnum; //å‡½æ•°æ•°é‡ u8 pnum; //å‚æ•°æ•°é‡ u8 id; //å‡½æ•°id u8 sptype; //å‚æ•°æ˜¾ç¤ºç±»å‹(éå­—ç¬¦ä¸²å‚æ•°):0,10è¿›åˆ¶;1,16è¿›åˆ¶; u16 parmtype; //å‚æ•°çš„ç±»å‹ u8 plentbl[MAX_PARM]; //æ¯ä¸ªå‚æ•°çš„é•¿åº¦æš‚å­˜è¡¨ u8 parm[PARM_LEN]; //å‡½æ•°çš„å‚æ•° u8 runtimeflag; //0,ä¸ç»Ÿè®¡å‡½æ•°æ‰§è¡Œæ—¶é—´;1,ç»Ÿè®¡å‡½æ•°æ‰§è¡Œæ—¶é—´,æ³¨æ„:æ­¤åŠŸèƒ½å¿…é¡»åœ¨USMART_ENTIMX_SCANä½¿èƒ½çš„æ—¶å€™,æ‰æœ‰ç”¨ u32 runtime; //è¿è¡Œæ—¶é—´,å•ä½:0.1ms,æœ€å¤§å»¶æ—¶æ—¶é—´ä¸ºå®šæ—¶å™¨CNTå€¼çš„2å€*0.1ms&#125;;extern struct _m_usmart_nametab usmart_nametab[]; //åœ¨usmart_config.cé‡Œé¢å®šä¹‰extern struct _m_usmart_dev usmart_dev; //åœ¨usmart_config.cé‡Œé¢å®šä¹‰void usmart_init(u8 sysclk);//åˆå§‹åŒ–u8 usmart_cmd_rec(u8*str); //è¯†åˆ«void usmart_exe(void); //æ‰§è¡Œvoid usmart_scan(void); //æ‰«æu32 read_addr(u32 addr); //è¯»å–æŒ‡å®šåœ°å€çš„å€¼void write_addr(u32 addr,u32 val);//åœ¨æŒ‡å®šåœ°å€å†™å…¥æŒ‡å®šçš„å€¼u32 usmart_get_runtime(void); //è·å–è¿è¡Œæ—¶é—´void usmart_reset_runtime(void);//å¤ä½è¿è¡Œæ—¶é—´#endif/******************* END OF FILE *********/ usmart_str.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358//usmart_str.c#include &quot;usmart_str.h&quot;#include &quot;usmart.h&quot; //å¯¹æ¯”å­—ç¬¦ä¸²str1å’Œstr2//*str1:å­—ç¬¦ä¸²1æŒ‡é’ˆ//*str2:å­—ç¬¦ä¸²2æŒ‡é’ˆ//è¿”å›å€¼:0ï¼Œç›¸ç­‰;1ï¼Œä¸ç›¸ç­‰;u8 usmart_strcmp(u8 *str1,u8 *str2)&#123; while(1) &#123; if(*str1!=*str2)return 1;//ä¸ç›¸ç­‰ if(*str1==&#x27;\\0&#x27;)break;//å¯¹æ¯”å®Œæˆäº†. str1++; str2++; &#125; return 0;//ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸ç­‰&#125;//æŠŠstr1çš„å†…å®¹copyåˆ°str2//*str1:å­—ç¬¦ä¸²1æŒ‡é’ˆ//*str2:å­—ç¬¦ä¸²2æŒ‡é’ˆ void usmart_strcopy(u8*str1,u8 *str2)&#123; while(1) &#123; *str2=*str1; //æ‹·è´ if(*str1==&#x27;\\0&#x27;)break;//æ‹·è´å®Œæˆäº†. str1++; str2++; &#125;&#125;//å¾—åˆ°å­—ç¬¦ä¸²çš„é•¿åº¦(å­—èŠ‚)//*str:å­—ç¬¦ä¸²æŒ‡é’ˆ//è¿”å›å€¼:å­—ç¬¦ä¸²çš„é•¿åº¦ u8 usmart_strlen(u8*str)&#123; u8 len=0; while(1) &#123; if(*str==&#x27;\\0&#x27;)break;//æ‹·è´å®Œæˆäº†. len++; str++; &#125; return len;&#125;//m^nå‡½æ•°//è¿”å›å€¼:m^næ¬¡æ–¹u32 usmart_pow(u8 m,u8 n)&#123; u32 result=1; while(n--)result*=m; return result;&#125; //æŠŠå­—ç¬¦ä¸²è½¬ä¸ºæ•°å­—//æ”¯æŒ16è¿›åˆ¶è½¬æ¢,ä½†æ˜¯16è¿›åˆ¶å­—æ¯å¿…é¡»æ˜¯å¤§å†™çš„,ä¸”æ ¼å¼ä¸ºä»¥0Xå¼€å¤´çš„.//ä¸æ”¯æŒè´Ÿæ•° //*str:æ•°å­—å­—ç¬¦ä¸²æŒ‡é’ˆ//*res:è½¬æ¢å®Œçš„ç»“æœå­˜æ”¾åœ°å€.//è¿”å›å€¼:0ï¼ŒæˆåŠŸè½¬æ¢å®Œæˆ.å…¶ä»–,é”™è¯¯ä»£ç .//1,æ•°æ®æ ¼å¼é”™è¯¯.2,16è¿›åˆ¶ä½æ•°ä¸º0.3,èµ·å§‹æ ¼å¼é”™è¯¯.4,åè¿›åˆ¶ä½æ•°ä¸º0.u8 usmart_str2num(u8*str,u32 *res)&#123; u32 t; u8 bnum=0; //æ•°å­—çš„ä½æ•° u8 *p; u8 hexdec=10;//é»˜è®¤ä¸ºåè¿›åˆ¶æ•°æ® p=str; *res=0;//æ¸…é›¶. while(1) &#123; if((*p&lt;=&#x27;9&#x27;&amp;&amp;*p&gt;=&#x27;0&#x27;)||(*p&lt;=&#x27;F&#x27;&amp;&amp;*p&gt;=&#x27;A&#x27;)||(*p==&#x27;X&#x27;&amp;&amp;bnum==1))//å‚æ•°åˆæ³• &#123; if(*p&gt;=&#x27;A&#x27;)hexdec=16; //å­—ç¬¦ä¸²ä¸­å­˜åœ¨å­—æ¯,ä¸º16è¿›åˆ¶æ ¼å¼. bnum++; //ä½æ•°å¢åŠ . &#125;else if(*p==&#x27;\\0&#x27;)break; //ç¢°åˆ°ç»“æŸç¬¦,é€€å‡º. else return 1; //ä¸å…¨æ˜¯åè¿›åˆ¶æˆ–è€…16è¿›åˆ¶æ•°æ®. p++; &#125; p=str; //é‡æ–°å®šä½åˆ°å­—ç¬¦ä¸²å¼€å§‹çš„åœ°å€. if(hexdec==16) //16è¿›åˆ¶æ•°æ® &#123; if(bnum&lt;3)return 2; //ä½æ•°å°äº3ï¼Œç›´æ¥é€€å‡º.å› ä¸º0Xå°±å äº†2ä¸ª,å¦‚æœ0Xåé¢ä¸è·Ÿæ•°æ®,åˆ™è¯¥æ•°æ®éæ³•. if(*p==&#x27;0&#x27; &amp;&amp; (*(p+1)==&#x27;X&#x27;))//å¿…é¡»ä»¥&#x27;0X&#x27;å¼€å¤´. &#123; p+=2; //åç§»åˆ°æ•°æ®èµ·å§‹åœ°å€. bnum-=2;//å‡å»åç§»é‡ &#125;else return 3;//èµ·å§‹å¤´çš„æ ¼å¼ä¸å¯¹ &#125;else if(bnum==0)return 4;//ä½æ•°ä¸º0ï¼Œç›´æ¥é€€å‡º. while(1) &#123; if(bnum)bnum--; if(*p&lt;=&#x27;9&#x27;&amp;&amp;*p&gt;=&#x27;0&#x27;)t=*p-&#x27;0&#x27;; //å¾—åˆ°æ•°å­—çš„å€¼ else t=*p-&#x27;A&#x27;+10; //å¾—åˆ°A~Få¯¹åº”çš„å€¼ *res+=t*usmart_pow(hexdec,bnum); p++; if(*p==&#x27;\\0&#x27;)break;//æ•°æ®éƒ½æŸ¥å®Œäº†. &#125; return 0;//æˆåŠŸè½¬æ¢&#125;//å¾—åˆ°æŒ‡ä»¤å//*str:æºå­—ç¬¦ä¸²//*cmdname:æŒ‡ä»¤å//*nlen:æŒ‡ä»¤åé•¿åº¦ //maxlen:æœ€å¤§é•¿åº¦(åšé™åˆ¶,æŒ‡ä»¤ä¸å¯èƒ½å¤ªé•¿çš„) //è¿”å›å€¼:0,æˆåŠŸ;å…¶ä»–,å¤±è´¥. u8 usmart_get_cmdname(u8*str,u8*cmdname,u8 *nlen,u8 maxlen)&#123; *nlen=0; while(*str!=&#x27; &#x27;&amp;&amp;*str!=&#x27;\\0&#x27;) //æ‰¾åˆ°ç©ºæ ¼æˆ–è€…ç»“æŸç¬¦åˆ™è®¤ä¸ºç»“æŸäº† &#123; *cmdname=*str; str++; cmdname++; (*nlen)++;//ç»Ÿè®¡å‘½ä»¤é•¿åº¦ if(*nlen&gt;=maxlen)return 1;//é”™è¯¯çš„æŒ‡ä»¤ &#125; *cmdname=&#x27;\\0&#x27;;//åŠ å…¥ç»“æŸç¬¦ return 0;//æ­£å¸¸è¿”å›&#125;//è·å–ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼ˆå½“ä¸­é—´æœ‰å¾ˆå¤šç©ºæ ¼çš„æ—¶å€™ï¼Œæ­¤å‡½æ•°ç›´æ¥å¿½ç•¥ç©ºæ ¼ï¼Œæ‰¾åˆ°ç©ºæ ¼ä¹‹åçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼‰//str:å­—ç¬¦ä¸²æŒ‡é’ˆ //è¿”å›å€¼:ä¸‹ä¸€ä¸ªå­—ç¬¦u8 usmart_search_nextc(u8* str)&#123; str++; while(*str==&#x27; &#x27;&amp;&amp;str!=&#x27;\\0&#x27;)str++; return *str;&#125; //ä»strä¸­å¾—åˆ°å‡½æ•°å//*str:æºå­—ç¬¦ä¸²æŒ‡é’ˆ//*fname:è·å–åˆ°çš„å‡½æ•°åå­—æŒ‡é’ˆ//*pnum:å‡½æ•°çš„å‚æ•°ä¸ªæ•°//*rval:æ˜¯å¦éœ€è¦æ˜¾ç¤ºè¿”å›å€¼(0,ä¸éœ€è¦;1,éœ€è¦)//è¿”å›å€¼:0,æˆåŠŸ;å…¶ä»–,é”™è¯¯ä»£ç .u8 usmart_get_fname(u8*str,u8*fname,u8 *pnum,u8 *rval)&#123; u8 res; u8 fover=0; //æ‹¬å·æ·±åº¦ u8 *strtemp; u8 offset=0; u8 parmnum=0; u8 temp=1; u8 fpname[6];//void+X+&#x27;/0&#x27; u8 fplcnt=0; //ç¬¬ä¸€ä¸ªå‚æ•°çš„é•¿åº¦è®¡æ•°å™¨ u8 pcnt=0; //å‚æ•°è®¡æ•°å™¨ u8 nchar; //åˆ¤æ–­å‡½æ•°æ˜¯å¦æœ‰è¿”å›å€¼ strtemp=str; while(*strtemp!=&#x27;\\0&#x27;)//æ²¡æœ‰ç»“æŸ &#123; if(*strtemp!=&#x27; &#x27;&amp;&amp;(pcnt&amp;0X7F)&lt;5)//æœ€å¤šè®°å½•5ä¸ªå­—ç¬¦ &#123; if(pcnt==0)pcnt|=0X80;//ç½®ä½æœ€é«˜ä½,æ ‡è®°å¼€å§‹æ¥æ”¶è¿”å›å€¼ç±»å‹ if(((pcnt&amp;0x7f)==4)&amp;&amp;(*strtemp!=&#x27;*&#x27;))break;//æœ€åä¸€ä¸ªå­—ç¬¦,å¿…é¡»æ˜¯* fpname[pcnt&amp;0x7f]=*strtemp;//è®°å½•å‡½æ•°çš„è¿”å›å€¼ç±»å‹ pcnt++; &#125;else if(pcnt==0X85)break; strtemp++; &#125; if(pcnt)//æ¥æ”¶å®Œäº† &#123; fpname[pcnt&amp;0x7f]=&#x27;\\0&#x27;;//åŠ å…¥ç»“æŸç¬¦ if(usmart_strcmp(fpname,&quot;void&quot;)==0)*rval=0;//ä¸éœ€è¦è¿”å›å€¼ else *rval=1; //éœ€è¦è¿”å›å€¼ pcnt=0; &#125; res=0; strtemp=str; while(*strtemp!=&#x27;(&#x27;&amp;&amp;*strtemp!=&#x27;\\0&#x27;) //æ­¤ä»£ç æ‰¾åˆ°å‡½æ•°åçš„çœŸæ­£èµ·å§‹ä½ç½® &#123; strtemp++; res++; if(*strtemp==&#x27; &#x27;||*strtemp==&#x27;*&#x27;) &#123; nchar=usmart_search_nextc(strtemp); //è·å–ä¸‹ä¸€ä¸ªå­—ç¬¦ if(nchar!=&#x27;(&#x27;&amp;&amp;nchar!=&#x27;*&#x27;)offset=res; //è·³è¿‡ç©ºæ ¼å’Œ*å· &#125; &#125; strtemp=str; if(offset)strtemp+=offset+1;//è·³åˆ°å‡½æ•°åå¼€å§‹çš„åœ°æ–¹ res=0; nchar=0;//æ˜¯å¦æ­£åœ¨å­—ç¬¦ä¸²é‡Œé¢çš„æ ‡å¿—,0ï¼Œä¸åœ¨å­—ç¬¦ä¸²;1ï¼Œåœ¨å­—ç¬¦ä¸²; while(1) &#123; if(*strtemp==0) &#123; res=USMART_FUNCERR;//å‡½æ•°é”™è¯¯ break; &#125;else if(*strtemp==&#x27;(&#x27;&amp;&amp;nchar==0)fover++;//æ‹¬å·æ·±åº¦å¢åŠ ä¸€çº§ else if(*strtemp==&#x27;)&#x27;&amp;&amp;nchar==0) &#123; if(fover)fover--; else res=USMART_FUNCERR;//é”™è¯¯ç»“æŸ,æ²¡æ”¶åˆ°&#x27;(&#x27; if(fover==0)break;//åˆ°æœ«å°¾äº†,é€€å‡º &#125;else if(*strtemp==&#x27;&quot;&#x27;)nchar=!nchar; if(fover==0)//å‡½æ•°åè¿˜æ²¡æ¥æ”¶å®Œ &#123; if(*strtemp!=&#x27; &#x27;)//ç©ºæ ¼ä¸å±äºå‡½æ•°å &#123; *fname=*strtemp;//å¾—åˆ°å‡½æ•°å fname++; &#125; &#125;else //å·²ç»æ¥å—å®Œäº†å‡½æ•°åäº†. &#123; if(*strtemp==&#x27;,&#x27;) &#123; temp=1; //ä½¿èƒ½å¢åŠ ä¸€ä¸ªå‚æ•° pcnt++; &#125;else if(*strtemp!=&#x27; &#x27;&amp;&amp;*strtemp!=&#x27;(&#x27;) &#123; if(pcnt==0&amp;&amp;fplcnt&lt;5) //å½“ç¬¬ä¸€ä¸ªå‚æ•°æ¥æ—¶,ä¸ºäº†é¿å…ç»Ÿè®¡voidç±»å‹çš„å‚æ•°,å¿…é¡»åšåˆ¤æ–­. &#123; fpname[fplcnt]=*strtemp;//è®°å½•å‚æ•°ç‰¹å¾. fplcnt++; &#125; temp++; //å¾—åˆ°æœ‰æ•ˆå‚æ•°(éç©ºæ ¼) &#125; if(fover==1&amp;&amp;temp==2) &#123; temp++; //é˜²æ­¢é‡å¤å¢åŠ  parmnum++; //å‚æ•°å¢åŠ ä¸€ä¸ª &#125; &#125; strtemp++; &#125; if(parmnum==1)//åªæœ‰1ä¸ªå‚æ•°. &#123; fpname[fplcnt]=&#x27;\\0&#x27;;//åŠ å…¥ç»“æŸç¬¦ if(usmart_strcmp(fpname,&quot;void&quot;)==0)parmnum=0;//å‚æ•°ä¸ºvoid,è¡¨ç¤ºæ²¡æœ‰å‚æ•°. &#125; *pnum=parmnum; //è®°å½•å‚æ•°ä¸ªæ•° *fname=&#x27;\\0&#x27;; //åŠ å…¥ç»“æŸç¬¦ return res; //è¿”å›æ‰§è¡Œç»“æœ&#125;//ä»strä¸­å¾—åˆ°ä¸€ä¸ªå‡½æ•°çš„å‚æ•°//*str:æºå­—ç¬¦ä¸²æŒ‡é’ˆ//*fparm:å‚æ•°å­—ç¬¦ä¸²æŒ‡é’ˆ//*ptype:å‚æ•°ç±»å‹ 0ï¼Œæ•°å­—;1ï¼Œå­—ç¬¦ä¸²;0XFFï¼Œå‚æ•°é”™è¯¯//è¿”å›å€¼:0,å·²ç»æ— å‚æ•°äº†;å…¶ä»–,ä¸‹ä¸€ä¸ªå‚æ•°çš„åç§»é‡.u8 usmart_get_aparm(u8 *str,u8 *fparm,u8 *ptype)&#123; u8 i=0; u8 enout=0; u8 type=0;//é»˜è®¤æ˜¯æ•°å­— u8 string=0; //æ ‡è®°stræ˜¯å¦æ­£åœ¨è¯» while(1) &#123; if(*str==&#x27;,&#x27;&amp;&amp; string==0)enout=1; //æš‚ç¼“ç«‹å³é€€å‡º,ç›®çš„æ˜¯å¯»æ‰¾ä¸‹ä¸€ä¸ªå‚æ•°çš„èµ·å§‹åœ°å€ if((*str==&#x27;)&#x27;||*str==&#x27;\\0&#x27;)&amp;&amp;string==0)break;//ç«‹å³é€€å‡ºæ ‡è¯†ç¬¦ if(type==0)//é»˜è®¤æ˜¯æ•°å­—çš„ &#123; if((*str&gt;=&#x27;0&#x27; &amp;&amp; *str&lt;=&#x27;9&#x27;)||(*str&gt;=&#x27;a&#x27; &amp;&amp; *str&lt;=&#x27;f&#x27;)||(*str&gt;=&#x27;A&#x27; &amp;&amp; *str&lt;=&#x27;F&#x27;)||*str==&#x27;X&#x27;||*str==&#x27;x&#x27;)//æ•°å­—ä¸²æ£€æµ‹ &#123; if(enout)break; //æ‰¾åˆ°äº†ä¸‹ä¸€ä¸ªå‚æ•°,ç›´æ¥é€€å‡º. if(*str&gt;=&#x27;a&#x27;)*fparm=*str-0X20; //å°å†™è½¬æ¢ä¸ºå¤§å†™ else *fparm=*str; //å°å†™æˆ–è€…æ•°å­—ä¿æŒä¸å˜ fparm++; &#125;else if(*str==&#x27;&quot;&#x27;)//æ‰¾åˆ°å­—ç¬¦ä¸²çš„å¼€å§‹æ ‡å¿— &#123; if(enout)break;//æ‰¾åˆ°,åæ‰æ‰¾åˆ°&quot;,è®¤ä¸ºç»“æŸäº†. type=1; string=1;//ç™»è®°STRING æ­£åœ¨è¯»äº† &#125;else if(*str!=&#x27; &#x27;&amp;&amp;*str!=&#x27;,&#x27;)//å‘ç°éæ³•å­—ç¬¦,å‚æ•°é”™è¯¯ &#123; type=0XFF; break; &#125; &#125;else//stringç±» &#123; if(*str==&#x27;&quot;&#x27;)string=0; if(enout)break; //æ‰¾åˆ°äº†ä¸‹ä¸€ä¸ªå‚æ•°,ç›´æ¥é€€å‡º. if(string) //å­—ç¬¦ä¸²æ­£åœ¨è¯» &#123; if(*str==&#x27;\\\\&#x27;) //é‡åˆ°è½¬ä¹‰ç¬¦(ä¸å¤åˆ¶è½¬ä¹‰ç¬¦) &#123; str++; //åç§»åˆ°è½¬ä¹‰ç¬¦åé¢çš„å­—ç¬¦,ä¸ç®¡ä»€ä¹ˆå­—ç¬¦,ç›´æ¥COPY i++; &#125; *fparm=*str; //å°å†™æˆ–è€…æ•°å­—ä¿æŒä¸å˜ fparm++; &#125; &#125; i++;//åç§»é‡å¢åŠ  str++; &#125; *fparm=&#x27;\\0&#x27;; //åŠ å…¥ç»“æŸç¬¦ *ptype=type; //è¿”å›å‚æ•°ç±»å‹ return i; //è¿”å›å‚æ•°é•¿åº¦&#125;//å¾—åˆ°æŒ‡å®šå‚æ•°çš„èµ·å§‹åœ°å€//num:ç¬¬numä¸ªå‚æ•°,èŒƒå›´0~9.//è¿”å›å€¼:è¯¥å‚æ•°çš„èµ·å§‹åœ°å€u8 usmart_get_parmpos(u8 num)&#123; u8 temp=0; u8 i; for(i=0;i&lt;num;i++)temp+=usmart_dev.plentbl[i]; return temp;&#125;//ä»strä¸­å¾—åˆ°å‡½æ•°å‚æ•°//str:æºå­—ç¬¦ä¸²;//parn:å‚æ•°çš„å¤šå°‘.0è¡¨ç¤ºæ— å‚æ•° voidç±»å‹//è¿”å›å€¼:0,æˆåŠŸ;å…¶ä»–,é”™è¯¯ä»£ç .u8 usmart_get_fparam(u8*str,u8 *parn)&#123; u8 i,type; u32 res; u8 n=0; u8 len; u8 tstr[PARM_LEN+1];//å­—èŠ‚é•¿åº¦çš„ç¼“å­˜,æœ€å¤šå¯ä»¥å­˜æ”¾PARM_LENä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸² for(i=0;i&lt;MAX_PARM;i++)usmart_dev.plentbl[i]=0;//æ¸…ç©ºå‚æ•°é•¿åº¦è¡¨ while(*str!=&#x27;(&#x27;)//åç§»åˆ°å‚æ•°å¼€å§‹çš„åœ°æ–¹ &#123; str++; if(*str==&#x27;\\0&#x27;)return USMART_FUNCERR;//é‡åˆ°ç»“æŸç¬¦äº† &#125; str++;//åç§»åˆ°&quot;(&quot;ä¹‹åçš„ç¬¬ä¸€ä¸ªå­—èŠ‚ while(1) &#123; i=usmart_get_aparm(str,tstr,&amp;type); //å¾—åˆ°ç¬¬ä¸€ä¸ªå‚æ•° str+=i; //åç§» switch(type) &#123; case 0: //æ•°å­— if(tstr[0]!=&#x27;\\0&#x27;) //æ¥æ”¶åˆ°çš„å‚æ•°æœ‰æ•ˆ &#123; i=usmart_str2num(tstr,&amp;res); //è®°å½•è¯¥å‚æ•° if(i)return USMART_PARMERR; //å‚æ•°é”™è¯¯. *(u32*)(usmart_dev.parm+usmart_get_parmpos(n))=res;//è®°å½•è½¬æ¢æˆåŠŸçš„ç»“æœ. usmart_dev.parmtype&amp;=~(1&lt;&lt;n); //æ ‡è®°æ•°å­— usmart_dev.plentbl[n]=4; //è¯¥å‚æ•°çš„é•¿åº¦ä¸º4 n++; //å‚æ•°å¢åŠ  if(n&gt;MAX_PARM)return USMART_PARMOVER;//å‚æ•°å¤ªå¤š &#125; break; case 1://å­—ç¬¦ä¸² len=usmart_strlen(tstr)+1; //åŒ…å«äº†ç»“æŸç¬¦&#x27;\\0&#x27; usmart_strcopy(tstr,&amp;usmart_dev.parm[usmart_get_parmpos(n)]);//æ‹·è´tstræ•°æ®åˆ°usmart_dev.parm[n] usmart_dev.parmtype|=1&lt;&lt;n; //æ ‡è®°å­—ç¬¦ä¸² usmart_dev.plentbl[n]=len; //è¯¥å‚æ•°çš„é•¿åº¦ä¸ºlen n++; if(n&gt;MAX_PARM)return USMART_PARMOVER;//å‚æ•°å¤ªå¤š break; case 0XFF://é”™è¯¯ return USMART_PARMERR;//å‚æ•°é”™è¯¯ &#125; if(*str==&#x27;)&#x27;||*str==&#x27;\\0&#x27;)break;//æŸ¥åˆ°ç»“æŸæ ‡å¿—äº†. &#125; *parn=n; //è®°å½•å‚æ•°çš„ä¸ªæ•° return USMART_OK;//æ­£ç¡®å¾—åˆ°äº†å‚æ•°&#125;/******************* END OF FILE *********/ usmart_str.h 1234567891011121314151617//usmart_str.h#ifndef __USMART_STR_H#define __USMART_STR_H #include &quot;stm32f10x.h&quot;u8 usmart_get_parmpos(u8 num); //å¾—åˆ°æŸä¸ªå‚æ•°åœ¨å‚æ•°åˆ—é‡Œé¢çš„èµ·å§‹ä½ç½®u8 usmart_strcmp(u8*str1,u8 *str2); //å¯¹æ¯”ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰u32 usmart_pow(u8 m,u8 n); //M^Næ¬¡æ–¹u8 usmart_str2num(u8*str,u32 *res); //å­—ç¬¦ä¸²è½¬ä¸ºæ•°å­—u8 usmart_get_cmdname(u8*str,u8*cmdname,u8 *nlen,u8 maxlen);//ä»strä¸­å¾—åˆ°æŒ‡ä»¤å,å¹¶è¿”å›æŒ‡ä»¤é•¿åº¦u8 usmart_get_fname(u8*str,u8*fname,u8 *pnum,u8 *rval); //ä»strä¸­å¾—åˆ°å‡½æ•°åu8 usmart_get_aparm(u8 *str,u8 *fparm,u8 *ptype); //ä»strä¸­å¾—åˆ°ä¸€ä¸ªå‡½æ•°å‚æ•°u8 usmart_get_fparam(u8*str,u8 *parn); //å¾—åˆ°strä¸­æ‰€æœ‰çš„å‡½æ•°å‚æ•°.#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334353637383940414243//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;lcd.h&quot;#include &quot;usart.h&quot; #include &quot;usmart.h&quot; //LEDçŠ¶æ€è®¾ç½®å‡½æ•°void led_set(u8 sta)&#123; LED1=sta;&#125; //å‡½æ•°å‚æ•°è°ƒç”¨æµ‹è¯•å‡½æ•°void test_fun(void(*ledset)(u8),u8 sta)&#123; ledset(sta);&#125; int main(void) &#123; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //LEDç«¯å£åˆå§‹åŒ– LCD_Init(); usmart_dev.init(SystemCoreClock/1000000); //åˆå§‹åŒ–USMART POINT_COLOR=RED; LCD_ShowString(30,50,200,16,16,&quot;ELITE STM32 ^_^&quot;); LCD_ShowString(30,70,200,16,16,&quot;USMART TEST&quot;); LCD_ShowString(30,90,200,16,16,&quot;ATOM@ALIENTEK&quot;); LCD_ShowString(30,110,200,16,16,&quot;2015/1/14&quot;); while(1) &#123; LED0=!LED0; delay_ms(500); &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ13ï¼‰TFTLCDæ˜¾ç¤º","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-013","date":"2022-11-08T03:19:18.000Z","updated":"2023-04-05T14:19:54.949Z","comments":true,"path":"posts/802121758.html","link":"","permalink":"https://sirius-tblog.github.io/posts/802121758.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ lcd.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833// lcd.c#include &quot;lcd.h&quot;#include &quot;stdlib.h&quot;#include &quot;font.h&quot; #include &quot;usart.h&quot; #include &quot;delay.h&quot; //LCDçš„ç”»ç¬”é¢œè‰²å’ŒèƒŒæ™¯è‰² u16 POINT_COLOR=0x0000; //ç”»ç¬”é¢œè‰²u16 BACK_COLOR=0xFFFF; //èƒŒæ™¯è‰² //ç®¡ç†LCDé‡è¦å‚æ•°//é»˜è®¤ä¸ºç«–å±_lcd_dev lcddev; //å†™å¯„å­˜å™¨å‡½æ•°//regval:å¯„å­˜å™¨å€¼void LCD_WR_REG(u16 regval)&#123; LCD-&gt;LCD_REG=regval;//å†™å…¥è¦å†™çš„å¯„å­˜å™¨åºå· &#125;//å†™LCDæ•°æ®//data:è¦å†™å…¥çš„å€¼void LCD_WR_DATA(u16 data)&#123; LCD-&gt;LCD_RAM=data; &#125;//è¯»LCDæ•°æ®//è¿”å›å€¼:è¯»åˆ°çš„å€¼u16 LCD_RD_DATA(void)&#123; vu16 ram; //é˜²æ­¢è¢«ä¼˜åŒ– ram=LCD-&gt;LCD_RAM; return ram; &#125; //å†™å¯„å­˜å™¨//LCD_Reg:å¯„å­˜å™¨åœ°å€//LCD_RegValue:è¦å†™å…¥çš„æ•°æ®void LCD_WriteReg(u16 LCD_Reg,u16 LCD_RegValue)&#123; LCD-&gt;LCD_REG = LCD_Reg; //å†™å…¥è¦å†™çš„å¯„å­˜å™¨åºå· LCD-&gt;LCD_RAM = LCD_RegValue;//å†™å…¥æ•°æ® &#125; //è¯»å¯„å­˜å™¨//LCD_Reg:å¯„å­˜å™¨åœ°å€//è¿”å›å€¼:è¯»åˆ°çš„æ•°æ®u16 LCD_ReadReg(u16 LCD_Reg)&#123; LCD_WR_REG(LCD_Reg); //å†™å…¥è¦è¯»çš„å¯„å­˜å™¨åºå· delay_us(5); return LCD_RD_DATA(); //è¿”å›è¯»åˆ°çš„å€¼&#125; //å¼€å§‹å†™GRAMvoid LCD_WriteRAM_Prepare(void)&#123; LCD-&gt;LCD_REG=lcddev.wramcmd; &#125; //LCDå†™GRAM//RGB_Code:é¢œè‰²å€¼void LCD_WriteRAM(u16 RGB_Code)&#123; LCD-&gt;LCD_RAM = RGB_Code;//å†™åå…­ä½GRAM&#125;//ä»ILI93xxè¯»å‡ºçš„æ•°æ®ä¸ºGBRæ ¼å¼ï¼Œè€Œæˆ‘ä»¬å†™å…¥çš„æ—¶å€™ä¸ºRGBæ ¼å¼ã€‚//é€šè¿‡è¯¥å‡½æ•°è½¬æ¢//c:GBRæ ¼å¼çš„é¢œè‰²å€¼//è¿”å›å€¼ï¼šRGBæ ¼å¼çš„é¢œè‰²å€¼u16 LCD_BGR2RGB(u16 c)&#123; u16 r,g,b,rgb; b=(c&gt;&gt;0)&amp;0x1f; g=(c&gt;&gt;5)&amp;0x3f; r=(c&gt;&gt;11)&amp;0x1f; rgb=(b&lt;&lt;11)+(g&lt;&lt;5)+(r&lt;&lt;0); return(rgb);&#125; //å½“mdk -O1æ—¶é—´ä¼˜åŒ–æ—¶éœ€è¦è®¾ç½®//å»¶æ—¶ivoid opt_delay(u8 i)&#123; while(i--);&#125;//è¯»å–ä¸ªæŸç‚¹çš„é¢œè‰²å€¼ //x,y:åæ ‡//è¿”å›å€¼:æ­¤ç‚¹çš„é¢œè‰²u16 LCD_ReadPoint(u16 x,u16 y)&#123; u16 r=0,g=0,b=0; if(x&gt;=lcddev.width||y&gt;=lcddev.height)return 0; //è¶…è¿‡äº†èŒƒå›´,ç›´æ¥è¿”å› LCD_SetCursor(x,y); if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X1963)LCD_WR_REG(0X2E);//9341/6804/3510/1963 å‘é€è¯»GRAMæŒ‡ä»¤ else if(lcddev.id==0X5510)LCD_WR_REG(0X2E00); //5510 å‘é€è¯»GRAMæŒ‡ä»¤ else LCD_WR_REG(0X22); //å…¶ä»–ICå‘é€è¯»GRAMæŒ‡ä»¤ if(lcddev.id==0X9320)opt_delay(2); //FOR 9320,å»¶æ—¶2us r=LCD_RD_DATA(); //dummy Read if(lcddev.id==0X1963)return r; //1963ç›´æ¥è¯»å°±å¯ä»¥ opt_delay(2); r=LCD_RD_DATA(); //å®é™…åæ ‡é¢œè‰² if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X5510) //9341/NT35310/NT35510è¦åˆ†2æ¬¡è¯»å‡º &#123; opt_delay(2); b=LCD_RD_DATA(); g=r&amp;0XFF; //å¯¹äº9341/5310/5510,ç¬¬ä¸€æ¬¡è¯»å–çš„æ˜¯RGçš„å€¼,Råœ¨å‰,Gåœ¨å,å„å 8ä½ g&lt;&lt;=8; &#125; if(lcddev.id==0X9325||lcddev.id==0X4535||lcddev.id==0X4531||lcddev.id==0XB505||lcddev.id==0XC505)return r; //è¿™å‡ ç§ICç›´æ¥è¿”å›é¢œè‰²å€¼ else if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X5510)return (((r&gt;&gt;11)&lt;&lt;11)|((g&gt;&gt;10)&lt;&lt;5)|(b&gt;&gt;11));//ILI9341/NT35310/NT35510éœ€è¦å…¬å¼è½¬æ¢ä¸€ä¸‹ else return LCD_BGR2RGB(r); //å…¶ä»–IC&#125; //LCDå¼€å¯æ˜¾ç¤ºvoid LCD_DisplayOn(void)&#123; if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X1963)LCD_WR_REG(0X29); //å¼€å¯æ˜¾ç¤º else if(lcddev.id==0X5510)LCD_WR_REG(0X2900); //å¼€å¯æ˜¾ç¤º else LCD_WriteReg(0X07,0x0173); //å¼€å¯æ˜¾ç¤º&#125; //LCDå…³é—­æ˜¾ç¤ºvoid LCD_DisplayOff(void)&#123; if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X1963)LCD_WR_REG(0X28); //å…³é—­æ˜¾ç¤º else if(lcddev.id==0X5510)LCD_WR_REG(0X2800); //å…³é—­æ˜¾ç¤º else LCD_WriteReg(0X07,0x0);//å…³é—­æ˜¾ç¤º &#125; //è®¾ç½®å…‰æ ‡ä½ç½®//Xpos:æ¨ªåæ ‡//Ypos:çºµåæ ‡void LCD_SetCursor(u16 Xpos, u16 Ypos)&#123; if(lcddev.id==0X9341||lcddev.id==0X5310) &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(Xpos&gt;&gt;8);LCD_WR_DATA(Xpos&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(Ypos&gt;&gt;8);LCD_WR_DATA(Ypos&amp;0XFF); &#125;else if(lcddev.id==0X6804) &#123; if(lcddev.dir==1)Xpos=lcddev.width-1-Xpos;//æ¨ªå±æ—¶å¤„ç† LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(Xpos&gt;&gt;8);LCD_WR_DATA(Xpos&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(Ypos&gt;&gt;8);LCD_WR_DATA(Ypos&amp;0XFF); &#125;else if(lcddev.id==0X1963) &#123; if(lcddev.dir==0)//xåæ ‡éœ€è¦å˜æ¢ &#123; Xpos=lcddev.width-1-Xpos; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(0);LCD_WR_DATA(0); LCD_WR_DATA(Xpos&gt;&gt;8);LCD_WR_DATA(Xpos&amp;0XFF); &#125;else &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(Xpos&gt;&gt;8);LCD_WR_DATA(Xpos&amp;0XFF); LCD_WR_DATA((lcddev.width-1)&gt;&gt;8);LCD_WR_DATA((lcddev.width-1)&amp;0XFF); &#125; LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(Ypos&gt;&gt;8);LCD_WR_DATA(Ypos&amp;0XFF); LCD_WR_DATA((lcddev.height-1)&gt;&gt;8);LCD_WR_DATA((lcddev.height-1)&amp;0XFF); &#125;else if(lcddev.id==0X5510) &#123; LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(Xpos&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(Xpos&amp;0XFF); LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(Ypos&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(Ypos&amp;0XFF); &#125;else &#123; if(lcddev.dir==1)Xpos=lcddev.width-1-Xpos;//æ¨ªå±å…¶å®å°±æ˜¯è°ƒè½¬x,yåæ ‡ LCD_WriteReg(lcddev.setxcmd, Xpos); LCD_WriteReg(lcddev.setycmd, Ypos); &#125; &#125; //è®¾ç½®LCDçš„è‡ªåŠ¨æ‰«ææ–¹å‘//æ³¨æ„:å…¶ä»–å‡½æ•°å¯èƒ½ä¼šå—åˆ°æ­¤å‡½æ•°è®¾ç½®çš„å½±å“(å°¤å…¶æ˜¯9341/6804è¿™ä¸¤ä¸ªå¥‡è‘©),//æ‰€ä»¥,ä¸€èˆ¬è®¾ç½®ä¸ºL2R_U2Då³å¯,å¦‚æœè®¾ç½®ä¸ºå…¶ä»–æ‰«ææ–¹å¼,å¯èƒ½å¯¼è‡´æ˜¾ç¤ºä¸æ­£å¸¸.//dir:0~7,ä»£è¡¨8ä¸ªæ–¹å‘(å…·ä½“å®šä¹‰è§lcd.h)//9320/9325/9328/4531/4535/1505/b505/5408/9341/5310/5510/1963ç­‰ICå·²ç»å®é™…æµ‹è¯• void LCD_Scan_Dir(u8 dir)&#123; u16 regval=0; u16 dirreg=0; u16 temp; if((lcddev.dir==1&amp;&amp;lcddev.id!=0X6804&amp;&amp;lcddev.id!=0X1963)||(lcddev.dir==0&amp;&amp;lcddev.id==0X1963))//æ¨ªå±æ—¶ï¼Œå¯¹6804å’Œ1963ä¸æ”¹å˜æ‰«ææ–¹å‘ï¼ç«–å±æ—¶1963æ”¹å˜æ–¹å‘ &#123; switch(dir)//æ–¹å‘è½¬æ¢ &#123; case 0:dir=6;break; case 1:dir=7;break; case 2:dir=4;break; case 3:dir=5;break; case 4:dir=1;break; case 5:dir=0;break; case 6:dir=3;break; case 7:dir=2;break; &#125; &#125; if(lcddev.id==0x9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X5510||lcddev.id==0X1963)//9341/6804/5310/5510/1963,ç‰¹æ®Šå¤„ç† &#123; switch(dir) &#123; case L2R_U2D://ä»å·¦åˆ°å³,ä»ä¸Šåˆ°ä¸‹ regval|=(0&lt;&lt;7)|(0&lt;&lt;6)|(0&lt;&lt;5); break; case L2R_D2U://ä»å·¦åˆ°å³,ä»ä¸‹åˆ°ä¸Š regval|=(1&lt;&lt;7)|(0&lt;&lt;6)|(0&lt;&lt;5); break; case R2L_U2D://ä»å³åˆ°å·¦,ä»ä¸Šåˆ°ä¸‹ regval|=(0&lt;&lt;7)|(1&lt;&lt;6)|(0&lt;&lt;5); break; case R2L_D2U://ä»å³åˆ°å·¦,ä»ä¸‹åˆ°ä¸Š regval|=(1&lt;&lt;7)|(1&lt;&lt;6)|(0&lt;&lt;5); break; case U2D_L2R://ä»ä¸Šåˆ°ä¸‹,ä»å·¦åˆ°å³ regval|=(0&lt;&lt;7)|(0&lt;&lt;6)|(1&lt;&lt;5); break; case U2D_R2L://ä»ä¸Šåˆ°ä¸‹,ä»å³åˆ°å·¦ regval|=(0&lt;&lt;7)|(1&lt;&lt;6)|(1&lt;&lt;5); break; case D2U_L2R://ä»ä¸‹åˆ°ä¸Š,ä»å·¦åˆ°å³ regval|=(1&lt;&lt;7)|(0&lt;&lt;6)|(1&lt;&lt;5); break; case D2U_R2L://ä»ä¸‹åˆ°ä¸Š,ä»å³åˆ°å·¦ regval|=(1&lt;&lt;7)|(1&lt;&lt;6)|(1&lt;&lt;5); break; &#125; if(lcddev.id==0X5510)dirreg=0X3600; else dirreg=0X36; if((lcddev.id!=0X5310)&amp;&amp;(lcddev.id!=0X5510)&amp;&amp;(lcddev.id!=0X1963))regval|=0X08;//5310/5510/1963ä¸éœ€è¦BGR if(lcddev.id==0X6804)regval|=0x02;//6804çš„BIT6å’Œ9341çš„åäº† LCD_WriteReg(dirreg,regval); if(lcddev.id!=0X1963)//1963ä¸åšåæ ‡å¤„ç† &#123; if(regval&amp;0X20) &#123; if(lcddev.width&lt;lcddev.height)//äº¤æ¢X,Y &#123; temp=lcddev.width; lcddev.width=lcddev.height; lcddev.height=temp; &#125; &#125;else &#123; if(lcddev.width&gt;lcddev.height)//äº¤æ¢X,Y &#123; temp=lcddev.width; lcddev.width=lcddev.height; lcddev.height=temp; &#125; &#125; &#125; if(lcddev.id==0X5510) &#123; LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(0); LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(0); LCD_WR_REG(lcddev.setxcmd+2);LCD_WR_DATA((lcddev.width-1)&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+3);LCD_WR_DATA((lcddev.width-1)&amp;0XFF); LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(0); LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(0); LCD_WR_REG(lcddev.setycmd+2);LCD_WR_DATA((lcddev.height-1)&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+3);LCD_WR_DATA((lcddev.height-1)&amp;0XFF); &#125;else &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(0);LCD_WR_DATA(0); LCD_WR_DATA((lcddev.width-1)&gt;&gt;8);LCD_WR_DATA((lcddev.width-1)&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(0);LCD_WR_DATA(0); LCD_WR_DATA((lcddev.height-1)&gt;&gt;8);LCD_WR_DATA((lcddev.height-1)&amp;0XFF); &#125; &#125;else &#123; switch(dir) &#123; case L2R_U2D://ä»å·¦åˆ°å³,ä»ä¸Šåˆ°ä¸‹ regval|=(1&lt;&lt;5)|(1&lt;&lt;4)|(0&lt;&lt;3); break; case L2R_D2U://ä»å·¦åˆ°å³,ä»ä¸‹åˆ°ä¸Š regval|=(0&lt;&lt;5)|(1&lt;&lt;4)|(0&lt;&lt;3); break; case R2L_U2D://ä»å³åˆ°å·¦,ä»ä¸Šåˆ°ä¸‹ regval|=(1&lt;&lt;5)|(0&lt;&lt;4)|(0&lt;&lt;3); break; case R2L_D2U://ä»å³åˆ°å·¦,ä»ä¸‹åˆ°ä¸Š regval|=(0&lt;&lt;5)|(0&lt;&lt;4)|(0&lt;&lt;3); break; case U2D_L2R://ä»ä¸Šåˆ°ä¸‹,ä»å·¦åˆ°å³ regval|=(1&lt;&lt;5)|(1&lt;&lt;4)|(1&lt;&lt;3); break; case U2D_R2L://ä»ä¸Šåˆ°ä¸‹,ä»å³åˆ°å·¦ regval|=(1&lt;&lt;5)|(0&lt;&lt;4)|(1&lt;&lt;3); break; case D2U_L2R://ä»ä¸‹åˆ°ä¸Š,ä»å·¦åˆ°å³ regval|=(0&lt;&lt;5)|(1&lt;&lt;4)|(1&lt;&lt;3); break; case D2U_R2L://ä»ä¸‹åˆ°ä¸Š,ä»å³åˆ°å·¦ regval|=(0&lt;&lt;5)|(0&lt;&lt;4)|(1&lt;&lt;3); break; &#125; dirreg=0X03; regval|=1&lt;&lt;12; LCD_WriteReg(dirreg,regval); &#125;&#125; //ç”»ç‚¹//x,y:åæ ‡//POINT_COLOR:æ­¤ç‚¹çš„é¢œè‰²void LCD_DrawPoint(u16 x,u16 y)&#123; LCD_SetCursor(x,y); //è®¾ç½®å…‰æ ‡ä½ç½® LCD_WriteRAM_Prepare(); //å¼€å§‹å†™å…¥GRAM LCD-&gt;LCD_RAM=POINT_COLOR; &#125;//å¿«é€Ÿç”»ç‚¹//x,y:åæ ‡//color:é¢œè‰²void LCD_Fast_DrawPoint(u16 x,u16 y,u16 color)&#123; if(lcddev.id==0X9341||lcddev.id==0X5310) &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(x&gt;&gt;8);LCD_WR_DATA(x&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(y&gt;&gt;8);LCD_WR_DATA(y&amp;0XFF); &#125;else if(lcddev.id==0X5510) &#123; LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(x&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(x&amp;0XFF); LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(y&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(y&amp;0XFF); &#125;else if(lcddev.id==0X1963) &#123; if(lcddev.dir==0)x=lcddev.width-1-x; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(x&gt;&gt;8);LCD_WR_DATA(x&amp;0XFF); LCD_WR_DATA(x&gt;&gt;8);LCD_WR_DATA(x&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(y&gt;&gt;8);LCD_WR_DATA(y&amp;0XFF); LCD_WR_DATA(y&gt;&gt;8);LCD_WR_DATA(y&amp;0XFF); &#125;else if(lcddev.id==0X6804) &#123; if(lcddev.dir==1)x=lcddev.width-1-x;//æ¨ªå±æ—¶å¤„ç† LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(x&gt;&gt;8);LCD_WR_DATA(x&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(y&gt;&gt;8);LCD_WR_DATA(y&amp;0XFF); &#125;else &#123; if(lcddev.dir==1)x=lcddev.width-1-x;//æ¨ªå±å…¶å®å°±æ˜¯è°ƒè½¬x,yåæ ‡ LCD_WriteReg(lcddev.setxcmd,x); LCD_WriteReg(lcddev.setycmd,y); &#125; LCD-&gt;LCD_REG=lcddev.wramcmd; LCD-&gt;LCD_RAM=color; &#125; //SSD1963 èƒŒå…‰è®¾ç½®//pwm:èƒŒå…‰ç­‰çº§,0~100.è¶Šå¤§è¶Šäº®.void LCD_SSD_BackLightSet(u8 pwm)&#123; LCD_WR_REG(0xBE); //é…ç½®PWMè¾“å‡º LCD_WR_DATA(0x05); //1è®¾ç½®PWMé¢‘ç‡ LCD_WR_DATA(pwm*2.55);//2è®¾ç½®PWMå ç©ºæ¯” LCD_WR_DATA(0x01); //3è®¾ç½®C LCD_WR_DATA(0xFF); //4è®¾ç½®D LCD_WR_DATA(0x00); //5è®¾ç½®E LCD_WR_DATA(0x00); //6è®¾ç½®F&#125;//è®¾ç½®LCDæ˜¾ç¤ºæ–¹å‘//dir:0,ç«–å±ï¼›1,æ¨ªå±void LCD_Display_Dir(u8 dir)&#123; if(dir==0) //ç«–å± &#123; lcddev.dir=0; //ç«–å± lcddev.width=240; lcddev.height=320; if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310) &#123; lcddev.wramcmd=0X2C; lcddev.setxcmd=0X2A; lcddev.setycmd=0X2B; if(lcddev.id==0X6804||lcddev.id==0X5310) &#123; lcddev.width=320; lcddev.height=480; &#125; &#125;else if(lcddev.id==0x5510) &#123; lcddev.wramcmd=0X2C00; lcddev.setxcmd=0X2A00; lcddev.setycmd=0X2B00; lcddev.width=480; lcddev.height=800; &#125;else if(lcddev.id==0X1963) &#123; lcddev.wramcmd=0X2C; //è®¾ç½®å†™å…¥GRAMçš„æŒ‡ä»¤ lcddev.setxcmd=0X2B; //è®¾ç½®å†™Xåæ ‡æŒ‡ä»¤ lcddev.setycmd=0X2A; //è®¾ç½®å†™Yåæ ‡æŒ‡ä»¤ lcddev.width=480; //è®¾ç½®å®½åº¦480 lcddev.height=800; //è®¾ç½®é«˜åº¦800 &#125;else &#123; lcddev.wramcmd=0X22; lcddev.setxcmd=0X20; lcddev.setycmd=0X21; &#125; &#125;else //æ¨ªå± &#123; lcddev.dir=1; //æ¨ªå± lcddev.width=320; lcddev.height=240; if(lcddev.id==0X9341||lcddev.id==0X5310) &#123; lcddev.wramcmd=0X2C; lcddev.setxcmd=0X2A; lcddev.setycmd=0X2B; &#125;else if(lcddev.id==0X6804) &#123; lcddev.wramcmd=0X2C; lcddev.setxcmd=0X2B; lcddev.setycmd=0X2A; &#125;else if(lcddev.id==0x5510) &#123; lcddev.wramcmd=0X2C00; lcddev.setxcmd=0X2A00; lcddev.setycmd=0X2B00; lcddev.width=800; lcddev.height=480; &#125;else if(lcddev.id==0X1963) &#123; lcddev.wramcmd=0X2C; //è®¾ç½®å†™å…¥GRAMçš„æŒ‡ä»¤ lcddev.setxcmd=0X2A; //è®¾ç½®å†™Xåæ ‡æŒ‡ä»¤ lcddev.setycmd=0X2B; //è®¾ç½®å†™Yåæ ‡æŒ‡ä»¤ lcddev.width=800; //è®¾ç½®å®½åº¦800 lcddev.height=480; //è®¾ç½®é«˜åº¦480 &#125;else &#123; lcddev.wramcmd=0X22; lcddev.setxcmd=0X21; lcddev.setycmd=0X20; &#125; if(lcddev.id==0X6804||lcddev.id==0X5310) &#123; lcddev.width=480; lcddev.height=320; &#125; &#125; LCD_Scan_Dir(DFT_SCAN_DIR); //é»˜è®¤æ‰«ææ–¹å‘&#125; //è®¾ç½®çª—å£,å¹¶è‡ªåŠ¨è®¾ç½®ç”»ç‚¹åæ ‡åˆ°çª—å£å·¦ä¸Šè§’(sx,sy).//sx,sy:çª—å£èµ·å§‹åæ ‡(å·¦ä¸Šè§’)//width,height:çª—å£å®½åº¦å’Œé«˜åº¦,å¿…é¡»å¤§äº0!!//çª—ä½“å¤§å°:width*height. void LCD_Set_Window(u16 sx,u16 sy,u16 width,u16 height)&#123; u8 hsareg,heareg,vsareg,veareg; u16 hsaval,heaval,vsaval,veaval; u16 twidth,theight; twidth=sx+width-1; theight=sy+height-1; if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X6804||(lcddev.dir==1&amp;&amp;lcddev.id==0X1963)) &#123; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(sx&gt;&gt;8); LCD_WR_DATA(sx&amp;0XFF); LCD_WR_DATA(twidth&gt;&gt;8); LCD_WR_DATA(twidth&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(sy&gt;&gt;8); LCD_WR_DATA(sy&amp;0XFF); LCD_WR_DATA(theight&gt;&gt;8); LCD_WR_DATA(theight&amp;0XFF); &#125;else if(lcddev.id==0X1963)//1963ç«–å±ç‰¹æ®Šå¤„ç† &#123; sx=lcddev.width-width-sx; height=sy+height-1; LCD_WR_REG(lcddev.setxcmd); LCD_WR_DATA(sx&gt;&gt;8); LCD_WR_DATA(sx&amp;0XFF); LCD_WR_DATA((sx+width-1)&gt;&gt;8); LCD_WR_DATA((sx+width-1)&amp;0XFF); LCD_WR_REG(lcddev.setycmd); LCD_WR_DATA(sy&gt;&gt;8); LCD_WR_DATA(sy&amp;0XFF); LCD_WR_DATA(height&gt;&gt;8); LCD_WR_DATA(height&amp;0XFF); &#125;else if(lcddev.id==0X5510) &#123; LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(sx&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(sx&amp;0XFF); LCD_WR_REG(lcddev.setxcmd+2);LCD_WR_DATA(twidth&gt;&gt;8); LCD_WR_REG(lcddev.setxcmd+3);LCD_WR_DATA(twidth&amp;0XFF); LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(sy&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(sy&amp;0XFF); LCD_WR_REG(lcddev.setycmd+2);LCD_WR_DATA(theight&gt;&gt;8); LCD_WR_REG(lcddev.setycmd+3);LCD_WR_DATA(theight&amp;0XFF); &#125;else //å…¶ä»–é©±åŠ¨IC &#123; if(lcddev.dir==1)//æ¨ªå± &#123; //çª—å£å€¼ hsaval=sy; heaval=theight; vsaval=lcddev.width-twidth-1; veaval=lcddev.width-sx-1; &#125;else &#123; hsaval=sx; heaval=twidth; vsaval=sy; veaval=theight; &#125; hsareg=0X50;heareg=0X51;//æ°´å¹³æ–¹å‘çª—å£å¯„å­˜å™¨ vsareg=0X52;veareg=0X53;//å‚ç›´æ–¹å‘çª—å£å¯„å­˜å™¨ //è®¾ç½®å¯„å­˜å™¨å€¼ LCD_WriteReg(hsareg,hsaval); LCD_WriteReg(heareg,heaval); LCD_WriteReg(vsareg,vsaval); LCD_WriteReg(veareg,veaval); LCD_SetCursor(sx,sy); //è®¾ç½®å…‰æ ‡ä½ç½® &#125;&#125;//åˆå§‹åŒ–lcd//è¯¥åˆå§‹åŒ–å‡½æ•°å¯ä»¥åˆå§‹åŒ–å„ç§ILI93XXæ¶²æ™¶,ä½†æ˜¯å…¶ä»–å‡½æ•°æ˜¯åŸºäºILI9320çš„!!!//åœ¨å…¶ä»–å‹å·çš„é©±åŠ¨èŠ¯ç‰‡ä¸Šæ²¡æœ‰æµ‹è¯•! void LCD_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; FSMC_NORSRAMInitTypeDef FSMC_NORSRAMInitStructure; FSMC_NORSRAMTimingInitTypeDef readWriteTiming; FSMC_NORSRAMTimingInitTypeDef writeTiming; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC,ENABLE); //ä½¿èƒ½FSMCæ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOE|RCC_APB2Periph_GPIOG,ENABLE);//ä½¿èƒ½PORTB,D,E,Gä»¥åŠAFIOå¤ç”¨åŠŸèƒ½æ—¶é’Ÿ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //PB0 æ¨æŒ½è¾“å‡º èƒŒå…‰ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //PORTDå¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_14|GPIO_Pin_15; // //PORTDå¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //å¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); //PORTEå¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15; // //PORTDå¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //å¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOE, &amp;GPIO_InitStructure); // //PORTG12å¤ç”¨æ¨æŒ½è¾“å‡º A0 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_12; // //PORTDå¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //å¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOG, &amp;GPIO_InitStructure); readWriteTiming.FSMC_AddressSetupTime = 0x01; //åœ°å€å»ºç«‹æ—¶é—´ï¼ˆADDSETï¼‰ä¸º2ä¸ªHCLK 1/36M=27ns readWriteTiming.FSMC_AddressHoldTime = 0x00; //åœ°å€ä¿æŒæ—¶é—´ï¼ˆADDHLDï¼‰æ¨¡å¼Aæœªç”¨åˆ° readWriteTiming.FSMC_DataSetupTime = 0x0f; // æ•°æ®ä¿å­˜æ—¶é—´ä¸º16ä¸ªHCLK,å› ä¸ºæ¶²æ™¶é©±åŠ¨ICçš„è¯»æ•°æ®çš„æ—¶å€™ï¼Œé€Ÿåº¦ä¸èƒ½å¤ªå¿«ï¼Œå°¤å…¶å¯¹1289è¿™ä¸ªICã€‚ readWriteTiming.FSMC_BusTurnAroundDuration = 0x00; readWriteTiming.FSMC_CLKDivision = 0x00; readWriteTiming.FSMC_DataLatency = 0x00; readWriteTiming.FSMC_AccessMode = FSMC_AccessMode_A; //æ¨¡å¼A writeTiming.FSMC_AddressSetupTime = 0x00; //åœ°å€å»ºç«‹æ—¶é—´ï¼ˆADDSETï¼‰ä¸º1ä¸ªHCLK writeTiming.FSMC_AddressHoldTime = 0x00; //åœ°å€ä¿æŒæ—¶é—´ï¼ˆA writeTiming.FSMC_DataSetupTime = 0x03; ////æ•°æ®ä¿å­˜æ—¶é—´ä¸º4ä¸ªHCLK writeTiming.FSMC_BusTurnAroundDuration = 0x00; writeTiming.FSMC_CLKDivision = 0x00; writeTiming.FSMC_DataLatency = 0x00; writeTiming.FSMC_AccessMode = FSMC_AccessMode_A; //æ¨¡å¼A FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM4;// è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨NE4 ï¼Œä¹Ÿå°±å¯¹åº”BTCR[6],[7]ã€‚ FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable; // ä¸å¤ç”¨æ•°æ®åœ°å€ FSMC_NORSRAMInitStructure.FSMC_MemoryType =FSMC_MemoryType_SRAM;// FSMC_MemoryType_SRAM; //SRAM FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;//å­˜å‚¨å™¨æ•°æ®å®½åº¦ä¸º16bit FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode =FSMC_BurstAccessMode_Disable;// FSMC_BurstAccessMode_Disable; FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low; FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait=FSMC_AsynchronousWait_Disable; FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable; FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState; FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable; // å­˜å‚¨å™¨å†™ä½¿èƒ½ FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable; FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Enable; // è¯»å†™ä½¿ç”¨ä¸åŒçš„æ—¶åº FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable; FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &amp;readWriteTiming; //è¯»å†™æ—¶åº FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &amp;writeTiming; //å†™æ—¶åº FSMC_NORSRAMInit(&amp;FSMC_NORSRAMInitStructure); //åˆå§‹åŒ–FSMCé…ç½® FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE); // ä½¿èƒ½BANK1 delay_ms(50); // delay 50 ms lcddev.id=LCD_ReadReg(0x0000); //è¯»IDï¼ˆ9320/9325/9328/4531/4535ç­‰ICï¼‰ if(lcddev.id&lt;0XFF||lcddev.id==0XFFFF||lcddev.id==0X9300)//è¯»åˆ°IDä¸æ­£ç¡®,æ–°å¢lcddev.id==0X9300åˆ¤æ–­ï¼Œå› ä¸º9341åœ¨æœªè¢«å¤ä½çš„æƒ…å†µä¸‹ä¼šè¢«è¯»æˆ9300 &#123; //å°è¯•9341 IDçš„è¯»å– LCD_WR_REG(0XD3); lcddev.id=LCD_RD_DATA(); //dummy read lcddev.id=LCD_RD_DATA(); //è¯»åˆ°0X00 lcddev.id=LCD_RD_DATA(); //è¯»å–93 lcddev.id&lt;&lt;=8; lcddev.id|=LCD_RD_DATA(); //è¯»å–41 if(lcddev.id!=0X9341) //é9341,å°è¯•æ˜¯ä¸æ˜¯6804 &#123; LCD_WR_REG(0XBF); lcddev.id=LCD_RD_DATA(); //dummy read lcddev.id=LCD_RD_DATA(); //è¯»å›0X01 lcddev.id=LCD_RD_DATA(); //è¯»å›0XD0 lcddev.id=LCD_RD_DATA(); //è¿™é‡Œè¯»å›0X68 lcddev.id&lt;&lt;=8; lcddev.id|=LCD_RD_DATA(); //è¿™é‡Œè¯»å›0X04 if(lcddev.id!=0X6804) //ä¹Ÿä¸æ˜¯6804,å°è¯•çœ‹çœ‹æ˜¯ä¸æ˜¯NT35310 &#123; LCD_WR_REG(0XD4); lcddev.id=LCD_RD_DATA();//dummy read lcddev.id=LCD_RD_DATA();//è¯»å›0X01 lcddev.id=LCD_RD_DATA();//è¯»å›0X53 lcddev.id&lt;&lt;=8; lcddev.id|=LCD_RD_DATA(); //è¿™é‡Œè¯»å›0X10 if(lcddev.id!=0X5310) //ä¹Ÿä¸æ˜¯NT35310,å°è¯•çœ‹çœ‹æ˜¯ä¸æ˜¯NT35510 &#123; LCD_WR_REG(0XDA00); lcddev.id=LCD_RD_DATA(); //è¯»å›0X00 LCD_WR_REG(0XDB00); lcddev.id=LCD_RD_DATA(); //è¯»å›0X80 lcddev.id&lt;&lt;=8; LCD_WR_REG(0XDC00); lcddev.id|=LCD_RD_DATA(); //è¯»å›0X00 if(lcddev.id==0x8000)lcddev.id=0x5510;//NT35510è¯»å›çš„IDæ˜¯8000H,ä¸ºæ–¹ä¾¿åŒºåˆ†,æˆ‘ä»¬å¼ºåˆ¶è®¾ç½®ä¸º5510 if(lcddev.id!=0X5510) //ä¹Ÿä¸æ˜¯NT5510,å°è¯•çœ‹çœ‹æ˜¯ä¸æ˜¯SSD1963 &#123; LCD_WR_REG(0XA1); lcddev.id=LCD_RD_DATA(); lcddev.id=LCD_RD_DATA(); //è¯»å›0X57 lcddev.id&lt;&lt;=8; lcddev.id|=LCD_RD_DATA(); //è¯»å›0X61 if(lcddev.id==0X5761)lcddev.id=0X1963;//SSD1963è¯»å›çš„IDæ˜¯5761H,ä¸ºæ–¹ä¾¿åŒºåˆ†,æˆ‘ä»¬å¼ºåˆ¶è®¾ç½®ä¸º1963 &#125; &#125; &#125; &#125; &#125; printf(&quot; LCD ID:%x\\r\\n&quot;,lcddev.id); //æ‰“å°LCD ID if(lcddev.id==0X9341) //9341åˆå§‹åŒ– &#123; LCD_WR_REG(0xCF); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC1); LCD_WR_DATA(0X30); LCD_WR_REG(0xED); LCD_WR_DATA(0x64); LCD_WR_DATA(0x03); LCD_WR_DATA(0X12); LCD_WR_DATA(0X81); LCD_WR_REG(0xE8); LCD_WR_DATA(0x85); LCD_WR_DATA(0x10); LCD_WR_DATA(0x7A); LCD_WR_REG(0xCB); LCD_WR_DATA(0x39); LCD_WR_DATA(0x2C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x34); LCD_WR_DATA(0x02); LCD_WR_REG(0xF7); LCD_WR_DATA(0x20); LCD_WR_REG(0xEA); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xC0); //Power control LCD_WR_DATA(0x1B); //VRH[5:0] LCD_WR_REG(0xC1); //Power control LCD_WR_DATA(0x01); //SAP[2:0];BT[3:0] LCD_WR_REG(0xC5); //VCM control LCD_WR_DATA(0x30); //3F LCD_WR_DATA(0x30); //3C LCD_WR_REG(0xC7); //VCM control2 LCD_WR_DATA(0XB7); LCD_WR_REG(0x36); // Memory Access Control LCD_WR_DATA(0x48); LCD_WR_REG(0x3A); LCD_WR_DATA(0x55); LCD_WR_REG(0xB1); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1A); LCD_WR_REG(0xB6); // Display Function Control LCD_WR_DATA(0x0A); LCD_WR_DATA(0xA2); LCD_WR_REG(0xF2); // 3Gamma Function Disable LCD_WR_DATA(0x00); LCD_WR_REG(0x26); //Gamma curve selected LCD_WR_DATA(0x01); LCD_WR_REG(0xE0); //Set Gamma LCD_WR_DATA(0x0F); LCD_WR_DATA(0x2A); LCD_WR_DATA(0x28); LCD_WR_DATA(0x08); LCD_WR_DATA(0x0E); LCD_WR_DATA(0x08); LCD_WR_DATA(0x54); LCD_WR_DATA(0XA9); LCD_WR_DATA(0x43); LCD_WR_DATA(0x0A); LCD_WR_DATA(0x0F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0XE1); //Set Gamma LCD_WR_DATA(0x00); LCD_WR_DATA(0x15); LCD_WR_DATA(0x17); LCD_WR_DATA(0x07); LCD_WR_DATA(0x11); LCD_WR_DATA(0x06); LCD_WR_DATA(0x2B); LCD_WR_DATA(0x56); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x05); LCD_WR_DATA(0x10); LCD_WR_DATA(0x0F); LCD_WR_DATA(0x3F); LCD_WR_DATA(0x3F); LCD_WR_DATA(0x0F); LCD_WR_REG(0x2B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x01); LCD_WR_DATA(0x3f); LCD_WR_REG(0x2A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0xef); LCD_WR_REG(0x11); //Exit Sleep delay_ms(120); LCD_WR_REG(0x29); //display on &#125;else if(lcddev.id==0x6804) //6804åˆå§‹åŒ– &#123; LCD_WR_REG(0X11); delay_ms(20); LCD_WR_REG(0XD0);//VCI1 VCL VGH VGL DDVDH VREG1OUT power amplitude setting LCD_WR_DATA(0X07); LCD_WR_DATA(0X42); LCD_WR_DATA(0X1D); LCD_WR_REG(0XD1);//VCOMH VCOM_AC amplitude setting LCD_WR_DATA(0X00); LCD_WR_DATA(0X1a); LCD_WR_DATA(0X09); LCD_WR_REG(0XD2);//Operational Amplifier Circuit Constant Current Adjust , charge pump frequency setting LCD_WR_DATA(0X01); LCD_WR_DATA(0X22); LCD_WR_REG(0XC0);//REV SM GS LCD_WR_DATA(0X10); LCD_WR_DATA(0X3B); LCD_WR_DATA(0X00); LCD_WR_DATA(0X02); LCD_WR_DATA(0X11); LCD_WR_REG(0XC5);// Frame rate setting = 72HZ when setting 0x03 LCD_WR_DATA(0X03); LCD_WR_REG(0XC8);//Gamma setting LCD_WR_DATA(0X00); LCD_WR_DATA(0X25); LCD_WR_DATA(0X21); LCD_WR_DATA(0X05); LCD_WR_DATA(0X00); LCD_WR_DATA(0X0a); LCD_WR_DATA(0X65); LCD_WR_DATA(0X25); LCD_WR_DATA(0X77); LCD_WR_DATA(0X50); LCD_WR_DATA(0X0f); LCD_WR_DATA(0X00); LCD_WR_REG(0XF8); LCD_WR_DATA(0X01); LCD_WR_REG(0XFE); LCD_WR_DATA(0X00); LCD_WR_DATA(0X02); LCD_WR_REG(0X20);//Exit invert mode LCD_WR_REG(0X36); LCD_WR_DATA(0X08);//åŸæ¥æ˜¯a LCD_WR_REG(0X3A); LCD_WR_DATA(0X55);//16ä½æ¨¡å¼ LCD_WR_REG(0X2B); LCD_WR_DATA(0X00); LCD_WR_DATA(0X00); LCD_WR_DATA(0X01); LCD_WR_DATA(0X3F); LCD_WR_REG(0X2A); LCD_WR_DATA(0X00); LCD_WR_DATA(0X00); LCD_WR_DATA(0X01); LCD_WR_DATA(0XDF); delay_ms(120); LCD_WR_REG(0X29); &#125;else if(lcddev.id==0x5310) &#123; LCD_WR_REG(0xED); LCD_WR_DATA(0x01); LCD_WR_DATA(0xFE); LCD_WR_REG(0xEE); LCD_WR_DATA(0xDE); LCD_WR_DATA(0x21); LCD_WR_REG(0xF1); LCD_WR_DATA(0x01); LCD_WR_REG(0xDF); LCD_WR_DATA(0x10); //VCOMvoltage// LCD_WR_REG(0xC4); LCD_WR_DATA(0x8F); //5f LCD_WR_REG(0xC6); LCD_WR_DATA(0x00); LCD_WR_DATA(0xE2); LCD_WR_DATA(0xE2); LCD_WR_DATA(0xE2); LCD_WR_REG(0xBF); LCD_WR_DATA(0xAA); LCD_WR_REG(0xB0); LCD_WR_DATA(0x0D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x0D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x11); LCD_WR_DATA(0x00); LCD_WR_DATA(0x19); LCD_WR_DATA(0x00); LCD_WR_DATA(0x21); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5D); LCD_WR_DATA(0x00); LCD_WR_REG(0xB1); LCD_WR_DATA(0x80); LCD_WR_DATA(0x00); LCD_WR_DATA(0x8B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x96); LCD_WR_DATA(0x00); LCD_WR_REG(0xB2); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x02); LCD_WR_DATA(0x00); LCD_WR_DATA(0x03); LCD_WR_DATA(0x00); LCD_WR_REG(0xB3); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xB4); LCD_WR_DATA(0x8B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x96); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA1); LCD_WR_DATA(0x00); LCD_WR_REG(0xB5); LCD_WR_DATA(0x02); LCD_WR_DATA(0x00); LCD_WR_DATA(0x03); LCD_WR_DATA(0x00); LCD_WR_DATA(0x04); LCD_WR_DATA(0x00); LCD_WR_REG(0xB6); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xB7); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5E); LCD_WR_DATA(0x00); LCD_WR_DATA(0x64); LCD_WR_DATA(0x00); LCD_WR_DATA(0x8C); LCD_WR_DATA(0x00); LCD_WR_DATA(0xAC); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDC); LCD_WR_DATA(0x00); LCD_WR_DATA(0x70); LCD_WR_DATA(0x00); LCD_WR_DATA(0x90); LCD_WR_DATA(0x00); LCD_WR_DATA(0xEB); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDC); LCD_WR_DATA(0x00); LCD_WR_REG(0xB8); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xBA); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xC1); LCD_WR_DATA(0x20); LCD_WR_DATA(0x00); LCD_WR_DATA(0x54); LCD_WR_DATA(0x00); LCD_WR_DATA(0xFF); LCD_WR_DATA(0x00); LCD_WR_REG(0xC2); LCD_WR_DATA(0x0A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x04); LCD_WR_DATA(0x00); LCD_WR_REG(0xC3); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x39); LCD_WR_DATA(0x00); LCD_WR_DATA(0x37); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x36); LCD_WR_DATA(0x00); LCD_WR_DATA(0x32); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x29); LCD_WR_DATA(0x00); LCD_WR_DATA(0x26); LCD_WR_DATA(0x00); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x23); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x36); LCD_WR_DATA(0x00); LCD_WR_DATA(0x32); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x29); LCD_WR_DATA(0x00); LCD_WR_DATA(0x26); LCD_WR_DATA(0x00); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x24); LCD_WR_DATA(0x00); LCD_WR_DATA(0x23); LCD_WR_DATA(0x00); LCD_WR_REG(0xC4); LCD_WR_DATA(0x62); LCD_WR_DATA(0x00); LCD_WR_DATA(0x05); LCD_WR_DATA(0x00); LCD_WR_DATA(0x84); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF0); LCD_WR_DATA(0x00); LCD_WR_DATA(0x18); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA4); LCD_WR_DATA(0x00); LCD_WR_DATA(0x18); LCD_WR_DATA(0x00); LCD_WR_DATA(0x50); LCD_WR_DATA(0x00); LCD_WR_DATA(0x0C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x17); LCD_WR_DATA(0x00); LCD_WR_DATA(0x95); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xE6); LCD_WR_DATA(0x00); LCD_WR_REG(0xC5); LCD_WR_DATA(0x32); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x65); LCD_WR_DATA(0x00); LCD_WR_DATA(0x76); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_REG(0xC6); LCD_WR_DATA(0x20); LCD_WR_DATA(0x00); LCD_WR_DATA(0x17); LCD_WR_DATA(0x00); LCD_WR_DATA(0x01); LCD_WR_DATA(0x00); LCD_WR_REG(0xC7); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xC8); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xC9); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xE0); LCD_WR_DATA(0x16); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x21); LCD_WR_DATA(0x00); LCD_WR_DATA(0x36); LCD_WR_DATA(0x00); LCD_WR_DATA(0x46); LCD_WR_DATA(0x00); LCD_WR_DATA(0x52); LCD_WR_DATA(0x00); LCD_WR_DATA(0x64); LCD_WR_DATA(0x00); LCD_WR_DATA(0x7A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x8B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA8); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB9); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC4); LCD_WR_DATA(0x00); LCD_WR_DATA(0xCA); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD9); LCD_WR_DATA(0x00); LCD_WR_DATA(0xE0); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE1); LCD_WR_DATA(0x16); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x22); LCD_WR_DATA(0x00); LCD_WR_DATA(0x36); LCD_WR_DATA(0x00); LCD_WR_DATA(0x45); LCD_WR_DATA(0x00); LCD_WR_DATA(0x52); LCD_WR_DATA(0x00); LCD_WR_DATA(0x64); LCD_WR_DATA(0x00); LCD_WR_DATA(0x7A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x8B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA8); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB9); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC4); LCD_WR_DATA(0x00); LCD_WR_DATA(0xCA); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD8); LCD_WR_DATA(0x00); LCD_WR_DATA(0xE0); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE2); LCD_WR_DATA(0x05); LCD_WR_DATA(0x00); LCD_WR_DATA(0x0B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x34); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x4F); LCD_WR_DATA(0x00); LCD_WR_DATA(0x61); LCD_WR_DATA(0x00); LCD_WR_DATA(0x79); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0x97); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA6); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB7); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC7); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD1); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD6); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE3); LCD_WR_DATA(0x05); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA); LCD_WR_DATA(0x00); LCD_WR_DATA(0x1C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x33); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x50); LCD_WR_DATA(0x00); LCD_WR_DATA(0x62); LCD_WR_DATA(0x00); LCD_WR_DATA(0x78); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0x97); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA6); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB7); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC7); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD1); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD5); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE4); LCD_WR_DATA(0x01); LCD_WR_DATA(0x00); LCD_WR_DATA(0x01); LCD_WR_DATA(0x00); LCD_WR_DATA(0x02); LCD_WR_DATA(0x00); LCD_WR_DATA(0x2A); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x4B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x74); LCD_WR_DATA(0x00); LCD_WR_DATA(0x84); LCD_WR_DATA(0x00); LCD_WR_DATA(0x93); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBE); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC4); LCD_WR_DATA(0x00); LCD_WR_DATA(0xCD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE5); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x02); LCD_WR_DATA(0x00); LCD_WR_DATA(0x29); LCD_WR_DATA(0x00); LCD_WR_DATA(0x3C); LCD_WR_DATA(0x00); LCD_WR_DATA(0x4B); LCD_WR_DATA(0x00); LCD_WR_DATA(0x5D); LCD_WR_DATA(0x00); LCD_WR_DATA(0x74); LCD_WR_DATA(0x00); LCD_WR_DATA(0x84); LCD_WR_DATA(0x00); LCD_WR_DATA(0x93); LCD_WR_DATA(0x00); LCD_WR_DATA(0xA2); LCD_WR_DATA(0x00); LCD_WR_DATA(0xB3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBE); LCD_WR_DATA(0x00); LCD_WR_DATA(0xC4); LCD_WR_DATA(0x00); LCD_WR_DATA(0xCD); LCD_WR_DATA(0x00); LCD_WR_DATA(0xD3); LCD_WR_DATA(0x00); LCD_WR_DATA(0xDC); LCD_WR_DATA(0x00); LCD_WR_DATA(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xE6); LCD_WR_DATA(0x11); LCD_WR_DATA(0x00); LCD_WR_DATA(0x34); LCD_WR_DATA(0x00); LCD_WR_DATA(0x56); LCD_WR_DATA(0x00); LCD_WR_DATA(0x76); LCD_WR_DATA(0x00); LCD_WR_DATA(0x77); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBB); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x45); LCD_WR_DATA(0x00); LCD_WR_DATA(0x43); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_REG(0xE7); LCD_WR_DATA(0x32); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x76); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x67); LCD_WR_DATA(0x00); LCD_WR_DATA(0x67); LCD_WR_DATA(0x00); LCD_WR_DATA(0x87); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBB); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0x77); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x56); LCD_WR_DATA(0x00); LCD_WR_DATA(0x23); LCD_WR_DATA(0x00); LCD_WR_DATA(0x33); LCD_WR_DATA(0x00); LCD_WR_DATA(0x45); LCD_WR_DATA(0x00); LCD_WR_REG(0xE8); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0x87); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0x77); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x88); LCD_WR_DATA(0x00); LCD_WR_DATA(0xAA); LCD_WR_DATA(0x00); LCD_WR_DATA(0xBB); LCD_WR_DATA(0x00); LCD_WR_DATA(0x99); LCD_WR_DATA(0x00); LCD_WR_DATA(0x66); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x44); LCD_WR_DATA(0x00); LCD_WR_DATA(0x55); LCD_WR_DATA(0x00); LCD_WR_REG(0xE9); LCD_WR_DATA(0xAA); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0x00); LCD_WR_DATA(0xAA); LCD_WR_REG(0xCF); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xF0); LCD_WR_DATA(0x00); LCD_WR_DATA(0x50); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xF3); LCD_WR_DATA(0x00); LCD_WR_REG(0xF9); LCD_WR_DATA(0x06); LCD_WR_DATA(0x10); LCD_WR_DATA(0x29); LCD_WR_DATA(0x00); LCD_WR_REG(0x3A); LCD_WR_DATA(0x55); //66 LCD_WR_REG(0x11); delay_ms(100); LCD_WR_REG(0x29); LCD_WR_REG(0x35); LCD_WR_DATA(0x00); LCD_WR_REG(0x51); LCD_WR_DATA(0xFF); LCD_WR_REG(0x53); LCD_WR_DATA(0x2C); LCD_WR_REG(0x55); LCD_WR_DATA(0x82); LCD_WR_REG(0x2c); &#125;else if(lcddev.id==0x5510) &#123; LCD_WriteReg(0xF000,0x55); LCD_WriteReg(0xF001,0xAA); LCD_WriteReg(0xF002,0x52); LCD_WriteReg(0xF003,0x08); LCD_WriteReg(0xF004,0x01); //AVDD Set AVDD 5.2V LCD_WriteReg(0xB000,0x0D); LCD_WriteReg(0xB001,0x0D); LCD_WriteReg(0xB002,0x0D); //AVDD ratio LCD_WriteReg(0xB600,0x34); LCD_WriteReg(0xB601,0x34); LCD_WriteReg(0xB602,0x34); //AVEE -5.2V LCD_WriteReg(0xB100,0x0D); LCD_WriteReg(0xB101,0x0D); LCD_WriteReg(0xB102,0x0D); //AVEE ratio LCD_WriteReg(0xB700,0x34); LCD_WriteReg(0xB701,0x34); LCD_WriteReg(0xB702,0x34); //VCL -2.5V LCD_WriteReg(0xB200,0x00); LCD_WriteReg(0xB201,0x00); LCD_WriteReg(0xB202,0x00); //VCL ratio LCD_WriteReg(0xB800,0x24); LCD_WriteReg(0xB801,0x24); LCD_WriteReg(0xB802,0x24); //VGH 15V (Free pump) LCD_WriteReg(0xBF00,0x01); LCD_WriteReg(0xB300,0x0F); LCD_WriteReg(0xB301,0x0F); LCD_WriteReg(0xB302,0x0F); //VGH ratio LCD_WriteReg(0xB900,0x34); LCD_WriteReg(0xB901,0x34); LCD_WriteReg(0xB902,0x34); //VGL_REG -10V LCD_WriteReg(0xB500,0x08); LCD_WriteReg(0xB501,0x08); LCD_WriteReg(0xB502,0x08); LCD_WriteReg(0xC200,0x03); //VGLX ratio LCD_WriteReg(0xBA00,0x24); LCD_WriteReg(0xBA01,0x24); LCD_WriteReg(0xBA02,0x24); //VGMP/VGSP 4.5V/0V LCD_WriteReg(0xBC00,0x00); LCD_WriteReg(0xBC01,0x78); LCD_WriteReg(0xBC02,0x00); //VGMN/VGSN -4.5V/0V LCD_WriteReg(0xBD00,0x00); LCD_WriteReg(0xBD01,0x78); LCD_WriteReg(0xBD02,0x00); //VCOM LCD_WriteReg(0xBE00,0x00); LCD_WriteReg(0xBE01,0x64); //Gamma Setting LCD_WriteReg(0xD100,0x00); LCD_WriteReg(0xD101,0x33); LCD_WriteReg(0xD102,0x00); LCD_WriteReg(0xD103,0x34); LCD_WriteReg(0xD104,0x00); LCD_WriteReg(0xD105,0x3A); LCD_WriteReg(0xD106,0x00); LCD_WriteReg(0xD107,0x4A); LCD_WriteReg(0xD108,0x00); LCD_WriteReg(0xD109,0x5C); LCD_WriteReg(0xD10A,0x00); LCD_WriteReg(0xD10B,0x81); LCD_WriteReg(0xD10C,0x00); LCD_WriteReg(0xD10D,0xA6); LCD_WriteReg(0xD10E,0x00); LCD_WriteReg(0xD10F,0xE5); LCD_WriteReg(0xD110,0x01); LCD_WriteReg(0xD111,0x13); LCD_WriteReg(0xD112,0x01); LCD_WriteReg(0xD113,0x54); LCD_WriteReg(0xD114,0x01); LCD_WriteReg(0xD115,0x82); LCD_WriteReg(0xD116,0x01); LCD_WriteReg(0xD117,0xCA); LCD_WriteReg(0xD118,0x02); LCD_WriteReg(0xD119,0x00); LCD_WriteReg(0xD11A,0x02); LCD_WriteReg(0xD11B,0x01); LCD_WriteReg(0xD11C,0x02); LCD_WriteReg(0xD11D,0x34); LCD_WriteReg(0xD11E,0x02); LCD_WriteReg(0xD11F,0x67); LCD_WriteReg(0xD120,0x02); LCD_WriteReg(0xD121,0x84); LCD_WriteReg(0xD122,0x02); LCD_WriteReg(0xD123,0xA4); LCD_WriteReg(0xD124,0x02); LCD_WriteReg(0xD125,0xB7); LCD_WriteReg(0xD126,0x02); LCD_WriteReg(0xD127,0xCF); LCD_WriteReg(0xD128,0x02); LCD_WriteReg(0xD129,0xDE); LCD_WriteReg(0xD12A,0x02); LCD_WriteReg(0xD12B,0xF2); LCD_WriteReg(0xD12C,0x02); LCD_WriteReg(0xD12D,0xFE); LCD_WriteReg(0xD12E,0x03); LCD_WriteReg(0xD12F,0x10); LCD_WriteReg(0xD130,0x03); LCD_WriteReg(0xD131,0x33); LCD_WriteReg(0xD132,0x03); LCD_WriteReg(0xD133,0x6D); LCD_WriteReg(0xD200,0x00); LCD_WriteReg(0xD201,0x33); LCD_WriteReg(0xD202,0x00); LCD_WriteReg(0xD203,0x34); LCD_WriteReg(0xD204,0x00); LCD_WriteReg(0xD205,0x3A); LCD_WriteReg(0xD206,0x00); LCD_WriteReg(0xD207,0x4A); LCD_WriteReg(0xD208,0x00); LCD_WriteReg(0xD209,0x5C); LCD_WriteReg(0xD20A,0x00); LCD_WriteReg(0xD20B,0x81); LCD_WriteReg(0xD20C,0x00); LCD_WriteReg(0xD20D,0xA6); LCD_WriteReg(0xD20E,0x00); LCD_WriteReg(0xD20F,0xE5); LCD_WriteReg(0xD210,0x01); LCD_WriteReg(0xD211,0x13); LCD_WriteReg(0xD212,0x01); LCD_WriteReg(0xD213,0x54); LCD_WriteReg(0xD214,0x01); LCD_WriteReg(0xD215,0x82); LCD_WriteReg(0xD216,0x01); LCD_WriteReg(0xD217,0xCA); LCD_WriteReg(0xD218,0x02); LCD_WriteReg(0xD219,0x00); LCD_WriteReg(0xD21A,0x02); LCD_WriteReg(0xD21B,0x01); LCD_WriteReg(0xD21C,0x02); LCD_WriteReg(0xD21D,0x34); LCD_WriteReg(0xD21E,0x02); LCD_WriteReg(0xD21F,0x67); LCD_WriteReg(0xD220,0x02); LCD_WriteReg(0xD221,0x84); LCD_WriteReg(0xD222,0x02); LCD_WriteReg(0xD223,0xA4); LCD_WriteReg(0xD224,0x02); LCD_WriteReg(0xD225,0xB7); LCD_WriteReg(0xD226,0x02); LCD_WriteReg(0xD227,0xCF); LCD_WriteReg(0xD228,0x02); LCD_WriteReg(0xD229,0xDE); LCD_WriteReg(0xD22A,0x02); LCD_WriteReg(0xD22B,0xF2); LCD_WriteReg(0xD22C,0x02); LCD_WriteReg(0xD22D,0xFE); LCD_WriteReg(0xD22E,0x03); LCD_WriteReg(0xD22F,0x10); LCD_WriteReg(0xD230,0x03); LCD_WriteReg(0xD231,0x33); LCD_WriteReg(0xD232,0x03); LCD_WriteReg(0xD233,0x6D); LCD_WriteReg(0xD300,0x00); LCD_WriteReg(0xD301,0x33); LCD_WriteReg(0xD302,0x00); LCD_WriteReg(0xD303,0x34); LCD_WriteReg(0xD304,0x00); LCD_WriteReg(0xD305,0x3A); LCD_WriteReg(0xD306,0x00); LCD_WriteReg(0xD307,0x4A); LCD_WriteReg(0xD308,0x00); LCD_WriteReg(0xD309,0x5C); LCD_WriteReg(0xD30A,0x00); LCD_WriteReg(0xD30B,0x81); LCD_WriteReg(0xD30C,0x00); LCD_WriteReg(0xD30D,0xA6); LCD_WriteReg(0xD30E,0x00); LCD_WriteReg(0xD30F,0xE5); LCD_WriteReg(0xD310,0x01); LCD_WriteReg(0xD311,0x13); LCD_WriteReg(0xD312,0x01); LCD_WriteReg(0xD313,0x54); LCD_WriteReg(0xD314,0x01); LCD_WriteReg(0xD315,0x82); LCD_WriteReg(0xD316,0x01); LCD_WriteReg(0xD317,0xCA); LCD_WriteReg(0xD318,0x02); LCD_WriteReg(0xD319,0x00); LCD_WriteReg(0xD31A,0x02); LCD_WriteReg(0xD31B,0x01); LCD_WriteReg(0xD31C,0x02); LCD_WriteReg(0xD31D,0x34); LCD_WriteReg(0xD31E,0x02); LCD_WriteReg(0xD31F,0x67); LCD_WriteReg(0xD320,0x02); LCD_WriteReg(0xD321,0x84); LCD_WriteReg(0xD322,0x02); LCD_WriteReg(0xD323,0xA4); LCD_WriteReg(0xD324,0x02); LCD_WriteReg(0xD325,0xB7); LCD_WriteReg(0xD326,0x02); LCD_WriteReg(0xD327,0xCF); LCD_WriteReg(0xD328,0x02); LCD_WriteReg(0xD329,0xDE); LCD_WriteReg(0xD32A,0x02); LCD_WriteReg(0xD32B,0xF2); LCD_WriteReg(0xD32C,0x02); LCD_WriteReg(0xD32D,0xFE); LCD_WriteReg(0xD32E,0x03); LCD_WriteReg(0xD32F,0x10); LCD_WriteReg(0xD330,0x03); LCD_WriteReg(0xD331,0x33); LCD_WriteReg(0xD332,0x03); LCD_WriteReg(0xD333,0x6D); LCD_WriteReg(0xD400,0x00); LCD_WriteReg(0xD401,0x33); LCD_WriteReg(0xD402,0x00); LCD_WriteReg(0xD403,0x34); LCD_WriteReg(0xD404,0x00); LCD_WriteReg(0xD405,0x3A); LCD_WriteReg(0xD406,0x00); LCD_WriteReg(0xD407,0x4A); LCD_WriteReg(0xD408,0x00); LCD_WriteReg(0xD409,0x5C); LCD_WriteReg(0xD40A,0x00); LCD_WriteReg(0xD40B,0x81); LCD_WriteReg(0xD40C,0x00); LCD_WriteReg(0xD40D,0xA6); LCD_WriteReg(0xD40E,0x00); LCD_WriteReg(0xD40F,0xE5); LCD_WriteReg(0xD410,0x01); LCD_WriteReg(0xD411,0x13); LCD_WriteReg(0xD412,0x01); LCD_WriteReg(0xD413,0x54); LCD_WriteReg(0xD414,0x01); LCD_WriteReg(0xD415,0x82); LCD_WriteReg(0xD416,0x01); LCD_WriteReg(0xD417,0xCA); LCD_WriteReg(0xD418,0x02); LCD_WriteReg(0xD419,0x00); LCD_WriteReg(0xD41A,0x02); LCD_WriteReg(0xD41B,0x01); LCD_WriteReg(0xD41C,0x02); LCD_WriteReg(0xD41D,0x34); LCD_WriteReg(0xD41E,0x02); LCD_WriteReg(0xD41F,0x67); LCD_WriteReg(0xD420,0x02); LCD_WriteReg(0xD421,0x84); LCD_WriteReg(0xD422,0x02); LCD_WriteReg(0xD423,0xA4); LCD_WriteReg(0xD424,0x02); LCD_WriteReg(0xD425,0xB7); LCD_WriteReg(0xD426,0x02); LCD_WriteReg(0xD427,0xCF); LCD_WriteReg(0xD428,0x02); LCD_WriteReg(0xD429,0xDE); LCD_WriteReg(0xD42A,0x02); LCD_WriteReg(0xD42B,0xF2); LCD_WriteReg(0xD42C,0x02); LCD_WriteReg(0xD42D,0xFE); LCD_WriteReg(0xD42E,0x03); LCD_WriteReg(0xD42F,0x10); LCD_WriteReg(0xD430,0x03); LCD_WriteReg(0xD431,0x33); LCD_WriteReg(0xD432,0x03); LCD_WriteReg(0xD433,0x6D); LCD_WriteReg(0xD500,0x00); LCD_WriteReg(0xD501,0x33); LCD_WriteReg(0xD502,0x00); LCD_WriteReg(0xD503,0x34); LCD_WriteReg(0xD504,0x00); LCD_WriteReg(0xD505,0x3A); LCD_WriteReg(0xD506,0x00); LCD_WriteReg(0xD507,0x4A); LCD_WriteReg(0xD508,0x00); LCD_WriteReg(0xD509,0x5C); LCD_WriteReg(0xD50A,0x00); LCD_WriteReg(0xD50B,0x81); LCD_WriteReg(0xD50C,0x00); LCD_WriteReg(0xD50D,0xA6); LCD_WriteReg(0xD50E,0x00); LCD_WriteReg(0xD50F,0xE5); LCD_WriteReg(0xD510,0x01); LCD_WriteReg(0xD511,0x13); LCD_WriteReg(0xD512,0x01); LCD_WriteReg(0xD513,0x54); LCD_WriteReg(0xD514,0x01); LCD_WriteReg(0xD515,0x82); LCD_WriteReg(0xD516,0x01); LCD_WriteReg(0xD517,0xCA); LCD_WriteReg(0xD518,0x02); LCD_WriteReg(0xD519,0x00); LCD_WriteReg(0xD51A,0x02); LCD_WriteReg(0xD51B,0x01); LCD_WriteReg(0xD51C,0x02); LCD_WriteReg(0xD51D,0x34); LCD_WriteReg(0xD51E,0x02); LCD_WriteReg(0xD51F,0x67); LCD_WriteReg(0xD520,0x02); LCD_WriteReg(0xD521,0x84); LCD_WriteReg(0xD522,0x02); LCD_WriteReg(0xD523,0xA4); LCD_WriteReg(0xD524,0x02); LCD_WriteReg(0xD525,0xB7); LCD_WriteReg(0xD526,0x02); LCD_WriteReg(0xD527,0xCF); LCD_WriteReg(0xD528,0x02); LCD_WriteReg(0xD529,0xDE); LCD_WriteReg(0xD52A,0x02); LCD_WriteReg(0xD52B,0xF2); LCD_WriteReg(0xD52C,0x02); LCD_WriteReg(0xD52D,0xFE); LCD_WriteReg(0xD52E,0x03); LCD_WriteReg(0xD52F,0x10); LCD_WriteReg(0xD530,0x03); LCD_WriteReg(0xD531,0x33); LCD_WriteReg(0xD532,0x03); LCD_WriteReg(0xD533,0x6D); LCD_WriteReg(0xD600,0x00); LCD_WriteReg(0xD601,0x33); LCD_WriteReg(0xD602,0x00); LCD_WriteReg(0xD603,0x34); LCD_WriteReg(0xD604,0x00); LCD_WriteReg(0xD605,0x3A); LCD_WriteReg(0xD606,0x00); LCD_WriteReg(0xD607,0x4A); LCD_WriteReg(0xD608,0x00); LCD_WriteReg(0xD609,0x5C); LCD_WriteReg(0xD60A,0x00); LCD_WriteReg(0xD60B,0x81); LCD_WriteReg(0xD60C,0x00); LCD_WriteReg(0xD60D,0xA6); LCD_WriteReg(0xD60E,0x00); LCD_WriteReg(0xD60F,0xE5); LCD_WriteReg(0xD610,0x01); LCD_WriteReg(0xD611,0x13); LCD_WriteReg(0xD612,0x01); LCD_WriteReg(0xD613,0x54); LCD_WriteReg(0xD614,0x01); LCD_WriteReg(0xD615,0x82); LCD_WriteReg(0xD616,0x01); LCD_WriteReg(0xD617,0xCA); LCD_WriteReg(0xD618,0x02); LCD_WriteReg(0xD619,0x00); LCD_WriteReg(0xD61A,0x02); LCD_WriteReg(0xD61B,0x01); LCD_WriteReg(0xD61C,0x02); LCD_WriteReg(0xD61D,0x34); LCD_WriteReg(0xD61E,0x02); LCD_WriteReg(0xD61F,0x67); LCD_WriteReg(0xD620,0x02); LCD_WriteReg(0xD621,0x84); LCD_WriteReg(0xD622,0x02); LCD_WriteReg(0xD623,0xA4); LCD_WriteReg(0xD624,0x02); LCD_WriteReg(0xD625,0xB7); LCD_WriteReg(0xD626,0x02); LCD_WriteReg(0xD627,0xCF); LCD_WriteReg(0xD628,0x02); LCD_WriteReg(0xD629,0xDE); LCD_WriteReg(0xD62A,0x02); LCD_WriteReg(0xD62B,0xF2); LCD_WriteReg(0xD62C,0x02); LCD_WriteReg(0xD62D,0xFE); LCD_WriteReg(0xD62E,0x03); LCD_WriteReg(0xD62F,0x10); LCD_WriteReg(0xD630,0x03); LCD_WriteReg(0xD631,0x33); LCD_WriteReg(0xD632,0x03); LCD_WriteReg(0xD633,0x6D); //LV2 Page 0 enable LCD_WriteReg(0xF000,0x55); LCD_WriteReg(0xF001,0xAA); LCD_WriteReg(0xF002,0x52); LCD_WriteReg(0xF003,0x08); LCD_WriteReg(0xF004,0x00); //Display control LCD_WriteReg(0xB100, 0xCC); LCD_WriteReg(0xB101, 0x00); //Source hold time LCD_WriteReg(0xB600,0x05); //Gate EQ control LCD_WriteReg(0xB700,0x70); LCD_WriteReg(0xB701,0x70); //Source EQ control (Mode 2) LCD_WriteReg(0xB800,0x01); LCD_WriteReg(0xB801,0x03); LCD_WriteReg(0xB802,0x03); LCD_WriteReg(0xB803,0x03); //Inversion mode (2-dot) LCD_WriteReg(0xBC00,0x02); LCD_WriteReg(0xBC01,0x00); LCD_WriteReg(0xBC02,0x00); //Timing control 4H w/ 4-delay LCD_WriteReg(0xC900,0xD0); LCD_WriteReg(0xC901,0x02); LCD_WriteReg(0xC902,0x50); LCD_WriteReg(0xC903,0x50); LCD_WriteReg(0xC904,0x50); LCD_WriteReg(0x3500,0x00); LCD_WriteReg(0x3A00,0x55); //16-bit/pixel LCD_WR_REG(0x1100); delay_us(120); LCD_WR_REG(0x2900); &#125;else if(lcddev.id==0x9325)//9325 &#123; LCD_WriteReg(0x00E5,0x78F0); LCD_WriteReg(0x0001,0x0100); LCD_WriteReg(0x0002,0x0700); LCD_WriteReg(0x0003,0x1030); LCD_WriteReg(0x0004,0x0000); LCD_WriteReg(0x0008,0x0202); LCD_WriteReg(0x0009,0x0000); LCD_WriteReg(0x000A,0x0000); LCD_WriteReg(0x000C,0x0000); LCD_WriteReg(0x000D,0x0000); LCD_WriteReg(0x000F,0x0000); //power on sequence VGHVGL LCD_WriteReg(0x0010,0x0000); LCD_WriteReg(0x0011,0x0007); LCD_WriteReg(0x0012,0x0000); LCD_WriteReg(0x0013,0x0000); LCD_WriteReg(0x0007,0x0000); //vgh LCD_WriteReg(0x0010,0x1690); LCD_WriteReg(0x0011,0x0227); //delayms(100); //vregiout LCD_WriteReg(0x0012,0x009D); //0x001b //delayms(100); //vom amplitude LCD_WriteReg(0x0013,0x1900); //delayms(100); //vom H LCD_WriteReg(0x0029,0x0025); LCD_WriteReg(0x002B,0x000D); //gamma LCD_WriteReg(0x0030,0x0007); LCD_WriteReg(0x0031,0x0303); LCD_WriteReg(0x0032,0x0003);// 0006 LCD_WriteReg(0x0035,0x0206); LCD_WriteReg(0x0036,0x0008); LCD_WriteReg(0x0037,0x0406); LCD_WriteReg(0x0038,0x0304);//0200 LCD_WriteReg(0x0039,0x0007); LCD_WriteReg(0x003C,0x0602);// 0504 LCD_WriteReg(0x003D,0x0008); //ram LCD_WriteReg(0x0050,0x0000); LCD_WriteReg(0x0051,0x00EF); LCD_WriteReg(0x0052,0x0000); LCD_WriteReg(0x0053,0x013F); LCD_WriteReg(0x0060,0xA700); LCD_WriteReg(0x0061,0x0001); LCD_WriteReg(0x006A,0x0000); // LCD_WriteReg(0x0080,0x0000); LCD_WriteReg(0x0081,0x0000); LCD_WriteReg(0x0082,0x0000); LCD_WriteReg(0x0083,0x0000); LCD_WriteReg(0x0084,0x0000); LCD_WriteReg(0x0085,0x0000); // LCD_WriteReg(0x0090,0x0010); LCD_WriteReg(0x0092,0x0600); LCD_WriteReg(0x0007,0x0133); LCD_WriteReg(0x00,0x0022);// &#125;else if(lcddev.id==0x9328)//ILI9328 OK &#123; LCD_WriteReg(0x00EC,0x108F);// internal timeing LCD_WriteReg(0x00EF,0x1234);// ADD //LCD_WriteReg(0x00e7,0x0010); //LCD_WriteReg(0x0000,0x0001);//å¼€å¯å†…éƒ¨æ—¶é’Ÿ LCD_WriteReg(0x0001,0x0100); LCD_WriteReg(0x0002,0x0700);//ç”µæºå¼€å¯ //LCD_WriteReg(0x0003,(1&lt;&lt;3)|(1&lt;&lt;4) ); //65K RGB //DRIVE TABLE(å¯„å­˜å™¨ 03H) //BIT3=AM BIT4:5=ID0:1 //AM ID0 ID1 FUNCATION // 0 0 0 R-&gt;L D-&gt;U // 1 0 0 D-&gt;U R-&gt;L // 0 1 0 L-&gt;R D-&gt;U // 1 1 0 D-&gt;U L-&gt;R // 0 0 1 R-&gt;L U-&gt;D // 1 0 1 U-&gt;D R-&gt;L // 0 1 1 L-&gt;R U-&gt;D æ­£å¸¸å°±ç”¨è¿™ä¸ª. // 1 1 1 U-&gt;D L-&gt;R LCD_WriteReg(0x0003,(1&lt;&lt;12)|(3&lt;&lt;4)|(0&lt;&lt;3) );//65K LCD_WriteReg(0x0004,0x0000); LCD_WriteReg(0x0008,0x0202); LCD_WriteReg(0x0009,0x0000); LCD_WriteReg(0x000a,0x0000);//display setting LCD_WriteReg(0x000c,0x0001);//display setting LCD_WriteReg(0x000d,0x0000);//0f3c LCD_WriteReg(0x000f,0x0000); //ç”µæºé…ç½® LCD_WriteReg(0x0010,0x0000); LCD_WriteReg(0x0011,0x0007); LCD_WriteReg(0x0012,0x0000); LCD_WriteReg(0x0013,0x0000); LCD_WriteReg(0x0007,0x0001); delay_ms(50); LCD_WriteReg(0x0010,0x1490); LCD_WriteReg(0x0011,0x0227); delay_ms(50); LCD_WriteReg(0x0012,0x008A); delay_ms(50); LCD_WriteReg(0x0013,0x1a00); LCD_WriteReg(0x0029,0x0006); LCD_WriteReg(0x002b,0x000d); delay_ms(50); LCD_WriteReg(0x0020,0x0000); LCD_WriteReg(0x0021,0x0000); delay_ms(50); //ä¼½é©¬æ ¡æ­£ LCD_WriteReg(0x0030,0x0000); LCD_WriteReg(0x0031,0x0604); LCD_WriteReg(0x0032,0x0305); LCD_WriteReg(0x0035,0x0000); LCD_WriteReg(0x0036,0x0C09); LCD_WriteReg(0x0037,0x0204); LCD_WriteReg(0x0038,0x0301); LCD_WriteReg(0x0039,0x0707); LCD_WriteReg(0x003c,0x0000); LCD_WriteReg(0x003d,0x0a0a); delay_ms(50); LCD_WriteReg(0x0050,0x0000); //æ°´å¹³GRAMèµ·å§‹ä½ç½® LCD_WriteReg(0x0051,0x00ef); //æ°´å¹³GRAMç»ˆæ­¢ä½ç½® LCD_WriteReg(0x0052,0x0000); //å‚ç›´GRAMèµ·å§‹ä½ç½® LCD_WriteReg(0x0053,0x013f); //å‚ç›´GRAMç»ˆæ­¢ä½ç½® LCD_WriteReg(0x0060,0xa700); LCD_WriteReg(0x0061,0x0001); LCD_WriteReg(0x006a,0x0000); LCD_WriteReg(0x0080,0x0000); LCD_WriteReg(0x0081,0x0000); LCD_WriteReg(0x0082,0x0000); LCD_WriteReg(0x0083,0x0000); LCD_WriteReg(0x0084,0x0000); LCD_WriteReg(0x0085,0x0000); LCD_WriteReg(0x0090,0x0010); LCD_WriteReg(0x0092,0x0600); //å¼€å¯æ˜¾ç¤ºè®¾ç½® LCD_WriteReg(0x0007,0x0133); &#125;else if(lcddev.id==0x9320)//æµ‹è¯•OK. &#123; LCD_WriteReg(0x00,0x0000); LCD_WriteReg(0x01,0x0100); //Driver Output Contral. LCD_WriteReg(0x02,0x0700); //LCD Driver Waveform Contral. LCD_WriteReg(0x03,0x1030);//Entry Mode Set. //LCD_WriteReg(0x03,0x1018); //Entry Mode Set. LCD_WriteReg(0x04,0x0000); //Scalling Contral. LCD_WriteReg(0x08,0x0202); //Display Contral 2.(0x0207) LCD_WriteReg(0x09,0x0000); //Display Contral 3.(0x0000) LCD_WriteReg(0x0a,0x0000); //Frame Cycle Contal.(0x0000) LCD_WriteReg(0x0c,(1&lt;&lt;0)); //Extern Display Interface Contral 1.(0x0000) LCD_WriteReg(0x0d,0x0000); //Frame Maker Position. LCD_WriteReg(0x0f,0x0000); //Extern Display Interface Contral 2. delay_ms(50); LCD_WriteReg(0x07,0x0101); //Display Contral. delay_ms(50); LCD_WriteReg(0x10,(1&lt;&lt;12)|(0&lt;&lt;8)|(1&lt;&lt;7)|(1&lt;&lt;6)|(0&lt;&lt;4)); //Power Control 1.(0x16b0) LCD_WriteReg(0x11,0x0007); //Power Control 2.(0x0001) LCD_WriteReg(0x12,(1&lt;&lt;8)|(1&lt;&lt;4)|(0&lt;&lt;0)); //Power Control 3.(0x0138) LCD_WriteReg(0x13,0x0b00); //Power Control 4. LCD_WriteReg(0x29,0x0000); //Power Control 7. LCD_WriteReg(0x2b,(1&lt;&lt;14)|(1&lt;&lt;4)); LCD_WriteReg(0x50,0); //Set X Star //æ°´å¹³GRAMç»ˆæ­¢ä½ç½®Set X End. LCD_WriteReg(0x51,239); //Set Y Star LCD_WriteReg(0x52,0); //Set Y End.t. LCD_WriteReg(0x53,319); // LCD_WriteReg(0x60,0x2700); //Driver Output Control. LCD_WriteReg(0x61,0x0001); //Driver Output Control. LCD_WriteReg(0x6a,0x0000); //Vertical Srcoll Control. LCD_WriteReg(0x80,0x0000); //Display Position? Partial Display 1. LCD_WriteReg(0x81,0x0000); //RAM Address Start? Partial Display 1. LCD_WriteReg(0x82,0x0000); //RAM Address End-Partial Display 1. LCD_WriteReg(0x83,0x0000); //Displsy Position? Partial Display 2. LCD_WriteReg(0x84,0x0000); //RAM Address Start? Partial Display 2. LCD_WriteReg(0x85,0x0000); //RAM Address End? Partial Display 2. LCD_WriteReg(0x90,(0&lt;&lt;7)|(16&lt;&lt;0)); //Frame Cycle Contral.(0x0013) LCD_WriteReg(0x92,0x0000); //Panel Interface Contral 2.(0x0000) LCD_WriteReg(0x93,0x0001); //Panel Interface Contral 3. LCD_WriteReg(0x95,0x0110); //Frame Cycle Contral.(0x0110) LCD_WriteReg(0x97,(0&lt;&lt;8)); // LCD_WriteReg(0x98,0x0000); //Frame Cycle Contral. LCD_WriteReg(0x07,0x0173); //(0x0173) &#125;else if(lcddev.id==0X9331)//OK |/|/| &#123; LCD_WriteReg(0x00E7, 0x1014); LCD_WriteReg(0x0001, 0x0100); // set SS and SM bit LCD_WriteReg(0x0002, 0x0200); // set 1 line inversion LCD_WriteReg(0x0003,(1&lt;&lt;12)|(3&lt;&lt;4)|(1&lt;&lt;3));//65K //LCD_WriteReg(0x0003, 0x1030); // set GRAM write direction and BGR=1. LCD_WriteReg(0x0008, 0x0202); // set the back porch and front porch LCD_WriteReg(0x0009, 0x0000); // set non-display area refresh cycle ISC[3:0] LCD_WriteReg(0x000A, 0x0000); // FMARK function LCD_WriteReg(0x000C, 0x0000); // RGB interface setting LCD_WriteReg(0x000D, 0x0000); // Frame marker Position LCD_WriteReg(0x000F, 0x0000); // RGB interface polarity //*************Power On sequence ****************// LCD_WriteReg(0x0010, 0x0000); // SAP, BT[3:0], AP, DSTB, SLP, STB LCD_WriteReg(0x0011, 0x0007); // DC1[2:0], DC0[2:0], VC[2:0] LCD_WriteReg(0x0012, 0x0000); // VREG1OUT voltage LCD_WriteReg(0x0013, 0x0000); // VDV[4:0] for VCOM amplitude delay_ms(200); // Dis-charge capacitor power voltage LCD_WriteReg(0x0010, 0x1690); // SAP, BT[3:0], AP, DSTB, SLP, STB LCD_WriteReg(0x0011, 0x0227); // DC1[2:0], DC0[2:0], VC[2:0] delay_ms(50); // Delay 50ms LCD_WriteReg(0x0012, 0x000C); // Internal reference voltage= Vci; delay_ms(50); // Delay 50ms LCD_WriteReg(0x0013, 0x0800); // Set VDV[4:0] for VCOM amplitude LCD_WriteReg(0x0029, 0x0011); // Set VCM[5:0] for VCOMH LCD_WriteReg(0x002B, 0x000B); // Set Frame Rate delay_ms(50); // Delay 50ms LCD_WriteReg(0x0020, 0x0000); // GRAM horizontal Address LCD_WriteReg(0x0021, 0x013f); // GRAM Vertical Address // ----------- Adjust the Gamma Curve ----------// LCD_WriteReg(0x0030, 0x0000); LCD_WriteReg(0x0031, 0x0106); LCD_WriteReg(0x0032, 0x0000); LCD_WriteReg(0x0035, 0x0204); LCD_WriteReg(0x0036, 0x160A); LCD_WriteReg(0x0037, 0x0707); LCD_WriteReg(0x0038, 0x0106); LCD_WriteReg(0x0039, 0x0707); LCD_WriteReg(0x003C, 0x0402); LCD_WriteReg(0x003D, 0x0C0F); //------------------ Set GRAM area ---------------// LCD_WriteReg(0x0050, 0x0000); // Horizontal GRAM Start Address LCD_WriteReg(0x0051, 0x00EF); // Horizontal GRAM End Address LCD_WriteReg(0x0052, 0x0000); // Vertical GRAM Start Address LCD_WriteReg(0x0053, 0x013F); // Vertical GRAM Start Address LCD_WriteReg(0x0060, 0x2700); // Gate Scan Line LCD_WriteReg(0x0061, 0x0001); // NDL,VLE, REV LCD_WriteReg(0x006A, 0x0000); // set scrolling line //-------------- Partial Display Control ---------// LCD_WriteReg(0x0080, 0x0000); LCD_WriteReg(0x0081, 0x0000); LCD_WriteReg(0x0082, 0x0000); LCD_WriteReg(0x0083, 0x0000); LCD_WriteReg(0x0084, 0x0000); LCD_WriteReg(0x0085, 0x0000); //-------------- Panel Control -------------------// LCD_WriteReg(0x0090, 0x0010); LCD_WriteReg(0x0092, 0x0600); LCD_WriteReg(0x0007, 0x0133); // 262K color and display ON &#125;else if(lcddev.id==0x5408) &#123; LCD_WriteReg(0x01,0x0100); LCD_WriteReg(0x02,0x0700);//LCD Driving Waveform Contral LCD_WriteReg(0x03,0x1030);//Entry Modeè®¾ç½® //æŒ‡é’ˆä»å·¦è‡³å³è‡ªä¸Šè€Œä¸‹çš„è‡ªåŠ¨å¢æ¨¡å¼ //Normal Mode(Window Mode disable) //RGBæ ¼å¼ //16ä½æ•°æ®2æ¬¡ä¼ è¾“çš„8æ€»çº¿è®¾ç½® LCD_WriteReg(0x04,0x0000); //Scalling Control register LCD_WriteReg(0x08,0x0207); //Display Control 2 LCD_WriteReg(0x09,0x0000); //Display Control 3 LCD_WriteReg(0x0A,0x0000); //Frame Cycle Control LCD_WriteReg(0x0C,0x0000); //External Display Interface Control 1 LCD_WriteReg(0x0D,0x0000); //Frame Maker Position LCD_WriteReg(0x0F,0x0000); //External Display Interface Control 2 delay_ms(20); //TFT æ¶²æ™¶å½©è‰²å›¾åƒæ˜¾ç¤ºæ–¹æ³•14 LCD_WriteReg(0x10,0x16B0); //0x14B0 //Power Control 1 LCD_WriteReg(0x11,0x0001); //0x0007 //Power Control 2 LCD_WriteReg(0x17,0x0001); //0x0000 //Power Control 3 LCD_WriteReg(0x12,0x0138); //0x013B //Power Control 4 LCD_WriteReg(0x13,0x0800); //0x0800 //Power Control 5 LCD_WriteReg(0x29,0x0009); //NVM read data 2 LCD_WriteReg(0x2a,0x0009); //NVM read data 3 LCD_WriteReg(0xa4,0x0000); LCD_WriteReg(0x50,0x0000); //è®¾ç½®æ“ä½œçª—å£çš„Xè½´å¼€å§‹åˆ— LCD_WriteReg(0x51,0x00EF); //è®¾ç½®æ“ä½œçª—å£çš„Xè½´ç»“æŸåˆ— LCD_WriteReg(0x52,0x0000); //è®¾ç½®æ“ä½œçª—å£çš„Yè½´å¼€å§‹è¡Œ LCD_WriteReg(0x53,0x013F); //è®¾ç½®æ“ä½œçª—å£çš„Yè½´ç»“æŸè¡Œ LCD_WriteReg(0x60,0x2700); //Driver Output Control //è®¾ç½®å±å¹•çš„ç‚¹æ•°ä»¥åŠæ‰«æçš„èµ·å§‹è¡Œ LCD_WriteReg(0x61,0x0001); //Driver Output Control LCD_WriteReg(0x6A,0x0000); //Vertical Scroll Control LCD_WriteReg(0x80,0x0000); //Display Position â€“ Partial Display 1 LCD_WriteReg(0x81,0x0000); //RAM Address Start â€“ Partial Display 1 LCD_WriteReg(0x82,0x0000); //RAM address End - Partial Display 1 LCD_WriteReg(0x83,0x0000); //Display Position â€“ Partial Display 2 LCD_WriteReg(0x84,0x0000); //RAM Address Start â€“ Partial Display 2 LCD_WriteReg(0x85,0x0000); //RAM address End â€“ Partail Display2 LCD_WriteReg(0x90,0x0013); //Frame Cycle Control LCD_WriteReg(0x92,0x0000); //Panel Interface Control 2 LCD_WriteReg(0x93,0x0003); //Panel Interface control 3 LCD_WriteReg(0x95,0x0110); //Frame Cycle Control LCD_WriteReg(0x07,0x0173); delay_ms(50); &#125; else if(lcddev.id==0x1505)//OK &#123; // second release on 3/5 ,luminance is acceptable,water wave appear during camera preview LCD_WriteReg(0x0007,0x0000); delay_ms(50); LCD_WriteReg(0x0012,0x011C);//0x011A why need to set several times? LCD_WriteReg(0x00A4,0x0001);//NVM LCD_WriteReg(0x0008,0x000F); LCD_WriteReg(0x000A,0x0008); LCD_WriteReg(0x000D,0x0008); //ä¼½é©¬æ ¡æ­£ LCD_WriteReg(0x0030,0x0707); LCD_WriteReg(0x0031,0x0007); //0x0707 LCD_WriteReg(0x0032,0x0603); LCD_WriteReg(0x0033,0x0700); LCD_WriteReg(0x0034,0x0202); LCD_WriteReg(0x0035,0x0002); //?0x0606 LCD_WriteReg(0x0036,0x1F0F); LCD_WriteReg(0x0037,0x0707); //0x0f0f 0x0105 LCD_WriteReg(0x0038,0x0000); LCD_WriteReg(0x0039,0x0000); LCD_WriteReg(0x003A,0x0707); LCD_WriteReg(0x003B,0x0000); //0x0303 LCD_WriteReg(0x003C,0x0007); //?0x0707 LCD_WriteReg(0x003D,0x0000); //0x1313//0x1f08 delay_ms(50); LCD_WriteReg(0x0007,0x0001); LCD_WriteReg(0x0017,0x0001);//å¼€å¯ç”µæº delay_ms(50); //ç”µæºé…ç½® LCD_WriteReg(0x0010,0x17A0); LCD_WriteReg(0x0011,0x0217);//reference voltage VC[2:0] Vciout = 1.00*Vcivl LCD_WriteReg(0x0012,0x011E);//0x011c //Vreg1out = Vcilvl*1.80 is it the same as Vgama1out ? LCD_WriteReg(0x0013,0x0F00);//VDV[4:0]--&gt;VCOM Amplitude VcomL = VcomH - Vcom Ampl LCD_WriteReg(0x002A,0x0000); LCD_WriteReg(0x0029,0x000A);//0x0001F Vcomh = VCM1[4:0]*Vreg1out gate source voltage?? LCD_WriteReg(0x0012,0x013E);// 0x013C power supply on //Coordinates Control// LCD_WriteReg(0x0050,0x0000);//0x0e00 LCD_WriteReg(0x0051,0x00EF); LCD_WriteReg(0x0052,0x0000); LCD_WriteReg(0x0053,0x013F); //Pannel Image Control// LCD_WriteReg(0x0060,0x2700); LCD_WriteReg(0x0061,0x0001); LCD_WriteReg(0x006A,0x0000); LCD_WriteReg(0x0080,0x0000); //Partial Image Control// LCD_WriteReg(0x0081,0x0000); LCD_WriteReg(0x0082,0x0000); LCD_WriteReg(0x0083,0x0000); LCD_WriteReg(0x0084,0x0000); LCD_WriteReg(0x0085,0x0000); //Panel Interface Control// LCD_WriteReg(0x0090,0x0013);//0x0010 frenqucy LCD_WriteReg(0x0092,0x0300); LCD_WriteReg(0x0093,0x0005); LCD_WriteReg(0x0095,0x0000); LCD_WriteReg(0x0097,0x0000); LCD_WriteReg(0x0098,0x0000); LCD_WriteReg(0x0001,0x0100); LCD_WriteReg(0x0002,0x0700); LCD_WriteReg(0x0003,0x1038);//æ‰«ææ–¹å‘ ä¸Š-&gt;ä¸‹ å·¦-&gt;å³ LCD_WriteReg(0x0004,0x0000); LCD_WriteReg(0x000C,0x0000); LCD_WriteReg(0x000F,0x0000); LCD_WriteReg(0x0020,0x0000); LCD_WriteReg(0x0021,0x0000); LCD_WriteReg(0x0007,0x0021); delay_ms(20); LCD_WriteReg(0x0007,0x0061); delay_ms(20); LCD_WriteReg(0x0007,0x0173); delay_ms(20); &#125;else if(lcddev.id==0xB505) &#123; LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x00a4,0x0001); delay_ms(20); LCD_WriteReg(0x0060,0x2700); LCD_WriteReg(0x0008,0x0202); LCD_WriteReg(0x0030,0x0214); LCD_WriteReg(0x0031,0x3715); LCD_WriteReg(0x0032,0x0604); LCD_WriteReg(0x0033,0x0e16); LCD_WriteReg(0x0034,0x2211); LCD_WriteReg(0x0035,0x1500); LCD_WriteReg(0x0036,0x8507); LCD_WriteReg(0x0037,0x1407); LCD_WriteReg(0x0038,0x1403); LCD_WriteReg(0x0039,0x0020); LCD_WriteReg(0x0090,0x001a); LCD_WriteReg(0x0010,0x0000); LCD_WriteReg(0x0011,0x0007); LCD_WriteReg(0x0012,0x0000); LCD_WriteReg(0x0013,0x0000); delay_ms(20); LCD_WriteReg(0x0010,0x0730); LCD_WriteReg(0x0011,0x0137); delay_ms(20); LCD_WriteReg(0x0012,0x01b8); delay_ms(20); LCD_WriteReg(0x0013,0x0f00); LCD_WriteReg(0x002a,0x0080); LCD_WriteReg(0x0029,0x0048); delay_ms(20); LCD_WriteReg(0x0001,0x0100); LCD_WriteReg(0x0002,0x0700); LCD_WriteReg(0x0003,0x1038);//æ‰«ææ–¹å‘ ä¸Š-&gt;ä¸‹ å·¦-&gt;å³ LCD_WriteReg(0x0008,0x0202); LCD_WriteReg(0x000a,0x0000); LCD_WriteReg(0x000c,0x0000); LCD_WriteReg(0x000d,0x0000); LCD_WriteReg(0x000e,0x0030); LCD_WriteReg(0x0050,0x0000); LCD_WriteReg(0x0051,0x00ef); LCD_WriteReg(0x0052,0x0000); LCD_WriteReg(0x0053,0x013f); LCD_WriteReg(0x0060,0x2700); LCD_WriteReg(0x0061,0x0001); LCD_WriteReg(0x006a,0x0000); //LCD_WriteReg(0x0080,0x0000); //LCD_WriteReg(0x0081,0x0000); LCD_WriteReg(0x0090,0X0011); LCD_WriteReg(0x0092,0x0600); LCD_WriteReg(0x0093,0x0402); LCD_WriteReg(0x0094,0x0002); delay_ms(20); LCD_WriteReg(0x0007,0x0001); delay_ms(20); LCD_WriteReg(0x0007,0x0061); LCD_WriteReg(0x0007,0x0173); LCD_WriteReg(0x0020,0x0000); LCD_WriteReg(0x0021,0x0000); LCD_WriteReg(0x00,0x22); &#125;else if(lcddev.id==0xC505) &#123; LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); delay_ms(20); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x0000,0x0000); LCD_WriteReg(0x00a4,0x0001); delay_ms(20); LCD_WriteReg(0x0060,0x2700); LCD_WriteReg(0x0008,0x0806); LCD_WriteReg(0x0030,0x0703);//gamma setting LCD_WriteReg(0x0031,0x0001); LCD_WriteReg(0x0032,0x0004); LCD_WriteReg(0x0033,0x0102); LCD_WriteReg(0x0034,0x0300); LCD_WriteReg(0x0035,0x0103); LCD_WriteReg(0x0036,0x001F); LCD_WriteReg(0x0037,0x0703); LCD_WriteReg(0x0038,0x0001); LCD_WriteReg(0x0039,0x0004); LCD_WriteReg(0x0090, 0x0015); //80Hz LCD_WriteReg(0x0010, 0X0410); //BT,AP LCD_WriteReg(0x0011,0x0247); //DC1,DC0,VC LCD_WriteReg(0x0012, 0x01BC); LCD_WriteReg(0x0013, 0x0e00); delay_ms(120); LCD_WriteReg(0x0001, 0x0100); LCD_WriteReg(0x0002, 0x0200); LCD_WriteReg(0x0003, 0x1030); LCD_WriteReg(0x000A, 0x0008); LCD_WriteReg(0x000C, 0x0000); LCD_WriteReg(0x000E, 0x0020); LCD_WriteReg(0x000F, 0x0000); LCD_WriteReg(0x0020, 0x0000); //H Start LCD_WriteReg(0x0021, 0x0000); //V Start LCD_WriteReg(0x002A,0x003D); //vcom2 delay_ms(20); LCD_WriteReg(0x0029, 0x002d); LCD_WriteReg(0x0050, 0x0000); LCD_WriteReg(0x0051, 0xD0EF); LCD_WriteReg(0x0052, 0x0000); LCD_WriteReg(0x0053, 0x013F); LCD_WriteReg(0x0061, 0x0000); LCD_WriteReg(0x006A, 0x0000); LCD_WriteReg(0x0092,0x0300); LCD_WriteReg(0x0093, 0x0005); LCD_WriteReg(0x0007, 0x0100); &#125;else if(lcddev.id==0x4531)//OK |/|/| &#123; LCD_WriteReg(0X00,0X0001); delay_ms(10); LCD_WriteReg(0X10,0X1628); LCD_WriteReg(0X12,0X000e);//0x0006 LCD_WriteReg(0X13,0X0A39); delay_ms(10); LCD_WriteReg(0X11,0X0040); LCD_WriteReg(0X15,0X0050); delay_ms(10); LCD_WriteReg(0X12,0X001e);//16 delay_ms(10); LCD_WriteReg(0X10,0X1620); LCD_WriteReg(0X13,0X2A39); delay_ms(10); LCD_WriteReg(0X01,0X0100); LCD_WriteReg(0X02,0X0300); LCD_WriteReg(0X03,0X1038);//æ”¹å˜æ–¹å‘çš„ LCD_WriteReg(0X08,0X0202); LCD_WriteReg(0X0A,0X0008); LCD_WriteReg(0X30,0X0000); LCD_WriteReg(0X31,0X0402); LCD_WriteReg(0X32,0X0106); LCD_WriteReg(0X33,0X0503); LCD_WriteReg(0X34,0X0104); LCD_WriteReg(0X35,0X0301); LCD_WriteReg(0X36,0X0707); LCD_WriteReg(0X37,0X0305); LCD_WriteReg(0X38,0X0208); LCD_WriteReg(0X39,0X0F0B); LCD_WriteReg(0X41,0X0002); LCD_WriteReg(0X60,0X2700); LCD_WriteReg(0X61,0X0001); LCD_WriteReg(0X90,0X0210); LCD_WriteReg(0X92,0X010A); LCD_WriteReg(0X93,0X0004); LCD_WriteReg(0XA0,0X0100); LCD_WriteReg(0X07,0X0001); LCD_WriteReg(0X07,0X0021); LCD_WriteReg(0X07,0X0023); LCD_WriteReg(0X07,0X0033); LCD_WriteReg(0X07,0X0133); LCD_WriteReg(0XA0,0X0000); &#125;else if(lcddev.id==0x4535) &#123; LCD_WriteReg(0X15,0X0030); LCD_WriteReg(0X9A,0X0010); LCD_WriteReg(0X11,0X0020); LCD_WriteReg(0X10,0X3428); LCD_WriteReg(0X12,0X0002);//16 LCD_WriteReg(0X13,0X1038); delay_ms(40); LCD_WriteReg(0X12,0X0012);//16 delay_ms(40); LCD_WriteReg(0X10,0X3420); LCD_WriteReg(0X13,0X3038); delay_ms(70); LCD_WriteReg(0X30,0X0000); LCD_WriteReg(0X31,0X0402); LCD_WriteReg(0X32,0X0307); LCD_WriteReg(0X33,0X0304); LCD_WriteReg(0X34,0X0004); LCD_WriteReg(0X35,0X0401); LCD_WriteReg(0X36,0X0707); LCD_WriteReg(0X37,0X0305); LCD_WriteReg(0X38,0X0610); LCD_WriteReg(0X39,0X0610); LCD_WriteReg(0X01,0X0100); LCD_WriteReg(0X02,0X0300); LCD_WriteReg(0X03,0X1030);//æ”¹å˜æ–¹å‘çš„ LCD_WriteReg(0X08,0X0808); LCD_WriteReg(0X0A,0X0008); LCD_WriteReg(0X60,0X2700); LCD_WriteReg(0X61,0X0001); LCD_WriteReg(0X90,0X013E); LCD_WriteReg(0X92,0X0100); LCD_WriteReg(0X93,0X0100); LCD_WriteReg(0XA0,0X3000); LCD_WriteReg(0XA3,0X0010); LCD_WriteReg(0X07,0X0001); LCD_WriteReg(0X07,0X0021); LCD_WriteReg(0X07,0X0023); LCD_WriteReg(0X07,0X0033); LCD_WriteReg(0X07,0X0133); &#125;else if(lcddev.id==0X1963) &#123; LCD_WR_REG(0xE2); //Set PLL with OSC = 10MHz (hardware), Multiplier N = 35, 250MHz &lt; VCO &lt; 800MHz = OSC*(N+1), VCO = 360MHz LCD_WR_DATA(0x23); //å‚æ•°1 LCD_WR_DATA(0x02); //å‚æ•°2 Divider M = 2, PLL = 360/(M+1) = 120MHz LCD_WR_DATA(0x04); //å‚æ•°3 Validate M and N values delay_us(100); LCD_WR_REG(0xE0); // Start PLL command LCD_WR_DATA(0x01); // enable PLL delay_ms(10); LCD_WR_REG(0xE0); // Start PLL command again LCD_WR_DATA(0x03); // now, use PLL output as system clock delay_ms(12); LCD_WR_REG(0x01); //è½¯å¤ä½ delay_ms(10); LCD_WR_REG(0xE6); //è®¾ç½®åƒç´ é¢‘ç‡ LCD_WR_DATA(0x03); LCD_WR_DATA(0xFF); LCD_WR_DATA(0xFF); LCD_WR_REG(0xB0); //è®¾ç½®LCDæ¨¡å¼ LCD_WR_DATA(0x20); //24ä½æ¨¡å¼ LCD_WR_DATA(0x00); //TFT æ¨¡å¼ LCD_WR_DATA((SSD_HOR_RESOLUTION-1)&gt;&gt;8);//è®¾ç½®LCDæ°´å¹³åƒç´  LCD_WR_DATA(SSD_HOR_RESOLUTION-1); LCD_WR_DATA((SSD_VER_RESOLUTION-1)&gt;&gt;8);//è®¾ç½®LCDå‚ç›´åƒç´  LCD_WR_DATA(SSD_VER_RESOLUTION-1); LCD_WR_DATA(0x00); //RGBåºåˆ— LCD_WR_REG(0xB4); //Set horizontal period LCD_WR_DATA((SSD_HT-1)&gt;&gt;8); LCD_WR_DATA(SSD_HT-1); LCD_WR_DATA((SSD_HPS-1)&gt;&gt;8); LCD_WR_DATA(SSD_HPS-1); LCD_WR_DATA(SSD_HOR_PULSE_WIDTH-1); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xB6); //Set vertical period LCD_WR_DATA((SSD_VT-1)&gt;&gt;8); LCD_WR_DATA(SSD_VT-1); LCD_WR_DATA((SSD_VSP-1)&gt;&gt;8); LCD_WR_DATA(SSD_VSP-1); LCD_WR_DATA(SSD_VER_FRONT_PORCH-1); LCD_WR_DATA(0x00); LCD_WR_DATA(0x00); LCD_WR_REG(0xF0); //è®¾ç½®SSD1963ä¸CPUæ¥å£ä¸º16bit LCD_WR_DATA(0x03); //16-bit(565 format) data for 16bpp LCD_WR_REG(0x29); //å¼€å¯æ˜¾ç¤º //è®¾ç½®PWMè¾“å‡º èƒŒå…‰é€šè¿‡å ç©ºæ¯”å¯è°ƒ LCD_WR_REG(0xD0); //è®¾ç½®è‡ªåŠ¨ç™½å¹³è¡¡DBC LCD_WR_DATA(0x00); //disable LCD_WR_REG(0xBE); //é…ç½®PWMè¾“å‡º LCD_WR_DATA(0x05); //1è®¾ç½®PWMé¢‘ç‡ LCD_WR_DATA(0xFE); //2è®¾ç½®PWMå ç©ºæ¯” LCD_WR_DATA(0x01); //3è®¾ç½®C LCD_WR_DATA(0xFF); //4è®¾ç½®D LCD_WR_DATA(0x00); //5è®¾ç½®E LCD_WR_REG(0xB8); //è®¾ç½®GPIOé…ç½® LCD_WR_DATA(0x0F); //4ä¸ªIOå£è®¾ç½®æˆè¾“å‡º LCD_WR_DATA(0x01); //GPIOä½¿ç”¨æ­£å¸¸çš„IOåŠŸèƒ½ LCD_WR_REG(0xBA); LCD_WR_DATA(0X01); //GPIO[1:0]=01,æ§åˆ¶LCDæ–¹å‘ LCD_SSD_BackLightSet(100);//èƒŒå…‰è®¾ç½®ä¸ºæœ€äº® &#125; LCD_Display_Dir(0); //é»˜è®¤ä¸ºç«–å± LCD_LED=1; //ç‚¹äº®èƒŒå…‰ LCD_Clear(WHITE);&#125; //æ¸…å±å‡½æ•°//color:è¦æ¸…å±çš„å¡«å……è‰²void LCD_Clear(u16 color)&#123; u32 index=0; u32 totalpoint=lcddev.width; totalpoint*=lcddev.height; //å¾—åˆ°æ€»ç‚¹æ•° if((lcddev.id==0X6804)&amp;&amp;(lcddev.dir==1))//6804æ¨ªå±çš„æ—¶å€™ç‰¹æ®Šå¤„ç† &#123; lcddev.dir=0; lcddev.setxcmd=0X2A; lcddev.setycmd=0X2B; LCD_SetCursor(0x00,0x0000); //è®¾ç½®å…‰æ ‡ä½ç½® lcddev.dir=1; lcddev.setxcmd=0X2B; lcddev.setycmd=0X2A; &#125;else LCD_SetCursor(0x00,0x0000); //è®¾ç½®å…‰æ ‡ä½ç½® LCD_WriteRAM_Prepare(); //å¼€å§‹å†™å…¥GRAM for(index=0;index&lt;totalpoint;index++) &#123; LCD-&gt;LCD_RAM=color; &#125;&#125; //åœ¨æŒ‡å®šåŒºåŸŸå†…å¡«å……å•ä¸ªé¢œè‰²//(sx,sy),(ex,ey):å¡«å……çŸ©å½¢å¯¹è§’åæ ‡,åŒºåŸŸå¤§å°ä¸º:(ex-sx+1)*(ey-sy+1) //color:è¦å¡«å……çš„é¢œè‰²void LCD_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 color)&#123; u16 i,j; u16 xlen=0; u16 temp; if((lcddev.id==0X6804)&amp;&amp;(lcddev.dir==1)) //6804æ¨ªå±çš„æ—¶å€™ç‰¹æ®Šå¤„ç† &#123; temp=sx; sx=sy; sy=lcddev.width-ex-1; ex=ey; ey=lcddev.width-temp-1; lcddev.dir=0; lcddev.setxcmd=0X2A; lcddev.setycmd=0X2B; LCD_Fill(sx,sy,ex,ey,color); lcddev.dir=1; lcddev.setxcmd=0X2B; lcddev.setycmd=0X2A; &#125;else &#123; xlen=ex-sx+1; for(i=sy;i&lt;=ey;i++) &#123; LCD_SetCursor(sx,i); //è®¾ç½®å…‰æ ‡ä½ç½® LCD_WriteRAM_Prepare(); //å¼€å§‹å†™å…¥GRAM for(j=0;j&lt;xlen;j++)LCD-&gt;LCD_RAM=color; //æ˜¾ç¤ºé¢œè‰² &#125; &#125; &#125; //åœ¨æŒ‡å®šåŒºåŸŸå†…å¡«å……æŒ‡å®šé¢œè‰²å— //(sx,sy),(ex,ey):å¡«å……çŸ©å½¢å¯¹è§’åæ ‡,åŒºåŸŸå¤§å°ä¸º:(ex-sx+1)*(ey-sy+1) //color:è¦å¡«å……çš„é¢œè‰²void LCD_Color_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 *color)&#123; u16 height,width; u16 i,j; width=ex-sx+1; //å¾—åˆ°å¡«å……çš„å®½åº¦ height=ey-sy+1; //é«˜åº¦ for(i=0;i&lt;height;i++) &#123; LCD_SetCursor(sx,sy+i); //è®¾ç½®å…‰æ ‡ä½ç½® LCD_WriteRAM_Prepare(); //å¼€å§‹å†™å…¥GRAM for(j=0;j&lt;width;j++)LCD-&gt;LCD_RAM=color[i*width+j];//å†™å…¥æ•°æ® &#125; &#125; //ç”»çº¿//x1,y1:èµ·ç‚¹åæ ‡//x2,y2:ç»ˆç‚¹åæ ‡ void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)&#123; u16 t; int xerr=0,yerr=0,delta_x,delta_y,distance; int incx,incy,uRow,uCol; delta_x=x2-x1; //è®¡ç®—åæ ‡å¢é‡ delta_y=y2-y1; uRow=x1; uCol=y1; if(delta_x&gt;0)incx=1; //è®¾ç½®å•æ­¥æ–¹å‘ else if(delta_x==0)incx=0;//å‚ç›´çº¿ else &#123;incx=-1;delta_x=-delta_x;&#125; if(delta_y&gt;0)incy=1; else if(delta_y==0)incy=0;//æ°´å¹³çº¿ else&#123;incy=-1;delta_y=-delta_y;&#125; if( delta_x&gt;delta_y)distance=delta_x; //é€‰å–åŸºæœ¬å¢é‡åæ ‡è½´ else distance=delta_y; for(t=0;t&lt;=distance+1;t++ )//ç”»çº¿è¾“å‡º &#123; LCD_DrawPoint(uRow,uCol);//ç”»ç‚¹ xerr+=delta_x ; yerr+=delta_y ; if(xerr&gt;distance) &#123; xerr-=distance; uRow+=incx; &#125; if(yerr&gt;distance) &#123; yerr-=distance; uCol+=incy; &#125; &#125; &#125; //ç”»çŸ©å½¢ //(x1,y1),(x2,y2):çŸ©å½¢çš„å¯¹è§’åæ ‡void LCD_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2)&#123; LCD_DrawLine(x1,y1,x2,y1); LCD_DrawLine(x1,y1,x1,y2); LCD_DrawLine(x1,y2,x2,y2); LCD_DrawLine(x2,y1,x2,y2);&#125;//åœ¨æŒ‡å®šä½ç½®ç”»ä¸€ä¸ªæŒ‡å®šå¤§å°çš„åœ†//(x,y):ä¸­å¿ƒç‚¹//r :åŠå¾„void LCD_Draw_Circle(u16 x0,u16 y0,u8 r)&#123; int a,b; int di; a=0;b=r; di=3-(r&lt;&lt;1); //åˆ¤æ–­ä¸‹ä¸ªç‚¹ä½ç½®çš„æ ‡å¿— while(a&lt;=b) &#123; LCD_DrawPoint(x0+a,y0-b); //5 LCD_DrawPoint(x0+b,y0-a); //0 LCD_DrawPoint(x0+b,y0+a); //4 LCD_DrawPoint(x0+a,y0+b); //6 LCD_DrawPoint(x0-a,y0+b); //1 LCD_DrawPoint(x0-b,y0+a); LCD_DrawPoint(x0-a,y0-b); //2 LCD_DrawPoint(x0-b,y0-a); //7 a++; //ä½¿ç”¨Bresenhamç®—æ³•ç”»åœ† if(di&lt;0)di +=4*a+6; else &#123; di+=10+4*(a-b); b--; &#125; &#125;&#125; //åœ¨æŒ‡å®šä½ç½®æ˜¾ç¤ºä¸€ä¸ªå­—ç¬¦//x,y:èµ·å§‹åæ ‡//num:è¦æ˜¾ç¤ºçš„å­—ç¬¦:&quot; &quot;---&gt;&quot;~&quot;//size:å­—ä½“å¤§å° 12/16/24//mode:å åŠ æ–¹å¼(1)è¿˜æ˜¯éå åŠ æ–¹å¼(0)void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode)&#123; u8 temp,t1,t; u16 y0=y; u8 csize=(size/8+((size%8)?1:0))*(size/2); //å¾—åˆ°å­—ä½“ä¸€ä¸ªå­—ç¬¦å¯¹åº”ç‚¹é˜µé›†æ‰€å çš„å­—èŠ‚æ•° num=num-&#x27; &#x27;;//å¾—åˆ°åç§»åçš„å€¼ï¼ˆASCIIå­—åº“æ˜¯ä»ç©ºæ ¼å¼€å§‹å–æ¨¡ï¼Œæ‰€ä»¥-&#x27; &#x27;å°±æ˜¯å¯¹åº”å­—ç¬¦çš„å­—åº“ï¼‰ for(t=0;t&lt;csize;t++) &#123; if(size==12)temp=asc2_1206[num][t]; //è°ƒç”¨1206å­—ä½“ else if(size==16)temp=asc2_1608[num][t]; //è°ƒç”¨1608å­—ä½“ else if(size==24)temp=asc2_2412[num][t]; //è°ƒç”¨2412å­—ä½“ else return; //æ²¡æœ‰çš„å­—åº“ for(t1=0;t1&lt;8;t1++) &#123; if(temp&amp;0x80)LCD_Fast_DrawPoint(x,y,POINT_COLOR); else if(mode==0)LCD_Fast_DrawPoint(x,y,BACK_COLOR); temp&lt;&lt;=1; y++; if(y&gt;=lcddev.height)return; //è¶…åŒºåŸŸäº† if((y-y0)==size) &#123; y=y0; x++; if(x&gt;=lcddev.width)return; //è¶…åŒºåŸŸäº† break; &#125; &#125; &#125; &#125; //m^nå‡½æ•°//è¿”å›å€¼:m^næ¬¡æ–¹.u32 LCD_Pow(u8 m,u8 n)&#123; u32 result=1; while(n--)result*=m; return result;&#125; //æ˜¾ç¤ºæ•°å­—,é«˜ä½ä¸º0,åˆ™ä¸æ˜¾ç¤º//x,y :èµ·ç‚¹åæ ‡ //len :æ•°å­—çš„ä½æ•°//size:å­—ä½“å¤§å°//color:é¢œè‰² //num:æ•°å€¼(0~4294967295); void LCD_ShowNum(u16 x,u16 y,u32 num,u8 len,u8 size)&#123; u8 t,temp; u8 enshow=0; for(t=0;t&lt;len;t++) &#123; temp=(num/LCD_Pow(10,len-t-1))%10; if(enshow==0&amp;&amp;t&lt;(len-1)) &#123; if(temp==0) &#123; LCD_ShowChar(x+(size/2)*t,y,&#x27; &#x27;,size,0); continue; &#125;else enshow=1; &#125; LCD_ShowChar(x+(size/2)*t,y,temp+&#x27;0&#x27;,size,0); &#125;&#125; //æ˜¾ç¤ºæ•°å­—,é«˜ä½ä¸º0,è¿˜æ˜¯æ˜¾ç¤º//x,y:èµ·ç‚¹åæ ‡//num:æ•°å€¼(0~999999999); //len:é•¿åº¦(å³è¦æ˜¾ç¤ºçš„ä½æ•°)//size:å­—ä½“å¤§å°//mode://[7]:0,ä¸å¡«å……;1,å¡«å……0.//[6:1]:ä¿ç•™//[0]:0,éå åŠ æ˜¾ç¤º;1,å åŠ æ˜¾ç¤º.void LCD_ShowxNum(u16 x,u16 y,u32 num,u8 len,u8 size,u8 mode)&#123; u8 t,temp; u8 enshow=0; for(t=0;t&lt;len;t++) &#123; temp=(num/LCD_Pow(10,len-t-1))%10; if(enshow==0&amp;&amp;t&lt;(len-1)) &#123; if(temp==0) &#123; if(mode&amp;0X80)LCD_ShowChar(x+(size/2)*t,y,&#x27;0&#x27;,size,mode&amp;0X01); else LCD_ShowChar(x+(size/2)*t,y,&#x27; &#x27;,size,mode&amp;0X01); continue; &#125;else enshow=1; &#125; LCD_ShowChar(x+(size/2)*t,y,temp+&#x27;0&#x27;,size,mode&amp;0X01); &#125;&#125; //æ˜¾ç¤ºå­—ç¬¦ä¸²//x,y:èµ·ç‚¹åæ ‡//width,height:åŒºåŸŸå¤§å° //size:å­—ä½“å¤§å°//*p:å­—ç¬¦ä¸²èµ·å§‹åœ°å€ void LCD_ShowString(u16 x,u16 y,u16 width,u16 height,u8 size,u8 *p)&#123; u8 x0=x; width+=x; height+=y; while((*p&lt;=&#x27;~&#x27;)&amp;&amp;(*p&gt;=&#x27; &#x27;))//åˆ¤æ–­æ˜¯ä¸æ˜¯éæ³•å­—ç¬¦! &#123; if(x&gt;=width)&#123;x=x0;y+=size;&#125; if(y&gt;=height)break;//é€€å‡º LCD_ShowChar(x,y,*p,size,0); x+=size/2; p++; &#125; &#125;/******************* END OF FILE *********/ lcd.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// lcd.h#ifndef __LCD_H#define __LCD_H #include &quot;sys.h&quot; #include &quot;stdlib.h&quot; //LCDé‡è¦å‚æ•°é›†typedef struct &#123; u16 width; //LCD å®½åº¦ u16 height; //LCD é«˜åº¦ u16 id; //LCD ID u8 dir; //æ¨ªå±è¿˜æ˜¯ç«–å±æ§åˆ¶ï¼š0ï¼Œç«–å±ï¼›1ï¼Œæ¨ªå±ã€‚ u16 wramcmd; //å¼€å§‹å†™gramæŒ‡ä»¤ u16 setxcmd; //è®¾ç½®xåæ ‡æŒ‡ä»¤ u16 setycmd; //è®¾ç½®yåæ ‡æŒ‡ä»¤ &#125;_lcd_dev; //LCDå‚æ•°extern _lcd_dev lcddev; //ç®¡ç†LCDé‡è¦å‚æ•°//LCDçš„ç”»ç¬”é¢œè‰²å’ŒèƒŒæ™¯è‰² extern u16 POINT_COLOR;//é»˜è®¤çº¢è‰² extern u16 BACK_COLOR; //èƒŒæ™¯é¢œè‰².é»˜è®¤ä¸ºç™½è‰²////////////////////////////////////////////////////////////////////////////////// //-----------------LCDç«¯å£å®šä¹‰---------------- #define LCD_LED PBout(0) //LCDèƒŒå…‰ PB0 //LCDåœ°å€ç»“æ„ä½“typedef struct&#123; vu16 LCD_REG; vu16 LCD_RAM;&#125; LCD_TypeDef;//ä½¿ç”¨NOR/SRAMçš„ Bank1.sector4,åœ°å€ä½HADDR[27,26]=11 A10ä½œä¸ºæ•°æ®å‘½ä»¤åŒºåˆ†çº¿ //æ³¨æ„è®¾ç½®æ—¶STM32å†…éƒ¨ä¼šå³ç§»ä¸€ä½å¯¹å…¶! #define LCD_BASE ((u32)(0x6C000000 | 0x000007FE))#define LCD ((LCD_TypeDef *) LCD_BASE)////////////////////////////////////////////////////////////////////////////////// //æ‰«ææ–¹å‘å®šä¹‰#define L2R_U2D 0 //ä»å·¦åˆ°å³,ä»ä¸Šåˆ°ä¸‹#define L2R_D2U 1 //ä»å·¦åˆ°å³,ä»ä¸‹åˆ°ä¸Š#define R2L_U2D 2 //ä»å³åˆ°å·¦,ä»ä¸Šåˆ°ä¸‹#define R2L_D2U 3 //ä»å³åˆ°å·¦,ä»ä¸‹åˆ°ä¸Š#define U2D_L2R 4 //ä»ä¸Šåˆ°ä¸‹,ä»å·¦åˆ°å³#define U2D_R2L 5 //ä»ä¸Šåˆ°ä¸‹,ä»å³åˆ°å·¦#define D2U_L2R 6 //ä»ä¸‹åˆ°ä¸Š,ä»å·¦åˆ°å³#define D2U_R2L 7 //ä»ä¸‹åˆ°ä¸Š,ä»å³åˆ°å·¦ #define DFT_SCAN_DIR L2R_U2D //é»˜è®¤çš„æ‰«ææ–¹å‘//ç”»ç¬”é¢œè‰²#define WHITE 0xFFFF#define BLACK 0x0000 #define BLUE 0x001F #define BRED 0XF81F#define GRED 0XFFE0#define GBLUE 0X07FF#define RED 0xF800#define MAGENTA 0xF81F#define GREEN 0x07E0#define CYAN 0x7FFF#define YELLOW 0xFFE0#define BROWN 0XBC40 //æ£•è‰²#define BRRED 0XFC07 //æ£•çº¢è‰²#define GRAY 0X8430 //ç°è‰²//GUIé¢œè‰²#define DARKBLUE 0X01CF //æ·±è“è‰²#define LIGHTBLUE 0X7D7C //æµ…è“è‰² #define GRAYBLUE 0X5458 //ç°è“è‰²//ä»¥ä¸Šä¸‰è‰²ä¸ºPANELçš„é¢œè‰² #define LIGHTGREEN 0X841F //æµ…ç»¿è‰²//#define LIGHTGRAY 0XEF5B //æµ…ç°è‰²(PANNEL)#define LGRAY 0XC618 //æµ…ç°è‰²(PANNEL),çª—ä½“èƒŒæ™¯è‰²#define LGRAYBLUE 0XA651 //æµ…ç°è“è‰²(ä¸­é—´å±‚é¢œè‰²)#define LBBLUE 0X2B12 //æµ…æ£•è“è‰²(é€‰æ‹©æ¡ç›®çš„åè‰²) void LCD_Init(void); //åˆå§‹åŒ–void LCD_DisplayOn(void); //å¼€æ˜¾ç¤ºvoid LCD_DisplayOff(void); //å…³æ˜¾ç¤ºvoid LCD_Clear(u16 Color); //æ¸…å±void LCD_SetCursor(u16 Xpos, u16 Ypos); //è®¾ç½®å…‰æ ‡void LCD_DrawPoint(u16 x,u16 y); //ç”»ç‚¹void LCD_Fast_DrawPoint(u16 x,u16 y,u16 color); //å¿«é€Ÿç”»ç‚¹u16 LCD_ReadPoint(u16 x,u16 y); //è¯»ç‚¹ void LCD_Draw_Circle(u16 x0,u16 y0,u8 r); //ç”»åœ†void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2); //ç”»çº¿void LCD_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2); //ç”»çŸ©å½¢void LCD_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 color); //å¡«å……å•è‰²void LCD_Color_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 *color); //å¡«å……æŒ‡å®šé¢œè‰²void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode); //æ˜¾ç¤ºä¸€ä¸ªå­—ç¬¦void LCD_ShowNum(u16 x,u16 y,u32 num,u8 len,u8 size); //æ˜¾ç¤ºä¸€ä¸ªæ•°å­—void LCD_ShowxNum(u16 x,u16 y,u32 num,u8 len,u8 size,u8 mode); //æ˜¾ç¤º æ•°å­—void LCD_ShowString(u16 x,u16 y,u16 width,u16 height,u8 size,u8 *p); //æ˜¾ç¤ºä¸€ä¸ªå­—ç¬¦ä¸²,12/16å­—ä½“void LCD_WriteReg(u16 LCD_Reg, u16 LCD_RegValue);u16 LCD_ReadReg(u16 LCD_Reg);void LCD_WriteRAM_Prepare(void);void LCD_WriteRAM(u16 RGB_Code);void LCD_SSD_BackLightSet(u8 pwm); //SSD1963 èƒŒå…‰æ§åˆ¶void LCD_Scan_Dir(u8 dir); //è®¾ç½®å±æ‰«ææ–¹å‘void LCD_Display_Dir(u8 dir); //è®¾ç½®å±å¹•æ˜¾ç¤ºæ–¹å‘void LCD_Set_Window(u16 sx,u16 sy,u16 width,u16 height); //è®¾ç½®çª—å£ //LCDåˆ†è¾¨ç‡è®¾ç½®#define SSD_HOR_RESOLUTION 800 //LCDæ°´å¹³åˆ†è¾¨ç‡#define SSD_VER_RESOLUTION 480 //LCDå‚ç›´åˆ†è¾¨ç‡//LCDé©±åŠ¨å‚æ•°è®¾ç½®#define SSD_HOR_PULSE_WIDTH 1 //æ°´å¹³è„‰å®½#define SSD_HOR_BACK_PORCH 210 //æ°´å¹³å‰å»Š#define SSD_HOR_FRONT_PORCH 45 //æ°´å¹³åå»Š#define SSD_VER_PULSE_WIDTH 1 //å‚ç›´è„‰å®½#define SSD_VER_BACK_PORCH 34 //å‚ç›´å‰å»Š#define SSD_VER_FRONT_PORCH 10 //å‚ç›´å‰å»Š//å¦‚ä¸‹å‡ ä¸ªå‚æ•°ï¼Œè‡ªåŠ¨è®¡ç®—#define SSD_HT (SSD_HOR_RESOLUTION+SSD_HOR_PULSE_WIDTH+SSD_HOR_BACK_PORCH+SSD_HOR_FRONT_PORCH)#define SSD_HPS (SSD_HOR_PULSE_WIDTH+SSD_HOR_BACK_PORCH)#define SSD_VT (SSD_VER_PULSE_WIDTH+SSD_VER_BACK_PORCH+SSD_VER_FRONT_PORCH+SSD_VER_RESOLUTION)#define SSD_VSP (SSD_VER_PULSE_WIDTH+SSD_VER_BACK_PORCH)#endif /******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;lcd.h&quot;#include &quot;usart.h&quot; int main(void) &#123; u8 x=0; u8 lcd_id[12]; //å­˜æ”¾LCD IDå­—ç¬¦ä¸² delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //LEDç«¯å£åˆå§‹åŒ– LCD_Init(); POINT_COLOR=RED; sprintf((char*)lcd_id,&quot;LCD ID:%04X&quot;,lcddev.id);//å°†LCD IDæ‰“å°åˆ°lcd_idæ•°ç»„ã€‚ while(1) &#123; switch(x) &#123; case 0:LCD_Clear(WHITE);break; case 1:LCD_Clear(BLACK);break; case 2:LCD_Clear(BLUE);break; case 3:LCD_Clear(RED);break; case 4:LCD_Clear(MAGENTA);break; case 5:LCD_Clear(GREEN);break; case 6:LCD_Clear(CYAN);break; case 7:LCD_Clear(YELLOW);break; case 8:LCD_Clear(BRRED);break; case 9:LCD_Clear(GRAY);break; case 10:LCD_Clear(LGRAY);break; case 11:LCD_Clear(BROWN);break; &#125; POINT_COLOR=RED; LCD_ShowString(30,40,210,24,24,&quot;Elite STM32F1 ^_^&quot;); LCD_ShowString(30,70,200,16,16,&quot;TFTLCD TEST&quot;); LCD_ShowString(30,90,200,16,16,&quot;ATOM@ALIENTEK&quot;); LCD_ShowString(30,110,200,16,16,lcd_id); //æ˜¾ç¤ºLCD ID LCD_ShowString(30,130,200,12,12,&quot;2015/1/14&quot;); x++; if(x==12)x=0; LED0=!LED0; delay_ms(1000); &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ12ï¼‰OLEDæ˜¾ç¤º","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-012","date":"2022-11-08T02:59:18.000Z","updated":"2023-04-05T14:19:45.345Z","comments":true,"path":"posts/3728621497.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3728621497.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ oled.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270// oled.c#include &quot;oled.h&quot;#include &quot;stdlib.h&quot;#include &quot;oledfont.h&quot; #include &quot;delay.h&quot;//OLEDçš„æ˜¾å­˜//å­˜æ”¾æ ¼å¼å¦‚ä¸‹.//[0]0 1 2 3 ... 127 //[1]0 1 2 3 ... 127 //[2]0 1 2 3 ... 127 //[3]0 1 2 3 ... 127 //[4]0 1 2 3 ... 127 //[5]0 1 2 3 ... 127 //[6]0 1 2 3 ... 127 //[7]0 1 2 3 ... 127 u8 OLED_GRAM[128][8]; //æ›´æ–°æ˜¾å­˜åˆ°LCD void OLED_Refresh_Gram(void)&#123; u8 i,n; for(i=0;i&lt;8;i++) &#123; OLED_WR_Byte (0xb0+i,OLED_CMD); //è®¾ç½®é¡µåœ°å€ï¼ˆ0~7ï¼‰ OLED_WR_Byte (0x00,OLED_CMD); //è®¾ç½®æ˜¾ç¤ºä½ç½®â€”åˆ—ä½åœ°å€ OLED_WR_Byte (0x10,OLED_CMD); //è®¾ç½®æ˜¾ç¤ºä½ç½®â€”åˆ—é«˜åœ°å€ for(n=0;n&lt;128;n++)OLED_WR_Byte(OLED_GRAM[n][i],OLED_DATA); &#125; &#125;#if OLED_MODE==1 //8080å¹¶å£ //å‘SSD1306å†™å…¥ä¸€ä¸ªå­—èŠ‚ã€‚//dat:è¦å†™å…¥çš„æ•°æ®/å‘½ä»¤//cmd:æ•°æ®/å‘½ä»¤æ ‡å¿— 0,è¡¨ç¤ºå‘½ä»¤;1,è¡¨ç¤ºæ•°æ®;void OLED_WR_Byte(u8 dat,u8 cmd)&#123; DATAOUT(dat); OLED_RS=cmd; OLED_CS=0; OLED_WR=0; OLED_WR=1; OLED_CS=1; OLED_RS=1; &#125; #else//å‘SSD1306å†™å…¥ä¸€ä¸ªå­—èŠ‚ã€‚//dat:è¦å†™å…¥çš„æ•°æ®/å‘½ä»¤//cmd:æ•°æ®/å‘½ä»¤æ ‡å¿— 0,è¡¨ç¤ºå‘½ä»¤;1,è¡¨ç¤ºæ•°æ®;void OLED_WR_Byte(u8 dat,u8 cmd)&#123; u8 i; OLED_RS=cmd; //å†™å‘½ä»¤ OLED_CS=0; for(i=0;i&lt;8;i++) &#123; OLED_SCLK=0; if(dat&amp;0x80)OLED_SDIN=1; else OLED_SDIN=0; OLED_SCLK=1; dat&lt;&lt;=1; &#125; OLED_CS=1; OLED_RS=1; &#125; #endif //å¼€å¯OLEDæ˜¾ç¤º void OLED_Display_On(void)&#123; OLED_WR_Byte(0X8D,OLED_CMD); //SET DCDCå‘½ä»¤ OLED_WR_Byte(0X14,OLED_CMD); //DCDC ON OLED_WR_Byte(0XAF,OLED_CMD); //DISPLAY ON&#125;//å…³é—­OLEDæ˜¾ç¤º void OLED_Display_Off(void)&#123; OLED_WR_Byte(0X8D,OLED_CMD); //SET DCDCå‘½ä»¤ OLED_WR_Byte(0X10,OLED_CMD); //DCDC OFF OLED_WR_Byte(0XAE,OLED_CMD); //DISPLAY OFF&#125; //æ¸…å±å‡½æ•°,æ¸…å®Œå±,æ•´ä¸ªå±å¹•æ˜¯é»‘è‰²çš„!å’Œæ²¡ç‚¹äº®ä¸€æ ·!!! void OLED_Clear(void) &#123; u8 i,n; for(i=0;i&lt;8;i++)for(n=0;n&lt;128;n++)OLED_GRAM[n][i]=0X00; OLED_Refresh_Gram();//æ›´æ–°æ˜¾ç¤º&#125;//ç”»ç‚¹ //x:0~127//y:0~63//t:1 å¡«å…… 0,æ¸…ç©º void OLED_DrawPoint(u8 x,u8 y,u8 t)&#123; u8 pos,bx,temp=0; if(x&gt;127||y&gt;63)return;//è¶…å‡ºèŒƒå›´äº†. pos=7-y/8; bx=y%8; temp=1&lt;&lt;(7-bx); if(t)OLED_GRAM[x][pos]|=temp; else OLED_GRAM[x][pos]&amp;=~temp; &#125;//x1,y1,x2,y2 å¡«å……åŒºåŸŸçš„å¯¹è§’åæ ‡//ç¡®ä¿x1&lt;=x2;y1&lt;=y2 0&lt;=x1&lt;=127 0&lt;=y1&lt;=63 //dot:0,æ¸…ç©º;1,å¡«å…… void OLED_Fill(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot) &#123; u8 x,y; for(x=x1;x&lt;=x2;x++) &#123; for(y=y1;y&lt;=y2;y++)OLED_DrawPoint(x,y,dot); &#125; OLED_Refresh_Gram();//æ›´æ–°æ˜¾ç¤º&#125;//åœ¨æŒ‡å®šä½ç½®æ˜¾ç¤ºä¸€ä¸ªå­—ç¬¦,åŒ…æ‹¬éƒ¨åˆ†å­—ç¬¦//x:0~127//y:0~63//mode:0,åç™½æ˜¾ç¤º;1,æ­£å¸¸æ˜¾ç¤º //size:é€‰æ‹©å­—ä½“ 12/16/24void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 size,u8 mode)&#123; u8 temp,t,t1; u8 y0=y; u8 csize=(size/8+((size%8)?1:0))*(size/2); //å¾—åˆ°å­—ä½“ä¸€ä¸ªå­—ç¬¦å¯¹åº”ç‚¹é˜µé›†æ‰€å çš„å­—èŠ‚æ•° chr=chr-&#x27; &#x27;;//å¾—åˆ°åç§»åçš„å€¼ for(t=0;t&lt;csize;t++) &#123; if(size==12)temp=asc2_1206[chr][t]; //è°ƒç”¨1206å­—ä½“ else if(size==16)temp=asc2_1608[chr][t]; //è°ƒç”¨1608å­—ä½“ else if(size==24)temp=asc2_2412[chr][t]; //è°ƒç”¨2412å­—ä½“ else return; //æ²¡æœ‰çš„å­—åº“ for(t1=0;t1&lt;8;t1++) &#123; if(temp&amp;0x80)OLED_DrawPoint(x,y,mode); else OLED_DrawPoint(x,y,!mode); temp&lt;&lt;=1; y++; if((y-y0)==size) &#123; y=y0; x++; break; &#125; &#125; &#125; &#125;//m^nå‡½æ•°u32 mypow(u8 m,u8 n)&#123; u32 result=1; while(n--)result*=m; return result;&#125; //æ˜¾ç¤º2ä¸ªæ•°å­—//x,y :èµ·ç‚¹åæ ‡ //len :æ•°å­—çš„ä½æ•°//size:å­—ä½“å¤§å°//mode:æ¨¡å¼ 0,å¡«å……æ¨¡å¼;1,å åŠ æ¨¡å¼//num:æ•°å€¼(0~4294967295); void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size)&#123; u8 t,temp; u8 enshow=0; for(t=0;t&lt;len;t++) &#123; temp=(num/mypow(10,len-t-1))%10; if(enshow==0&amp;&amp;t&lt;(len-1)) &#123; if(temp==0) &#123; OLED_ShowChar(x+(size/2)*t,y,&#x27; &#x27;,size,1); continue; &#125;else enshow=1; &#125; OLED_ShowChar(x+(size/2)*t,y,temp+&#x27;0&#x27;,size,1); &#125;&#125; //æ˜¾ç¤ºå­—ç¬¦ä¸²//x,y:èµ·ç‚¹åæ ‡ //size:å­—ä½“å¤§å° //*p:å­—ç¬¦ä¸²èµ·å§‹åœ°å€ void OLED_ShowString(u8 x,u8 y,const u8 *p,u8 size)&#123; while((*p&lt;=&#x27;~&#x27;)&amp;&amp;(*p&gt;=&#x27; &#x27;))//åˆ¤æ–­æ˜¯ä¸æ˜¯éæ³•å­—ç¬¦! &#123; if(x&gt;(128-(size/2)))&#123;x=0;y+=size;&#125; if(y&gt;(64-size))&#123;y=x=0;OLED_Clear();&#125; OLED_ShowChar(x,y,*p,size,1); x+=size/2; p++; &#125; &#125; //åˆå§‹åŒ–SSD1306 void OLED_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOG, ENABLE); //ä½¿èƒ½PC,D,Gç«¯å£æ—¶é’Ÿ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_6; //PD3,PD6æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//é€Ÿåº¦50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); //åˆå§‹åŒ–GPIOD3,6 GPIO_SetBits(GPIOD,GPIO_Pin_3|GPIO_Pin_6); //PD3,PD6 è¾“å‡ºé«˜ #if OLED_MODE==1 GPIO_InitStructure.GPIO_Pin =0xFF; //PC0~7 OUTæ¨æŒ½è¾“å‡º GPIO_Init(GPIOC, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOC,0xFF); //PC0~7è¾“å‡ºé«˜ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15; //PG13,14,15 OUTæ¨æŒ½è¾“å‡º GPIO_Init(GPIOG, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOG,GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15); //PG13,14,15 OUT è¾“å‡ºé«˜ #else GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1; //PC0,1 OUTæ¨æŒ½è¾“å‡º GPIO_Init(GPIOC, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOC,GPIO_Pin_0|GPIO_Pin_1); //PC0,1 OUT è¾“å‡ºé«˜ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15; //PG15 OUTæ¨æŒ½è¾“å‡º RST GPIO_Init(GPIOG, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOG,GPIO_Pin_15); //PG15 OUT è¾“å‡ºé«˜ #endif OLED_CS=1; OLED_RS=1; OLED_RST=0; delay_ms(100); OLED_RST=1; OLED_WR_Byte(0xAE,OLED_CMD); //å…³é—­æ˜¾ç¤º OLED_WR_Byte(0xD5,OLED_CMD); //è®¾ç½®æ—¶é’Ÿåˆ†é¢‘å› å­,éœ‡è¡é¢‘ç‡ OLED_WR_Byte(80,OLED_CMD); //[3:0],åˆ†é¢‘å› å­;[7:4],éœ‡è¡é¢‘ç‡ OLED_WR_Byte(0xA8,OLED_CMD); //è®¾ç½®é©±åŠ¨è·¯æ•° OLED_WR_Byte(0X3F,OLED_CMD); //é»˜è®¤0X3F(1/64) OLED_WR_Byte(0xD3,OLED_CMD); //è®¾ç½®æ˜¾ç¤ºåç§» OLED_WR_Byte(0X00,OLED_CMD); //é»˜è®¤ä¸º0 OLED_WR_Byte(0x40,OLED_CMD); //è®¾ç½®æ˜¾ç¤ºå¼€å§‹è¡Œ [5:0],è¡Œæ•°. OLED_WR_Byte(0x8D,OLED_CMD); //ç”µè·æ³µè®¾ç½® OLED_WR_Byte(0x14,OLED_CMD); //bit2ï¼Œå¼€å¯/å…³é—­ OLED_WR_Byte(0x20,OLED_CMD); //è®¾ç½®å†…å­˜åœ°å€æ¨¡å¼ OLED_WR_Byte(0x02,OLED_CMD); //[1:0],00ï¼Œåˆ—åœ°å€æ¨¡å¼;01ï¼Œè¡Œåœ°å€æ¨¡å¼;10,é¡µåœ°å€æ¨¡å¼;é»˜è®¤10; OLED_WR_Byte(0xA1,OLED_CMD); //æ®µé‡å®šä¹‰è®¾ç½®,bit0:0,0-&gt;0;1,0-&gt;127; OLED_WR_Byte(0xC0,OLED_CMD); //è®¾ç½®COMæ‰«ææ–¹å‘;bit3:0,æ™®é€šæ¨¡å¼;1,é‡å®šä¹‰æ¨¡å¼ COM[N-1]-&gt;COM0;N:é©±åŠ¨è·¯æ•° OLED_WR_Byte(0xDA,OLED_CMD); //è®¾ç½®COMç¡¬ä»¶å¼•è„šé…ç½® OLED_WR_Byte(0x12,OLED_CMD); //[5:4]é…ç½® OLED_WR_Byte(0x81,OLED_CMD); //å¯¹æ¯”åº¦è®¾ç½® OLED_WR_Byte(0xEF,OLED_CMD); //1~255;é»˜è®¤0X7F (äº®åº¦è®¾ç½®,è¶Šå¤§è¶Šäº®) OLED_WR_Byte(0xD9,OLED_CMD); //è®¾ç½®é¢„å……ç”µå‘¨æœŸ OLED_WR_Byte(0xf1,OLED_CMD); //[3:0],PHASE 1;[7:4],PHASE 2; OLED_WR_Byte(0xDB,OLED_CMD); //è®¾ç½®VCOMH ç”µå‹å€ç‡ OLED_WR_Byte(0x30,OLED_CMD); //[6:4] 000,0.65*vcc;001,0.77*vcc;011,0.83*vcc; OLED_WR_Byte(0xA4,OLED_CMD); //å…¨å±€æ˜¾ç¤ºå¼€å¯;bit0:1,å¼€å¯;0,å…³é—­;(ç™½å±/é»‘å±) OLED_WR_Byte(0xA6,OLED_CMD); //è®¾ç½®æ˜¾ç¤ºæ–¹å¼;bit0:1,åç›¸æ˜¾ç¤º;0,æ­£å¸¸æ˜¾ç¤º OLED_WR_Byte(0xAF,OLED_CMD); //å¼€å¯æ˜¾ç¤º OLED_Clear();&#125; /******************* END OF FILE *********/ oled.h 12345678910111213141516171819202122232425262728293031323334353637383940414243// oled.h#ifndef __OLED_H#define __OLED_H #include &quot;sys.h&quot;#include &quot;stdlib.h&quot; //OLEDæ¨¡å¼è®¾ç½®//0: 4çº¿ä¸²è¡Œæ¨¡å¼ ï¼ˆæ¨¡å—çš„BS1ï¼ŒBS2å‡æ¥GNDï¼‰//1: å¹¶è¡Œ8080æ¨¡å¼ ï¼ˆæ¨¡å—çš„BS1ï¼ŒBS2å‡æ¥VCCï¼‰#define OLED_MODE 1 //---------------------------OLEDç«¯å£å®šä¹‰-------------------------- #define OLED_CS PDout(6)#define OLED_RST PGout(15) #define OLED_RS PDout(3)#define OLED_WR PGout(14) #define OLED_RD PGout(13) //PC0~7,ä½œä¸ºæ•°æ®çº¿ #define DATAOUT(x) GPIO_Write(GPIOC,x);//è¾“å‡º //ä½¿ç”¨4çº¿ä¸²è¡Œæ¥å£æ—¶ä½¿ç”¨ #define OLED_SCLK PCout(0)#define OLED_SDIN PCout(1) #define OLED_CMD 0 //å†™å‘½ä»¤#define OLED_DATA 1 //å†™æ•°æ®//OLEDæ§åˆ¶ç”¨å‡½æ•°void OLED_WR_Byte(u8 dat,u8 cmd); void OLED_Display_On(void);void OLED_Display_Off(void);void OLED_Refresh_Gram(void); void OLED_Init(void);void OLED_Clear(void);void OLED_DrawPoint(u8 x,u8 y,u8 t);void OLED_Fill(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot);void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 size,u8 mode);void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size);void OLED_ShowString(u8 x,u8 y,const u8 *p,u8 size); #endif /******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627282930313233343536//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;oled.h&quot; int main(void) &#123; u8 t; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ LED_Init(); //LEDç«¯å£åˆå§‹åŒ– OLED_Init(); //åˆå§‹åŒ–OLED OLED_ShowString(0,0,&quot;ALIENTEK&quot;,24); OLED_ShowString(0,24, &quot;0.96&#x27; OLED TEST&quot;,16); OLED_ShowString(0,40,&quot;ATOM 2015/1/14&quot;,12); OLED_ShowString(0,52,&quot;ASCII:&quot;,12); OLED_ShowString(64,52,&quot;CODE:&quot;,12); OLED_Refresh_Gram(); //æ›´æ–°æ˜¾ç¤ºåˆ°OLED t=&#x27; &#x27;; while(1) &#123; OLED_ShowChar(48,48,t,16,1);//æ˜¾ç¤ºASCIIå­—ç¬¦ OLED_Refresh_Gram(); t++; if(t&gt;&#x27;~&#x27;)t=&#x27; &#x27;; OLED_ShowNum(103,48,t,3,16);//æ˜¾ç¤ºASCIIå­—ç¬¦çš„ç å€¼ delay_ms(500); LED0=!LED0; &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ11ï¼‰è§¦æ‘¸æŒ‰é”®","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-011","date":"2022-11-08T02:39:18.000Z","updated":"2023-04-05T14:19:36.208Z","comments":true,"path":"posts/2323345083.html","link":"","permalink":"https://sirius-tblog.github.io/posts/2323345083.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ tpad.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// tpad.c#include &quot;tpad.h&quot;#include &quot;delay.h&quot; #include &quot;usart.h&quot;#define TPAD_ARR_MAX_VAL 0XFFFF //æœ€å¤§çš„ARRå€¼vu16 tpad_default_val=0;//ç©ºè½½çš„æ—¶å€™(æ²¡æœ‰æ‰‹æŒ‰ä¸‹),è®¡æ•°å™¨éœ€è¦çš„æ—¶é—´//åˆå§‹åŒ–è§¦æ‘¸æŒ‰é”®//è·å¾—ç©ºè½½çš„æ—¶å€™è§¦æ‘¸æŒ‰é”®çš„å–å€¼.//è¿”å›å€¼:0,åˆå§‹åŒ–æˆåŠŸ;1,åˆå§‹åŒ–å¤±è´¥u8 TPAD_Init(u8 psc)&#123; u16 buf[10]; u16 temp; u8 j,i; TIM5_CH2_Cap_Init(TPAD_ARR_MAX_VAL,psc-1);//ä»¥1Mhzçš„é¢‘ç‡è®¡æ•° for(i=0;i&lt;10;i++)//è¿ç»­è¯»å–10æ¬¡ &#123; buf[i]=TPAD_Get_Val(); delay_ms(10); &#125; for(i=0;i&lt;9;i++)//æ’åº &#123; for(j=i+1;j&lt;10;j++) &#123; if(buf[i]&gt;buf[j])//å‡åºæ’åˆ— &#123; temp=buf[i]; buf[i]=buf[j]; buf[j]=temp; &#125; &#125; &#125; temp=0; for(i=2;i&lt;8;i++)temp+=buf[i];//å–ä¸­é—´çš„6ä¸ªæ•°æ®è¿›è¡Œå¹³å‡ tpad_default_val=temp/6; printf(&quot;tpad_default_val:%d\\r\\n&quot;,tpad_default_val); if(tpad_default_val&gt;TPAD_ARR_MAX_VAL/2)return 1;//åˆå§‹åŒ–é‡åˆ°è¶…è¿‡TPAD_ARR_MAX_VAL/2çš„æ•°å€¼,ä¸æ­£å¸¸! return 0; &#125;//å¤ä½ä¸€æ¬¡void TPAD_Reset(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //ä½¿èƒ½PAç«¯å£æ—¶é’Ÿ //è®¾ç½®GPIOA.1ä¸ºæ¨æŒ½ä½¿å‡º GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; //PA1 ç«¯å£é…ç½® GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_ResetBits(GPIOA,GPIO_Pin_1); //PA.1è¾“å‡º0,æ”¾ç”µ delay_ms(5); TIM_SetCounter(TIM5,0); //å½’0 TIM_ClearITPendingBit(TIM5, TIM_IT_CC2|TIM_IT_Update); //æ¸…é™¤ä¸­æ–­æ ‡å¿— //è®¾ç½®GPIOA.1ä¸ºæµ®ç©ºè¾“å…¥ GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING; //æµ®ç©ºè¾“å…¥ GPIO_Init(GPIOA, &amp;GPIO_InitStructure); &#125;//å¾—åˆ°å®šæ—¶å™¨æ•è·å€¼//å¦‚æœè¶…æ—¶,åˆ™ç›´æ¥è¿”å›å®šæ—¶å™¨çš„è®¡æ•°å€¼.u16 TPAD_Get_Val(void)&#123; TPAD_Reset(); while(TIM_GetFlagStatus(TIM5, TIM_IT_CC2) == RESET)//ç­‰å¾…æ•è·ä¸Šå‡æ²¿ &#123; if(TIM_GetCounter(TIM5)&gt;TPAD_ARR_MAX_VAL-500)return TIM_GetCounter(TIM5);//è¶…æ—¶äº†,ç›´æ¥è¿”å›CNTçš„å€¼ &#125;; return TIM_GetCapture2(TIM5); &#125; //è¯»å–næ¬¡,å–æœ€å¤§å€¼//nï¼šè¿ç»­è·å–çš„æ¬¡æ•°//è¿”å›å€¼ï¼šnæ¬¡è¯»æ•°é‡Œé¢è¯»åˆ°çš„æœ€å¤§è¯»æ•°å€¼u16 TPAD_Get_MaxVal(u8 n)&#123; u16 temp=0; u16 res=0; while(n--) &#123; temp=TPAD_Get_Val();//å¾—åˆ°ä¸€æ¬¡å€¼ if(temp&gt;res)res=temp; &#125;; return res;&#125; //æ‰«æè§¦æ‘¸æŒ‰é”®//mode:0,ä¸æ”¯æŒè¿ç»­è§¦å‘(æŒ‰ä¸‹ä¸€æ¬¡å¿…é¡»æ¾å¼€æ‰èƒ½æŒ‰ä¸‹ä¸€æ¬¡);1,æ”¯æŒè¿ç»­è§¦å‘(å¯ä»¥ä¸€ç›´æŒ‰ä¸‹)//è¿”å›å€¼:0,æ²¡æœ‰æŒ‰ä¸‹;1,æœ‰æŒ‰ä¸‹; #define TPAD_GATE_VAL 100 //è§¦æ‘¸çš„é—¨é™å€¼,ä¹Ÿå°±æ˜¯å¿…é¡»å¤§äºtpad_default_val+TPAD_GATE_VAL,æ‰è®¤ä¸ºæ˜¯æœ‰æ•ˆè§¦æ‘¸.u8 TPAD_Scan(u8 mode)&#123; static u8 keyen=0; //0,å¯ä»¥å¼€å§‹æ£€æµ‹;&gt;0,è¿˜ä¸èƒ½å¼€å§‹æ£€æµ‹ u8 res=0; u8 sample=3; //é»˜è®¤é‡‡æ ·æ¬¡æ•°ä¸º3æ¬¡ u16 rval; if(mode) &#123; sample=6; //æ”¯æŒè¿æŒ‰çš„æ—¶å€™ï¼Œè®¾ç½®é‡‡æ ·æ¬¡æ•°ä¸º6æ¬¡ keyen=0; //æ”¯æŒè¿æŒ‰ &#125; rval=TPAD_Get_MaxVal(sample); if(rval&gt;(tpad_default_val+TPAD_GATE_VAL))//å¤§äºtpad_default_val+TPAD_GATE_VAL,æœ‰æ•ˆ &#123; if(keyen==0)res=1; //keyen==0,æœ‰æ•ˆ //printf(&quot;r:%d\\r\\n&quot;,rval); keyen=3; //è‡³å°‘è¦å†è¿‡3æ¬¡ä¹‹åæ‰èƒ½æŒ‰é”®æœ‰æ•ˆ &#125; if(keyen)keyen--; return res;&#125; //å®šæ—¶å™¨2é€šé“2è¾“å…¥æ•è·é…ç½®void TIM5_CH2_Cap_Init(u16 arr,u16 psc)&#123; GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_ICInitTypeDef TIM5_ICInitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); //ä½¿èƒ½TIM5æ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //ä½¿èƒ½PAç«¯å£æ—¶é’Ÿ //è®¾ç½®GPIOA.1ä¸ºæµ®ç©ºè¾“å…¥ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; //PA1 ç«¯å£é…ç½® GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //é€Ÿåº¦50MHz GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING; //æµ®ç©ºè¾“å…¥ GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //è®¾ç½®ä¸ºæµ®ç©ºè¾“å…¥ //åˆå§‹åŒ–TIM5 TIM_TimeBaseStructure.TIM_Period = arr; //è®¾å®šè®¡æ•°å™¨è‡ªåŠ¨é‡è£…å€¼ TIM_TimeBaseStructure.TIM_Prescaler =psc; //é¢„åˆ†é¢‘å™¨ TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //è®¾ç½®æ—¶é’Ÿåˆ†å‰²:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIMå‘ä¸Šè®¡æ•°æ¨¡å¼ TIM_TimeBaseInit(TIM5, &amp;TIM_TimeBaseStructure); //æ ¹æ®TIM_TimeBaseInitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–TIMxçš„æ—¶é—´åŸºæ•°å•ä½ //åˆå§‹åŒ–é€šé“2 TIM5_ICInitStructure.TIM_Channel = TIM_Channel_2; //CC1S=01 é€‰æ‹©è¾“å…¥ç«¯ IC2æ˜ å°„åˆ°TI5ä¸Š TIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; //ä¸Šå‡æ²¿æ•è· TIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; TIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; //é…ç½®è¾“å…¥åˆ†é¢‘,ä¸åˆ†é¢‘ TIM5_ICInitStructure.TIM_ICFilter = 0x03;//IC2F=0011 é…ç½®è¾“å…¥æ»¤æ³¢å™¨ 8ä¸ªå®šæ—¶å™¨æ—¶é’Ÿå‘¨æœŸæ»¤æ³¢ TIM_ICInit(TIM5, &amp;TIM5_ICInitStructure);//åˆå§‹åŒ–I5 IC2 TIM_Cmd(TIM5,ENABLE ); //ä½¿èƒ½å®šæ—¶å™¨5&#125;/******************* END OF FILE *********/ tpad.h 12345678910111213141516// tpad.h#ifndef __TPAD_H#define __TPAD_H#include &quot;sys.h&quot; extern vu16 tpad_default_val; void TPAD_Reset(void);u16 TPAD_Get_Val(void);u16 TPAD_Get_MaxVal(u8 n);u8 TPAD_Init(u8 psc);u8 TPAD_Scan(u8 mode);void TIM5_CH2_Cap_Init(u16 arr,u16 psc); #endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;tpad.h&quot; int main(void) &#123; u8 t=0; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //LEDç«¯å£åˆå§‹åŒ– TPAD_Init(6); //åˆå§‹åŒ–è§¦æ‘¸æŒ‰é”® while(1) &#123; if(TPAD_Scan(0)) //æˆåŠŸæ•è·åˆ°äº†ä¸€æ¬¡ä¸Šå‡æ²¿(æ­¤å‡½æ•°æ‰§è¡Œæ—¶é—´è‡³å°‘15ms) &#123; LED1=!LED1; //LED1å–å &#125; t++; if(t==15) &#123; t=0; LED0=!LED0; //LED0å–å,æç¤ºç¨‹åºæ­£åœ¨è¿è¡Œ &#125; delay_ms(10); &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ10ï¼‰è¾“å…¥æ•è·","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-010","date":"2022-11-08T02:19:18.000Z","updated":"2023-04-05T14:19:19.975Z","comments":true,"path":"posts/1244416953.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1244416953.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ timer.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191// timer.c#include &quot;timer.h&quot;#include &quot;led.h&quot;#include &quot;usart.h&quot;//é€šç”¨å®šæ—¶å™¨ä¸­æ–­åˆå§‹åŒ–//è¿™é‡Œæ—¶é’Ÿé€‰æ‹©ä¸ºAPB1çš„2å€ï¼Œè€ŒAPB1ä¸º36M//arrï¼šè‡ªåŠ¨é‡è£…å€¼ã€‚//pscï¼šæ—¶é’Ÿé¢„åˆ†é¢‘æ•°//è¿™é‡Œä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3!void TIM3_Int_Init(u16 arr,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //æ—¶é’Ÿä½¿èƒ½ TIM_TimeBaseStructure.TIM_Period = arr; //è®¾ç½®åœ¨ä¸‹ä¸€ä¸ªæ›´æ–°äº‹ä»¶è£…å…¥æ´»åŠ¨çš„è‡ªåŠ¨é‡è£…è½½å¯„å­˜å™¨å‘¨æœŸçš„å€¼ è®¡æ•°åˆ°5000ä¸º500ms TIM_TimeBaseStructure.TIM_Prescaler =psc; //è®¾ç½®ç”¨æ¥ä½œä¸ºTIMxæ—¶é’Ÿé¢‘ç‡é™¤æ•°çš„é¢„åˆ†é¢‘å€¼ 10Khzçš„è®¡æ•°é¢‘ç‡ TIM_TimeBaseStructure.TIM_ClockDivision = 0; //è®¾ç½®æ—¶é’Ÿåˆ†å‰²:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIMå‘ä¸Šè®¡æ•°æ¨¡å¼ TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //æ ¹æ®TIM_TimeBaseInitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–TIMxçš„æ—¶é—´åŸºæ•°å•ä½ TIM_ITConfig( //ä½¿èƒ½æˆ–è€…å¤±èƒ½æŒ‡å®šçš„TIMä¸­æ–­ TIM3, //TIM2 TIM_IT_Update | //TIM ä¸­æ–­æº TIM_IT_Trigger, //TIM è§¦å‘ä¸­æ–­æº ENABLE //ä½¿èƒ½ ); NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; //TIM3ä¸­æ–­ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //å…ˆå ä¼˜å…ˆçº§0çº§ NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //ä»ä¼˜å…ˆçº§3çº§ NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQé€šé“è¢«ä½¿èƒ½ NVIC_Init(&amp;NVIC_InitStructure); //æ ¹æ®NVIC_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾NVICå¯„å­˜å™¨ TIM_Cmd(TIM3, ENABLE); //ä½¿èƒ½TIMxå¤–è®¾ &#125;void TIM3_IRQHandler(void) //TIM3ä¸­æ–­&#123; if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //æ£€æŸ¥æŒ‡å®šçš„TIMä¸­æ–­å‘ç”Ÿä¸å¦:TIM ä¸­æ–­æº &#123; TIM_ClearITPendingBit(TIM3, TIM_IT_Update ); //æ¸…é™¤TIMxçš„ä¸­æ–­å¾…å¤„ç†ä½:TIM ä¸­æ–­æº LED1=!LED1; &#125;&#125;//PWMè¾“å‡ºåˆå§‹åŒ–//arrï¼šè‡ªåŠ¨é‡è£…å€¼//pscï¼šæ—¶é’Ÿé¢„åˆ†é¢‘æ•°void TIM3_PWM_Init(u16 arr,u16 psc)&#123; GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE); //ä½¿èƒ½GPIOå¤–è®¾å’ŒAFIOå¤ç”¨åŠŸèƒ½æ¨¡å—æ—¶é’Ÿä½¿èƒ½ GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); //Timer3éƒ¨åˆ†é‡æ˜ å°„ TIM3_CH2-&gt;PB5 //ç”¨äºTIM3çš„CH2è¾“å‡ºçš„PWMé€šè¿‡è¯¥LEDæ˜¾ç¤º //è®¾ç½®è¯¥å¼•è„šä¸ºå¤ç”¨è¾“å‡ºåŠŸèƒ½,è¾“å‡ºTIM3 CH2çš„PWMè„‰å†²æ³¢å½¢ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //TIM_CH2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //å¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //GPIO_WriteBit(GPIOA, GPIO_Pin_7,Bit_SET); // PA7ä¸Šæ‹‰ TIM_TimeBaseStructure.TIM_Period = arr; //è®¾ç½®åœ¨ä¸‹ä¸€ä¸ªæ›´æ–°äº‹ä»¶è£…å…¥æ´»åŠ¨çš„è‡ªåŠ¨é‡è£…è½½å¯„å­˜å™¨å‘¨æœŸçš„å€¼ 80K TIM_TimeBaseStructure.TIM_Prescaler =psc; //è®¾ç½®ç”¨æ¥ä½œä¸ºTIMxæ—¶é’Ÿé¢‘ç‡é™¤æ•°çš„é¢„åˆ†é¢‘å€¼ ä¸åˆ†é¢‘ TIM_TimeBaseStructure.TIM_ClockDivision = 0; //è®¾ç½®æ—¶é’Ÿåˆ†å‰²:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIMå‘ä¸Šè®¡æ•°æ¨¡å¼ TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //æ ¹æ®TIM_TimeBaseInitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–TIMxçš„æ—¶é—´åŸºæ•°å•ä½ TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //é€‰æ‹©å®šæ—¶å™¨æ¨¡å¼:TIMè„‰å†²å®½åº¦è°ƒåˆ¶æ¨¡å¼2 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //æ¯”è¾ƒè¾“å‡ºä½¿èƒ½ TIM_OCInitStructure.TIM_Pulse = 0; //è®¾ç½®å¾…è£…å…¥æ•è·æ¯”è¾ƒå¯„å­˜å™¨çš„è„‰å†²å€¼ TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //è¾“å‡ºææ€§:TIMè¾“å‡ºæ¯”è¾ƒææ€§é«˜ TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure); //æ ¹æ®TIM_OCInitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾TIMx TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); //ä½¿èƒ½TIMxåœ¨CCR2ä¸Šçš„é¢„è£…è½½å¯„å­˜å™¨ TIM_ARRPreloadConfig(TIM3, ENABLE); //ä½¿èƒ½TIMxåœ¨ARRä¸Šçš„é¢„è£…è½½å¯„å­˜å™¨ TIM_Cmd(TIM3, ENABLE); //ä½¿èƒ½TIMxå¤–è®¾ &#125;//å®šæ—¶å™¨5é€šé“1è¾“å…¥æ•è·é…ç½®TIM_ICInitTypeDef TIM5_ICInitStructure;void TIM5_Cap_Init(u16 arr,u16 psc)&#123; GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); //ä½¿èƒ½TIM5æ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //ä½¿èƒ½GPIOAæ—¶é’Ÿ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //PA0 æ¸…é™¤ä¹‹å‰è®¾ç½® GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0 è¾“å…¥ GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_ResetBits(GPIOA,GPIO_Pin_0); //PA0 ä¸‹æ‹‰ //åˆå§‹åŒ–å®šæ—¶å™¨5 TIM5 TIM_TimeBaseStructure.TIM_Period = arr; //è®¾å®šè®¡æ•°å™¨è‡ªåŠ¨é‡è£…å€¼ TIM_TimeBaseStructure.TIM_Prescaler =psc; //é¢„åˆ†é¢‘å™¨ TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //è®¾ç½®æ—¶é’Ÿåˆ†å‰²:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIMå‘ä¸Šè®¡æ•°æ¨¡å¼ TIM_TimeBaseInit(TIM5, &amp;TIM_TimeBaseStructure); //æ ¹æ®TIM_TimeBaseInitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–TIMxçš„æ—¶é—´åŸºæ•°å•ä½ //åˆå§‹åŒ–TIM5è¾“å…¥æ•è·å‚æ•° TIM5_ICInitStructure.TIM_Channel = TIM_Channel_1; //CC1S=01 é€‰æ‹©è¾“å…¥ç«¯ IC1æ˜ å°„åˆ°TI1ä¸Š TIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; //ä¸Šå‡æ²¿æ•è· TIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //æ˜ å°„åˆ°TI1ä¸Š TIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; //é…ç½®è¾“å…¥åˆ†é¢‘,ä¸åˆ†é¢‘ TIM5_ICInitStructure.TIM_ICFilter = 0x00;//IC1F=0000 é…ç½®è¾“å…¥æ»¤æ³¢å™¨ ä¸æ»¤æ³¢ TIM_ICInit(TIM5, &amp;TIM5_ICInitStructure); //ä¸­æ–­åˆ†ç»„åˆå§‹åŒ– NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn; //TIM3ä¸­æ–­ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; //å…ˆå ä¼˜å…ˆçº§2çº§ NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; //ä»ä¼˜å…ˆçº§0çº§ NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQé€šé“è¢«ä½¿èƒ½ NVIC_Init(&amp;NVIC_InitStructure); //æ ¹æ®NVIC_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾NVICå¯„å­˜å™¨ TIM_ITConfig(TIM5,TIM_IT_Update|TIM_IT_CC1,ENABLE);//å…è®¸æ›´æ–°ä¸­æ–­ ,å…è®¸CC1IEæ•è·ä¸­æ–­ TIM_Cmd(TIM5,ENABLE ); //ä½¿èƒ½å®šæ—¶å™¨5 &#125;u8 TIM5CH1_CAPTURE_STA=0; //è¾“å…¥æ•è·çŠ¶æ€ u16 TIM5CH1_CAPTURE_VAL; //è¾“å…¥æ•è·å€¼ //å®šæ—¶å™¨5ä¸­æ–­æœåŠ¡ç¨‹åº void TIM5_IRQHandler(void)&#123; if((TIM5CH1_CAPTURE_STA&amp;0X80)==0)//è¿˜æœªæˆåŠŸæ•è· &#123; if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET) &#123; if(TIM5CH1_CAPTURE_STA&amp;0X40)//å·²ç»æ•è·åˆ°é«˜ç”µå¹³äº† &#123; if((TIM5CH1_CAPTURE_STA&amp;0X3F)==0X3F)//é«˜ç”µå¹³å¤ªé•¿äº† &#123; TIM5CH1_CAPTURE_STA|=0X80;//æ ‡è®°æˆåŠŸæ•è·äº†ä¸€æ¬¡ TIM5CH1_CAPTURE_VAL=0XFFFF; &#125;else TIM5CH1_CAPTURE_STA++; &#125; &#125; if (TIM_GetITStatus(TIM5, TIM_IT_CC1) != RESET)//æ•è·1å‘ç”Ÿæ•è·äº‹ä»¶ &#123; if(TIM5CH1_CAPTURE_STA&amp;0X40) //æ•è·åˆ°ä¸€ä¸ªä¸‹é™æ²¿ &#123; TIM5CH1_CAPTURE_STA|=0X80; //æ ‡è®°æˆåŠŸæ•è·åˆ°ä¸€æ¬¡ä¸Šå‡æ²¿ TIM5CH1_CAPTURE_VAL=TIM_GetCapture1(TIM5); TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Rising); //CC1P=0 è®¾ç½®ä¸ºä¸Šå‡æ²¿æ•è· &#125;else //è¿˜æœªå¼€å§‹,ç¬¬ä¸€æ¬¡æ•è·ä¸Šå‡æ²¿ &#123; TIM5CH1_CAPTURE_STA=0; //æ¸…ç©º TIM5CH1_CAPTURE_VAL=0; TIM_SetCounter(TIM5,0); TIM5CH1_CAPTURE_STA|=0X40; //æ ‡è®°æ•è·åˆ°äº†ä¸Šå‡æ²¿ TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Falling); //CC1P=1 è®¾ç½®ä¸ºä¸‹é™æ²¿æ•è· &#125; &#125; &#125; TIM_ClearITPendingBit(TIM5, TIM_IT_CC1|TIM_IT_Update); //æ¸…é™¤ä¸­æ–­æ ‡å¿—ä½ &#125;/******************* END OF FILE *********/ timer.h 1234567891011// timer.h#ifndef __TIMER_H#define __TIMER_H#include &quot;sys.h&quot;void TIM3_Int_Init(u16 arr,u16 psc);void TIM3_PWM_Init(u16 arr,u16 psc);void TIM5_Cap_Init(u16 arr,u16 psc);#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334353637383940//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;timer.h&quot;extern u8 TIM5CH1_CAPTURE_STA; //è¾“å…¥æ•è·çŠ¶æ€ extern u16 TIM5CH1_CAPTURE_VAL; //è¾“å…¥æ•è·å€¼ int main(void) &#123; u32 temp=0; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //LEDç«¯å£åˆå§‹åŒ– TIM3_PWM_Init(899,0); //ä¸åˆ†é¢‘ã€‚PWMé¢‘ç‡=72000/(899+1)=80Khz TIM5_Cap_Init(0XFFFF,72-1); //ä»¥1Mhzçš„é¢‘ç‡è®¡æ•° while(1) &#123; delay_ms(10); TIM_SetCompare2(TIM3,TIM_GetCapture2(TIM3)+1); if(TIM_GetCapture2(TIM3)==300)TIM_SetCompare2(TIM3,0); if(TIM5CH1_CAPTURE_STA&amp;0X80)//æˆåŠŸæ•è·åˆ°äº†ä¸€æ¬¡ä¸Šå‡æ²¿ &#123; temp=TIM5CH1_CAPTURE_STA&amp;0X3F; temp*=65536;//æº¢å‡ºæ—¶é—´æ€»å’Œ temp+=TIM5CH1_CAPTURE_VAL;//å¾—åˆ°æ€»çš„é«˜ç”µå¹³æ—¶é—´ printf(&quot;HIGH:%d us\\r\\n&quot;,temp);//æ‰“å°æ€»çš„é«˜ç‚¹å¹³æ—¶é—´ TIM5CH1_CAPTURE_STA=0;//å¼€å¯ä¸‹ä¸€æ¬¡æ•è· &#125; &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ9ï¼‰PWMè¾“å‡º","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-009","date":"2022-11-08T01:59:18.000Z","updated":"2023-04-05T14:19:11.394Z","comments":true,"path":"posts/1529114485.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1529114485.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ timer.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// timer.c#include &quot;timer.h&quot;#include &quot;led.h&quot;#include &quot;usart.h&quot; //é€šç”¨å®šæ—¶å™¨3ä¸­æ–­åˆå§‹åŒ–//è¿™é‡Œæ—¶é’Ÿé€‰æ‹©ä¸ºAPB1çš„2å€ï¼Œè€ŒAPB1ä¸º36M//arrï¼šè‡ªåŠ¨é‡è£…å€¼ã€‚//pscï¼šæ—¶é’Ÿé¢„åˆ†é¢‘æ•°//è¿™é‡Œä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3!void TIM3_Int_Init(u16 arr,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //æ—¶é’Ÿä½¿èƒ½ TIM_TimeBaseStructure.TIM_Period = arr; //è®¾ç½®åœ¨ä¸‹ä¸€ä¸ªæ›´æ–°äº‹ä»¶è£…å…¥æ´»åŠ¨çš„è‡ªåŠ¨é‡è£…è½½å¯„å­˜å™¨å‘¨æœŸçš„å€¼ è®¡æ•°åˆ°5000ä¸º500ms TIM_TimeBaseStructure.TIM_Prescaler =psc; //è®¾ç½®ç”¨æ¥ä½œä¸ºTIMxæ—¶é’Ÿé¢‘ç‡é™¤æ•°çš„é¢„åˆ†é¢‘å€¼ 10Khzçš„è®¡æ•°é¢‘ç‡ TIM_TimeBaseStructure.TIM_ClockDivision = 0; //è®¾ç½®æ—¶é’Ÿåˆ†å‰²:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIMå‘ä¸Šè®¡æ•°æ¨¡å¼ TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //æ ¹æ®TIM_TimeBaseInitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–TIMxçš„æ—¶é—´åŸºæ•°å•ä½ TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE ); //ä½¿èƒ½æŒ‡å®šçš„TIM3ä¸­æ–­,å…è®¸æ›´æ–°ä¸­æ–­ NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; //TIM3ä¸­æ–­ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //å…ˆå ä¼˜å…ˆçº§0çº§ NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //ä»ä¼˜å…ˆçº§3çº§ NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQé€šé“è¢«ä½¿èƒ½ NVIC_Init(&amp;NVIC_InitStructure); //æ ¹æ®NVIC_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾NVICå¯„å­˜å™¨ TIM_Cmd(TIM3, ENABLE); //ä½¿èƒ½TIMxå¤–è®¾ &#125;//å®šæ—¶å™¨3ä¸­æ–­æœåŠ¡ç¨‹åºvoid TIM3_IRQHandler(void) //TIM3ä¸­æ–­&#123; if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //æ£€æŸ¥æŒ‡å®šçš„TIMä¸­æ–­å‘ç”Ÿä¸å¦:TIM ä¸­æ–­æº &#123; TIM_ClearITPendingBit(TIM3, TIM_IT_Update ); //æ¸…é™¤TIMxçš„ä¸­æ–­å¾…å¤„ç†ä½:TIM ä¸­æ–­æº LED1=!LED1; &#125;&#125;//TIM3 PWMéƒ¨åˆ†åˆå§‹åŒ– //PWMè¾“å‡ºåˆå§‹åŒ–//arrï¼šè‡ªåŠ¨é‡è£…å€¼//pscï¼šæ—¶é’Ÿé¢„åˆ†é¢‘æ•°void TIM3_PWM_Init(u16 arr,u16 psc)&#123; GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //ä½¿èƒ½å®šæ—¶å™¨3æ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE); //ä½¿èƒ½GPIOå¤–è®¾å’ŒAFIOå¤ç”¨åŠŸèƒ½æ¨¡å—æ—¶é’Ÿ GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); //Timer3éƒ¨åˆ†é‡æ˜ å°„ TIM3_CH2-&gt;PB5 //è®¾ç½®è¯¥å¼•è„šä¸ºå¤ç”¨è¾“å‡ºåŠŸèƒ½,è¾“å‡ºTIM3 CH2çš„PWMè„‰å†²æ³¢å½¢ GPIOB.5 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //TIM_CH2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //å¤ç”¨æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure);//åˆå§‹åŒ–GPIO //åˆå§‹åŒ–TIM3 TIM_TimeBaseStructure.TIM_Period = arr; //è®¾ç½®åœ¨ä¸‹ä¸€ä¸ªæ›´æ–°äº‹ä»¶è£…å…¥æ´»åŠ¨çš„è‡ªåŠ¨é‡è£…è½½å¯„å­˜å™¨å‘¨æœŸçš„å€¼ TIM_TimeBaseStructure.TIM_Prescaler =psc; //è®¾ç½®ç”¨æ¥ä½œä¸ºTIMxæ—¶é’Ÿé¢‘ç‡é™¤æ•°çš„é¢„åˆ†é¢‘å€¼ TIM_TimeBaseStructure.TIM_ClockDivision = 0; //è®¾ç½®æ—¶é’Ÿåˆ†å‰²:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIMå‘ä¸Šè®¡æ•°æ¨¡å¼ TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //æ ¹æ®TIM_TimeBaseInitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–TIMxçš„æ—¶é—´åŸºæ•°å•ä½ //åˆå§‹åŒ–TIM3 Channel2 PWMæ¨¡å¼ TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //é€‰æ‹©å®šæ—¶å™¨æ¨¡å¼:TIMè„‰å†²å®½åº¦è°ƒåˆ¶æ¨¡å¼2 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //æ¯”è¾ƒè¾“å‡ºä½¿èƒ½ TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //è¾“å‡ºææ€§:TIMè¾“å‡ºæ¯”è¾ƒææ€§é«˜ TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure); //æ ¹æ®TæŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾TIM3 OC2 TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); //ä½¿èƒ½TIM3åœ¨CCR2ä¸Šçš„é¢„è£…è½½å¯„å­˜å™¨ TIM_Cmd(TIM3, ENABLE); //ä½¿èƒ½TIM3 &#125;/******************* END OF FILE *********/ timer.h 12345678910// timer.h#ifndef __TIMER_H#define __TIMER_H#include &quot;sys.h&quot;void TIM3_Int_Init(u16 arr,u16 psc);void TIM3_PWM_Init(u16 arr,u16 psc);#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;timer.h&quot; int main(void) &#123; u16 led0pwmval=0; u8 dir=1; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //LEDç«¯å£åˆå§‹åŒ– TIM3_PWM_Init(899,0); //ä¸åˆ†é¢‘ã€‚PWMé¢‘ç‡=72000000/900=80Khz while(1) &#123; delay_ms(10); if(dir)led0pwmval++; else led0pwmval--; if(led0pwmval&gt;300)dir=0; if(led0pwmval==0)dir=1; TIM_SetCompare2(TIM3,led0pwmval); &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ8ï¼‰å®šæ—¶å™¨ä¸­æ–­","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-008","date":"2022-11-08T01:39:18.000Z","updated":"2023-04-05T14:19:00.567Z","comments":true,"path":"posts/3757997425.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3757997425.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ timer.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// timer.c#include &quot;timer.h&quot;#include &quot;led.h&quot;//é€šç”¨å®šæ—¶å™¨3ä¸­æ–­åˆå§‹åŒ–//è¿™é‡Œæ—¶é’Ÿé€‰æ‹©ä¸ºAPB1çš„2å€ï¼Œè€ŒAPB1ä¸º36M//arrï¼šè‡ªåŠ¨é‡è£…å€¼ã€‚//pscï¼šæ—¶é’Ÿé¢„åˆ†é¢‘æ•°//è¿™é‡Œä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨3!void TIM3_Int_Init(u16 arr,u16 psc)&#123; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //æ—¶é’Ÿä½¿èƒ½ //å®šæ—¶å™¨TIM3åˆå§‹åŒ– TIM_TimeBaseStructure.TIM_Period = arr; //è®¾ç½®åœ¨ä¸‹ä¸€ä¸ªæ›´æ–°äº‹ä»¶è£…å…¥æ´»åŠ¨çš„è‡ªåŠ¨é‡è£…è½½å¯„å­˜å™¨å‘¨æœŸçš„å€¼ TIM_TimeBaseStructure.TIM_Prescaler =psc; //è®¾ç½®ç”¨æ¥ä½œä¸ºTIMxæ—¶é’Ÿé¢‘ç‡é™¤æ•°çš„é¢„åˆ†é¢‘å€¼ TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //è®¾ç½®æ—¶é’Ÿåˆ†å‰²:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIMå‘ä¸Šè®¡æ•°æ¨¡å¼ TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //æ ¹æ®æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–TIMxçš„æ—¶é—´åŸºæ•°å•ä½ TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE ); //ä½¿èƒ½æŒ‡å®šçš„TIM3ä¸­æ–­,å…è®¸æ›´æ–°ä¸­æ–­ //ä¸­æ–­ä¼˜å…ˆçº§NVICè®¾ç½® NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; //TIM3ä¸­æ–­ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //å…ˆå ä¼˜å…ˆçº§0çº§ NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //ä»ä¼˜å…ˆçº§3çº§ NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQé€šé“è¢«ä½¿èƒ½ NVIC_Init(&amp;NVIC_InitStructure); //åˆå§‹åŒ–NVICå¯„å­˜å™¨ TIM_Cmd(TIM3, ENABLE); //ä½¿èƒ½TIMx &#125;//å®šæ—¶å™¨3ä¸­æ–­æœåŠ¡ç¨‹åºvoid TIM3_IRQHandler(void) //TIM3ä¸­æ–­&#123; if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //æ£€æŸ¥TIM3æ›´æ–°ä¸­æ–­å‘ç”Ÿä¸å¦ &#123; TIM_ClearITPendingBit(TIM3, TIM_IT_Update ); //æ¸…é™¤TIMxæ›´æ–°ä¸­æ–­æ ‡å¿— LED1=!LED1; &#125;&#125;/******************* END OF FILE *********/ timer.h 12345678910// timer.h#ifndef __TIMER_H#define __TIMER_H#include &quot;sys.h&quot;void TIM3_Int_Init(u16 arr,u16 psc); #endif/******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;timer.h&quot; int main(void) &#123; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //LEDç«¯å£åˆå§‹åŒ– TIM3_Int_Init(4999,7199);//10Khzçš„è®¡æ•°é¢‘ç‡ï¼Œè®¡æ•°åˆ°5000ä¸º500ms while(1) &#123; LED0=!LED0; delay_ms(200); &#125; &#125; /******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ7ï¼‰çª—å£çœ‹é—¨ç‹—","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-007","date":"2022-11-08T01:19:18.000Z","updated":"2023-04-05T14:18:51.344Z","comments":true,"path":"posts/2692450778.html","link":"","permalink":"https://sirius-tblog.github.io/posts/2692450778.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 LED0é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ã€‚ é©±åŠ¨ wwdg.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// wwdg.c#include &quot;wwdg.h&quot;#include &quot;led.h&quot;//ä¿å­˜WWDGè®¡æ•°å™¨çš„è®¾ç½®å€¼,é»˜è®¤ä¸ºæœ€å¤§. u8 WWDG_CNT=0x7f; //åˆå§‹åŒ–çª—å£çœ‹é—¨ç‹— //tr :T[6:0],è®¡æ•°å™¨å€¼ //wr :W[6:0],çª—å£å€¼ //fprer:åˆ†é¢‘ç³»æ•°ï¼ˆWDGTBï¼‰,ä»…æœ€ä½2ä½æœ‰æ•ˆ //Fwwdg=PCLK1/(4096*2^fprer). void WWDG_Init(u8 tr,u8 wr,u32 fprer)&#123; RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE); // WWDGæ—¶é’Ÿä½¿èƒ½ WWDG_CNT=tr&amp;WWDG_CNT; //åˆå§‹åŒ–WWDG_CNT. WWDG_SetPrescaler(fprer);////è®¾ç½®IWDGé¢„åˆ†é¢‘å€¼ WWDG_SetWindowValue(wr);//è®¾ç½®çª—å£å€¼ WWDG_Enable(WWDG_CNT); //ä½¿èƒ½çœ‹é—¨ç‹— , è®¾ç½® counter . WWDG_ClearFlag();//æ¸…é™¤æå‰å”¤é†’ä¸­æ–­æ ‡å¿—ä½ WWDG_NVIC_Init();//åˆå§‹åŒ–çª—å£çœ‹é—¨ç‹— NVIC WWDG_EnableIT(); //å¼€å¯çª—å£çœ‹é—¨ç‹—ä¸­æ–­&#125; //é‡è®¾ç½®WWDGè®¡æ•°å™¨çš„å€¼void WWDG_Set_Counter(u8 cnt)&#123; WWDG_Enable(cnt);//ä½¿èƒ½çœ‹é—¨ç‹— , è®¾ç½® counter . &#125;//çª—å£çœ‹é—¨ç‹—ä¸­æ–­æœåŠ¡ç¨‹åºvoid WWDG_NVIC_Init()&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = WWDG_IRQn; //WWDGä¸­æ–­ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; //æŠ¢å 2ï¼Œå­ä¼˜å…ˆçº§3ï¼Œç»„2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //æŠ¢å 2ï¼Œå­ä¼˜å…ˆçº§3ï¼Œç»„2 NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE; NVIC_Init(&amp;NVIC_InitStructure);//NVICåˆå§‹åŒ–&#125;void WWDG_IRQHandler(void) &#123; WWDG_SetCounter(WWDG_CNT); //å½“ç¦æ‰æ­¤å¥å,çª—å£çœ‹é—¨ç‹—å°†äº§ç”Ÿå¤ä½ WWDG_ClearFlag(); //æ¸…é™¤æå‰å”¤é†’ä¸­æ–­æ ‡å¿—ä½ LED1=!LED1; //LEDçŠ¶æ€ç¿»è½¬ &#125;/******************* END OF FILE *********/ wwdg.h 1234567891011// wwdg.h#ifndef __WDG_H#define __WDG_H#include &quot;sys.h&quot;void WWDG_Init(u8 tr,u8 wr,u32 fprer);//åˆå§‹åŒ–WWDGvoid WWDG_Set_Counter(u8 cnt); //è®¾ç½®WWDGçš„è®¡æ•°å™¨void WWDG_NVIC_Init(void);#endif/******************* END OF FILE *********/ main.c 1234567891011121314151617181920212223242526//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;wwdg.h&quot; int main(void) &#123; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§åˆ†ç»„ä¸ºç»„2ï¼š2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); KEY_Init(); //æŒ‰é”®åˆå§‹åŒ– LED0=0; delay_ms(300); WWDG_Init(0X7F,0X5F,WWDG_Prescaler_8);//è®¡æ•°å™¨å€¼ä¸º7f,çª—å£å¯„å­˜å™¨ä¸º5f,åˆ†é¢‘æ•°ä¸º8 while(1) &#123; LED0=1; &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ ä»£ç ç‰‡æ®µåˆ†æ ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ6ï¼‰ç‹¬ç«‹çœ‹é—¨ç‹—","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-006","date":"2022-11-08T00:49:18.000Z","updated":"2023-04-09T14:24:26.743Z","comments":true,"path":"posts/1102504782.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1102504782.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ ä½¿ç”¨æŒ‰é”® WK_UP æ“ä½œä»¥åŠLEDé—ªçƒç°è±¡è®¤è¯†ç‹¬ç«‹çœ‹é—¨ç‹—åŠå…¶åŸºæœ¬åº”ç”¨ã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š STM32ä¸»è¦åº”ç”¨ç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ led0 output PB5 LED0é©±åŠ¨ WK_UP input PA4 WK_UPçŠ¶æ€æ£€æµ‹ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶ä½¿ç”¨ç‹¬ç«‹çœ‹é—¨ç‹—èµ„æºï¼Œé€šè¿‡æŒ‰é”®çš„æ“ä½œä»¥åŠLEDé—ªçƒç»“æœåˆ¤æ–­å–‚ç‹—æ˜¯å¦å®Œæˆã€‚ æ ¹æ®ç”µè·¯è¿æ¥å…³ç³»ä»¥åŠå·²çŸ¥é€»è¾‘å…³ç³»å¯å¾—å¦‚ä¸‹é¢„æœŸç»“æœï¼š æŒ‰é”® çŠ¶æ€ ç°è±¡ è¯´æ˜ WK_UP é•¿æ—¶é—´æœªæ£€æµ‹åˆ°è¢«æŒ‰ä¸‹ LED0ä¸åœé—ªçƒ æ­¤æ—¶MCUé‡å¤è¿›å…¥mainå‡½æ•°ï¼Œå³è¢«ä¸åœåœ°å¤ä½ WK_UP æé¢‘ç¹æ£€æµ‹åˆ°è¢«æŒ‰ä¸‹ LED0å¸¸äº® æ­¤æ—¶ç¨‹åºåœ¨whileä¸­åœç•™ï¼Œå³å› ä¸ºåŠæ—¶å–‚ç‹—è€Œä¸ä¼šè¢«å¤ä½ é©±åŠ¨ iwdg.c 12345678910111213141516171819202122232425262728// iwdg.c#include &quot;iwdg.h&quot;//åˆå§‹åŒ–ç‹¬ç«‹çœ‹é—¨ç‹—//prer:åˆ†é¢‘æ•°:0~7(åªæœ‰ä½3ä½æœ‰æ•ˆ!)//åˆ†é¢‘å› å­=4*2^prer.ä½†æœ€å¤§å€¼åªèƒ½æ˜¯256!//rlr:é‡è£…è½½å¯„å­˜å™¨å€¼:ä½11ä½æœ‰æ•ˆ.//æ—¶é—´è®¡ç®—(å¤§æ¦‚):Tout=((4*2^prer)*rlr)/40 (ms).void IWDG_Init(u8 prer,u16 rlr) &#123; IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); //ä½¿èƒ½å¯¹å¯„å­˜å™¨IWDG_PRå’ŒIWDG_RLRçš„å†™æ“ä½œ IWDG_SetPrescaler(prer); //è®¾ç½®IWDGé¢„åˆ†é¢‘å€¼:è®¾ç½®IWDGé¢„åˆ†é¢‘å€¼ä¸º64 IWDG_SetReload(rlr); //è®¾ç½®IWDGé‡è£…è½½å€¼ IWDG_ReloadCounter(); //æŒ‰ç…§IWDGé‡è£…è½½å¯„å­˜å™¨çš„å€¼é‡è£…è½½IWDGè®¡æ•°å™¨ IWDG_Enable(); //ä½¿èƒ½IWDG&#125;//å–‚ç‹¬ç«‹çœ‹é—¨ç‹—void IWDG_Feed(void)&#123; IWDG_ReloadCounter();//reload &#125;/******************* END OF FILE *********/ iwdg.h 1234567891011// iwdg.h#ifndef __IWDG_H#define __IWDG_H#include &quot;sys.h&quot;void IWDG_Init(u8 prer,u16 rlr);void IWDG_Feed(void);#endif/******************* END OF FILE *********/ main.c 1234567891011121314151617181920212223242526272829//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;iwdg.h&quot; int main(void) &#123; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //åˆå§‹åŒ–ä¸LEDè¿æ¥çš„ç¡¬ä»¶æ¥å£ KEY_Init(); //æŒ‰é”®åˆå§‹åŒ– delay_ms(500); //è®©äººçœ‹å¾—åˆ°ç­ IWDG_Init(4,625); //ä¸åˆ†é¢‘æ•°ä¸º64,é‡è½½å€¼ä¸º625,æº¢å‡ºæ—¶é—´ä¸º1s LED0=0; //ç‚¹äº®LED0 while(1) &#123; if(KEY_Scan(0)==WKUP_PRES) &#123; IWDG_Feed();//å¦‚æœWK_UPæŒ‰ä¸‹,åˆ™å–‚ç‹— &#125; delay_ms(10); &#125;; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ é—²è°ˆ ç« èŠ‚ç›®çš„ æœ¬ç« ä¸»è¦æ˜¯ç†Ÿæ‚‰ç‹¬ç«‹çœ‹é—¨ç‹—IWDGèµ„æºã€‚ ç¨‹åºæ®µåˆ†æ å¯¹ç‹¬ç«‹çœ‹é—¨ç‹—ä½¿ç”¨çš„ä¸€èˆ¬æ­¥éª¤: æµ…çŸ¥å¤–éƒ¨ä¸­æ–­èµ„æº STM32 ç‹¬ç«‹çœ‹é—¨ç‹—èµ„æºå°çŸ¥è¯†ã€‚","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ5ï¼‰å¤–éƒ¨ä¸­æ–­","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-005","date":"2022-11-08T00:29:18.000Z","updated":"2023-04-09T14:08:52.187Z","comments":true,"path":"posts/730138348.html","link":"","permalink":"https://sirius-tblog.github.io/posts/730138348.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š STM32ä¸»è¦åº”ç”¨ç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ KEY0 input PE3 KEY0çŠ¶æ€æ£€æµ‹ KEY1 input PE4 KEY1çŠ¶æ€æ£€æµ‹ WK_UP input PA4 WK_UPçŠ¶æ€æ£€æµ‹ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶ï¼Œé€šè¿‡ä¸­æ–­çš„åŠŸèƒ½æ£€æµ‹ç«¯å£çŠ¶æ€å¹¶æ§åˆ¶å¤–éƒ¨LEDæŒ‡ç¤ºç¯ã€èœ‚é¸£å™¨ç­‰ç”µè·¯å™¨ä»¶ã€‚ æ ¹æ®ç”µè·¯è¿æ¥å…³ç³»å¯çŸ¥å¦‚ä¸‹é¢„æœŸç»“æœï¼š æŒ‰é”® çŠ¶æ€ ç°è±¡ KEY0 æ£€æµ‹åˆ°è¢«æŒ‰ä¸‹ BEEPå‘å£° KEY1 æ£€æµ‹åˆ°è¢«æŒ‰ä¸‹ LED1æš—äº®çŠ¶æ€ç¿»è½¬ WK_UP æ£€æµ‹åˆ°è¢«æŒ‰ä¸‹ LED0ã€LED1æš—äº®çŠ¶æ€åŒæ—¶ç¿»è½¬ é©±åŠ¨ exti.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// exti.c#include &quot;exti.h&quot;#include &quot;led.h&quot;#include &quot;key.h&quot;#include &quot;delay.h&quot;#include &quot;usart.h&quot;#include &quot;beep.h&quot;//å¤–éƒ¨ä¸­æ–­0æœåŠ¡ç¨‹åºvoid EXTIX_Init(void)&#123; EXTI_InitTypeDef EXTI_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; KEY_Init(); // æŒ‰é”®ç«¯å£åˆå§‹åŒ– RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //ä½¿èƒ½å¤ç”¨åŠŸèƒ½æ—¶é’Ÿ //GPIOE.3 ä¸­æ–­çº¿ä»¥åŠä¸­æ–­åˆå§‹åŒ–é…ç½® ä¸‹é™æ²¿è§¦å‘ //KEY1 GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource3); EXTI_InitStructure.EXTI_Line=EXTI_Line3; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(&amp;EXTI_InitStructure); //æ ¹æ®EXTI_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾EXTIå¯„å­˜å™¨ //GPIOE.4 ä¸­æ–­çº¿ä»¥åŠä¸­æ–­åˆå§‹åŒ–é…ç½® ä¸‹é™æ²¿è§¦å‘ //KEY0 GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource4); EXTI_InitStructure.EXTI_Line=EXTI_Line4; EXTI_Init(&amp;EXTI_InitStructure); //æ ¹æ®EXTI_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾EXTIå¯„å­˜å™¨ //GPIOA.0 ä¸­æ–­çº¿ä»¥åŠä¸­æ–­åˆå§‹åŒ–é…ç½® ä¸Šå‡æ²¿è§¦å‘ PA0 //WK_UP GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); EXTI_InitStructure.EXTI_Line=EXTI_Line0; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_Init(&amp;EXTI_InitStructure); //æ ¹æ®EXTI_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾EXTIå¯„å­˜å™¨ NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; //ä½¿èƒ½æŒ‰é”®WK_UPæ‰€åœ¨çš„å¤–éƒ¨ä¸­æ–­é€šé“ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //æŠ¢å ä¼˜å…ˆçº§2ï¼Œ NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03; //å­ä¼˜å…ˆçº§3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //ä½¿èƒ½å¤–éƒ¨ä¸­æ–­é€šé“ NVIC_Init(&amp;NVIC_InitStructure); NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn; //ä½¿èƒ½æŒ‰é”®KEY1æ‰€åœ¨çš„å¤–éƒ¨ä¸­æ–­é€šé“ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //æŠ¢å ä¼˜å…ˆçº§2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01; //å­ä¼˜å…ˆçº§1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //ä½¿èƒ½å¤–éƒ¨ä¸­æ–­é€šé“ NVIC_Init(&amp;NVIC_InitStructure); //æ ¹æ®NVIC_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾NVICå¯„å­˜å™¨ NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn; //ä½¿èƒ½æŒ‰é”®KEY0æ‰€åœ¨çš„å¤–éƒ¨ä¸­æ–­é€šé“ NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //æŠ¢å ä¼˜å…ˆçº§2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00; //å­ä¼˜å…ˆçº§0 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //ä½¿èƒ½å¤–éƒ¨ä¸­æ–­é€šé“ NVIC_Init(&amp;NVIC_InitStructure); //æ ¹æ®NVIC_InitStructä¸­æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–å¤–è®¾NVICå¯„å­˜å™¨ &#125;//å¤–éƒ¨ä¸­æ–­0æœåŠ¡ç¨‹åº void EXTI0_IRQHandler(void)&#123; delay_ms(10);//æ¶ˆæŠ– if(WK_UP==1) //WK_UPæŒ‰é”® &#123; BEEP=!BEEP; &#125; EXTI_ClearITPendingBit(EXTI_Line0); //æ¸…é™¤LINE0ä¸Šçš„ä¸­æ–­æ ‡å¿—ä½ &#125; //å¤–éƒ¨ä¸­æ–­3æœåŠ¡ç¨‹åºvoid EXTI3_IRQHandler(void)&#123; delay_ms(10);//æ¶ˆæŠ– if(KEY1==0) //æŒ‰é”®KEY1 &#123; LED1=!LED1; &#125; EXTI_ClearITPendingBit(EXTI_Line3); //æ¸…é™¤LINE3ä¸Šçš„ä¸­æ–­æ ‡å¿—ä½ &#125;void EXTI4_IRQHandler(void)&#123; delay_ms(10);//æ¶ˆæŠ– if(KEY0==0) //æŒ‰é”®KEY0 &#123; LED0=!LED0; LED1=!LED1; &#125; EXTI_ClearITPendingBit(EXTI_Line4); //æ¸…é™¤LINE4ä¸Šçš„ä¸­æ–­æ ‡å¿—ä½ &#125;/******************* END OF FILE *********/ exti.h 123456789// exti.h#ifndef __EXTI_H#define __EXIT_H #include &quot;sys.h&quot;void EXTIX_Init(void);//å¤–éƒ¨ä¸­æ–­åˆå§‹åŒ– #endif/******************* END OF FILE *********/ main.c 123456789101112131415161718192021222324252627//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot;#include &quot;exti.h&quot;#include &quot;beep.h&quot; int main(void) &#123; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //åˆå§‹åŒ–ä¸LEDè¿æ¥çš„ç¡¬ä»¶æ¥å£ BEEP_Init(); //åˆå§‹åŒ–èœ‚é¸£å™¨IO EXTIX_Init(); //åˆå§‹åŒ–å¤–éƒ¨ä¸­æ–­è¾“å…¥ LED0=0; //å…ˆç‚¹äº®çº¢ç¯ while(1) &#123; printf(&quot;OK\\r\\n&quot;); delay_ms(1000); &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ é—²è°ˆ ç« èŠ‚ç›®çš„ æœ¬ç« ä¸»è¦æ˜¯ç†Ÿæ‚‰åŸºç¡€ GPIO ç«¯å£å¤–éƒ¨ä¸­æ–­èµ„æºã€‚ ç¨‹åºæ®µåˆ†æ å¯¹IOå£å¤–éƒ¨ä¸­æ–­ä½¿ç”¨çš„ä¸€èˆ¬æ­¥éª¤: åˆå§‹åŒ– IO å£ä¸ºè¾“å…¥ã€‚ å¼€å¯ AFIO æ—¶é’Ÿ è®¾ç½® IO å£ä¸ä¸­æ–­çº¿çš„æ˜ å°„å…³ç³»ã€‚ åˆå§‹åŒ–çº¿ä¸Šä¸­æ–­ï¼Œè®¾ç½®è§¦å‘æ¡ä»¶ç­‰ã€‚ é…ç½®ä¸­æ–­åˆ†ç»„ï¼ˆNVICï¼‰ï¼Œå¹¶ä½¿èƒ½ä¸­æ–­ã€‚ ç¼–å†™ä¸­æ–­æœåŠ¡å‡½æ•°ã€‚ ä¸»å‡½æ•°ä¸­å¯¹ä¸­æ–­èµ„æºè¿›è¡Œåˆå§‹åŒ–è°ƒç”¨ï¼Œé©±åŠ¨æŒ‡ç¤ºç¯ã€èœ‚é¸£å™¨ç­‰ç­‰ã€‚ æµ…çŸ¥å¤–éƒ¨ä¸­æ–­èµ„æº STM32 å¤–éƒ¨ä¸­æ–­å°çŸ¥è¯†ã€‚","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ4ï¼‰ä¸²å£é€šä¿¡","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-004","date":"2022-11-07T23:59:18.000Z","updated":"2023-04-09T14:08:40.041Z","comments":true,"path":"posts/1103739706.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1103739706.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ åº”ç”¨å†…éƒ¨ä¸²å£èµ„æºï¼Œå®ç°ä¸²å£é€šä¿¡åŠŸèƒ½ã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š STM32ä¸»è¦åº”ç”¨ç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ USART1_TX output PA9 MCUç«¯ä¸²å£USART1ä¿¡å·è¾“å‡º USART1_RX input PA10 MCUç«¯ä¸²å£USART1ä¿¡å·è¾“å…¥ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨USART1å†…éƒ¨èµ„æºï¼Œé€šè¿‡USBè½¬ä¸²å£ç”µè·¯è¿›è¡Œä¸PCç«¯é€šä¿¡ã€‚æ­¤å¤„ä½¿ç”¨RS232åè®®ã€‚ é©±åŠ¨ usart.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138// usart.c#include &quot;sys.h&quot;#include &quot;usart.h&quot; //å¦‚æœä½¿ç”¨ucos,åˆ™åŒ…æ‹¬ä¸‹é¢çš„å¤´æ–‡ä»¶å³å¯#if SYSTEM_SUPPORT_OS#include &quot;includes.h&quot; //ucos ä½¿ç”¨ #endif/åŠ å…¥ä»¥ä¸‹ä»£ç ,æ”¯æŒprintfå‡½æ•°,è€Œä¸éœ€è¦é€‰æ‹©use MicroLIB #if 1#pragma import(__use_no_semihosting) //æ ‡å‡†åº“éœ€è¦çš„æ”¯æŒå‡½æ•° struct __FILE &#123; int handle; &#125;; FILE __stdout; //å®šä¹‰_sys_exit()ä»¥é¿å…ä½¿ç”¨åŠä¸»æœºæ¨¡å¼ void _sys_exit(int x) &#123; x = x; &#125; //é‡å®šä¹‰fputcå‡½æ•° int fputc(int ch, FILE *f)&#123; while((USART1-&gt;SR&amp;0X40)==0);//å¾ªç¯å‘é€,ç›´åˆ°å‘é€å®Œæ¯• USART1-&gt;DR = (u8) ch; return ch;&#125;#endif /*ä½¿ç”¨microLibçš„æ–¹æ³•*/ /* int fputc(int ch, FILE *f)&#123; USART_SendData(USART1, (uint8_t) ch); while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET) &#123;&#125; return ch;&#125;int GetKey (void) &#123; while (!(USART1-&gt;SR &amp; USART_FLAG_RXNE)); return ((int)(USART1-&gt;DR &amp; 0x1FF));&#125;*/ #if EN_USART1_RX //å¦‚æœä½¿èƒ½äº†æ¥æ”¶//ä¸²å£1ä¸­æ–­æœåŠ¡ç¨‹åº//æ³¨æ„,è¯»å–USARTx-&gt;SRèƒ½é¿å…è«åå…¶å¦™çš„é”™è¯¯ u8 USART_RX_BUF[USART_REC_LEN]; //æ¥æ”¶ç¼“å†²,æœ€å¤§USART_REC_LENä¸ªå­—èŠ‚.//æ¥æ”¶çŠ¶æ€//bit15ï¼Œ æ¥æ”¶å®Œæˆæ ‡å¿—//bit14ï¼Œ æ¥æ”¶åˆ°0x0d//bit13~0ï¼Œ æ¥æ”¶åˆ°çš„æœ‰æ•ˆå­—èŠ‚æ•°ç›®u16 USART_RX_STA=0; //æ¥æ”¶çŠ¶æ€æ ‡è®° void uart_init(u32 bound)&#123; //GPIOç«¯å£è®¾ç½® GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE); //ä½¿èƒ½USART1ï¼ŒGPIOAæ—¶é’Ÿ //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //å¤ç”¨æ¨æŒ½è¾“å‡º GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//åˆå§‹åŒ–GPIOA.9 //USART1_RX GPIOA.10åˆå§‹åŒ– GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//æµ®ç©ºè¾“å…¥ GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//åˆå§‹åŒ–GPIOA.10 //Usart1 NVIC é…ç½® NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//æŠ¢å ä¼˜å…ˆçº§3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //å­ä¼˜å…ˆçº§3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQé€šé“ä½¿èƒ½ NVIC_Init(&amp;NVIC_InitStructure); //æ ¹æ®æŒ‡å®šçš„å‚æ•°åˆå§‹åŒ–VICå¯„å­˜å™¨ //USART åˆå§‹åŒ–è®¾ç½® USART_InitStructure.USART_BaudRate = bound;//ä¸²å£æ³¢ç‰¹ç‡ USART_InitStructure.USART_WordLength = USART_WordLength_8b;//å­—é•¿ä¸º8ä½æ•°æ®æ ¼å¼ USART_InitStructure.USART_StopBits = USART_StopBits_1;//ä¸€ä¸ªåœæ­¢ä½ USART_InitStructure.USART_Parity = USART_Parity_No;//æ— å¥‡å¶æ ¡éªŒä½ USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//æ— ç¡¬ä»¶æ•°æ®æµæ§åˆ¶ USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //æ”¶å‘æ¨¡å¼ USART_Init(USART1, &amp;USART_InitStructure); //åˆå§‹åŒ–ä¸²å£1 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//å¼€å¯ä¸²å£æ¥å—ä¸­æ–­ USART_Cmd(USART1, ENABLE); //ä½¿èƒ½ä¸²å£1 &#125;void USART1_IRQHandler(void) //ä¸²å£1ä¸­æ–­æœåŠ¡ç¨‹åº &#123; u8 Res;#if SYSTEM_SUPPORT_OS //å¦‚æœSYSTEM_SUPPORT_OSä¸ºçœŸï¼Œåˆ™éœ€è¦æ”¯æŒOS. OSIntEnter(); #endif if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //æ¥æ”¶ä¸­æ–­(æ¥æ”¶åˆ°çš„æ•°æ®å¿…é¡»æ˜¯0x0d 0x0aç»“å°¾) &#123; Res =USART_ReceiveData(USART1); //è¯»å–æ¥æ”¶åˆ°çš„æ•°æ® if((USART_RX_STA&amp;0x8000)==0)//æ¥æ”¶æœªå®Œæˆ &#123; if(USART_RX_STA&amp;0x4000)//æ¥æ”¶åˆ°äº†0x0d &#123; if(Res!=0x0a)USART_RX_STA=0;//æ¥æ”¶é”™è¯¯,é‡æ–°å¼€å§‹ else USART_RX_STA|=0x8000; //æ¥æ”¶å®Œæˆäº† &#125; else //è¿˜æ²¡æ”¶åˆ°0X0D &#123; if(Res==0x0d)USART_RX_STA|=0x4000; else &#123; USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=Res ; USART_RX_STA++; if(USART_RX_STA&gt;(USART_REC_LEN-1))USART_RX_STA=0;//æ¥æ”¶æ•°æ®é”™è¯¯,é‡æ–°å¼€å§‹æ¥æ”¶ &#125; &#125; &#125; &#125; #if SYSTEM_SUPPORT_OS //å¦‚æœSYSTEM_SUPPORT_OSä¸ºçœŸï¼Œåˆ™éœ€è¦æ”¯æŒOS. OSIntExit(); #endif&#125; #endif /******************* END OF FILE *********/ usart.h 12345678910111213141516// usart.h#ifndef __USART_H#define __USART_H#include &quot;stdio.h&quot; #include &quot;sys.h&quot; #define USART_REC_LEN 200 //å®šä¹‰æœ€å¤§æ¥æ”¶å­—èŠ‚æ•° 200#define EN_USART1_RX 1 //ä½¿èƒ½ï¼ˆ1ï¼‰/ç¦æ­¢ï¼ˆ0ï¼‰ä¸²å£1æ¥æ”¶ extern u8 USART_RX_BUF[USART_REC_LEN]; //æ¥æ”¶ç¼“å†²,æœ€å¤§USART_REC_LENä¸ªå­—èŠ‚.æœ«å­—èŠ‚ä¸ºæ¢è¡Œç¬¦ extern u16 USART_RX_STA; //æ¥æ”¶çŠ¶æ€æ ‡è®° //å¦‚æœæƒ³ä¸²å£ä¸­æ–­æ¥æ”¶ï¼Œè¯·ä¸è¦æ³¨é‡Šä»¥ä¸‹å®å®šä¹‰void uart_init(u32 bound);#endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;usart.h&quot; int main(void) &#123; u16 t; u16 len; u16 times=0; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //è®¾ç½®NVICä¸­æ–­åˆ†ç»„2:2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§ uart_init(115200); //ä¸²å£åˆå§‹åŒ–ä¸º115200 LED_Init(); //LEDç«¯å£åˆå§‹åŒ– KEY_Init(); //åˆå§‹åŒ–ä¸æŒ‰é”®è¿æ¥çš„ç¡¬ä»¶æ¥å£ while(1) &#123; if(USART_RX_STA&amp;0x8000) &#123; len=USART_RX_STA&amp;0x3fff;//å¾—åˆ°æ­¤æ¬¡æ¥æ”¶åˆ°çš„æ•°æ®é•¿åº¦ printf(&quot;\\r\\næ‚¨å‘é€çš„æ¶ˆæ¯ä¸º:\\r\\n\\r\\n&quot;); for(t=0;t&lt;len;t++) &#123; USART_SendData(USART1, USART_RX_BUF[t]);//å‘ä¸²å£1å‘é€æ•°æ® while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);//ç­‰å¾…å‘é€ç»“æŸ &#125; printf(&quot;\\r\\n\\r\\n&quot;);//æ’å…¥æ¢è¡Œ USART_RX_STA=0; &#125;else &#123; times++; if(times%5000==0) &#123; printf(&quot;\\r\\nç²¾è‹±STM32å¼€å‘æ¿ ä¸²å£å®éªŒ\\r\\n&quot;); printf(&quot;æ­£ç‚¹åŸå­@ALIENTEK\\r\\n\\r\\n&quot;); &#125; if(times%200==0)printf(&quot;è¯·è¾“å…¥æ•°æ®,ä»¥å›è½¦é”®ç»“æŸ\\n&quot;); if(times%30==0)LED0=!LED0;//é—ªçƒLED,æç¤ºç³»ç»Ÿæ­£åœ¨è¿è¡Œ. delay_ms(10); &#125; &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ é—²è°ˆ ç« èŠ‚ç›®çš„ æœ¬ç« ä¸»è¦æ˜¯ç†Ÿæ‚‰ GPIO å¤ç”¨ç«¯å£èµ„æºUSART1çš„é€šä¿¡ã€‚ ç¨‹åºæ®µåˆ†æ å¯¹ç«¯å£çš„é©±åŠ¨ï¼Œè¿™é‡Œä¸»è¦è¿›è¡Œå¦‚ä¸‹è®¾ç½®ï¼ˆè§ usart.c ï¼‰: å¯åŠ¨ç›¸åº”ç«¯å£æ—¶é’Ÿ Clock ä»¥åŠå¤ç”¨èµ„æºUSART1 æ—¶é’Ÿ Clock; ä¸²å£ USART1 å¤ä½; åˆå§‹åŒ–ç«¯é…ç½®ï¼ŒåŒ…æ‹¬â€œå…·ä½“å¼•è„š PIN_x â€ã€â€œç«¯å£æ¨¡å¼ Mode â€ã€â€œé€Ÿåº¦é…ç½® Speed â€; å°†ä¸Šè¿°é…ç½®ä½¿ç”¨å®˜æ–¹åº“å‡½æ•°è¿›è¡Œå¯¹å¯¹åº”ç«¯å£å¼•è„šåˆå§‹åŒ–(å‡½æ•° GPIO_Init() ); åˆå§‹åŒ– USART1 èµ„æºå‚æ•°é…ç½®ï¼ŒåŒ…æ‹¬â€œæ³¢ç‰¹ç‡ BaudRateâ€ã€â€œå­—èŠ‚é•¿åº¦ WordLength â€ã€â€œåœæ­¢ä½ StopBits â€ã€â€œå¥‡å¶æ ¡éªŒä½ Parity â€ã€â€œç¡¬ä»¶æ•°æ®æµæ§åˆ¶ HFC â€ã€â€œæ”¶å‘æ¨¡å¼ Mode â€; å°†ä¸Šè¿°é…ç½®ä½¿ç”¨å®˜æ–¹åº“å‡½æ•°è¿›è¡Œå¯¹å¯¹åº”èµ„æºåˆå§‹åŒ–(å‡½æ•° USART_Init() ); åˆå§‹åŒ–ä¼˜å…ˆçº§ NVIC å‚æ•°é…ç½®ï¼ŒåŒ…æ‹¬â€œä¸­æ–­è¯·æ±‚é€šé“ IRQChannelâ€ã€â€œæŠ¢å ä¼˜å…ˆçº§ â€ã€â€œå­ä¼˜å…ˆçº§â€ã€â€œä¸­æ–­è¯·æ±‚é€šé“ä½¿èƒ½ â€; å°†ä¸Šè¿°é…ç½®ä½¿ç”¨å®˜æ–¹åº“å‡½æ•°è¿›è¡Œå¯¹å¯¹åº” NVIC åˆå§‹åŒ–(å‡½æ•° NVIC_Init() ); å¼€å¯ä¸­æ–­; ä½¿èƒ½ä¸²å£ USART1; ä¸»å‡½æ•°ä¸­å¯¹è‡ªå®šä¹‰å‡½æ•°è¿›è¡Œè°ƒç”¨å¹¶æ‰§è¡Œï¼Œé©±åŠ¨æŒ‡ç¤ºç¯ã€èœ‚é¸£å™¨ç­‰ç­‰ã€‚","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ3ï¼‰æŒ‰é”®è¾“å…¥","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-003","date":"2022-11-07T23:39:18.000Z","updated":"2023-04-09T14:08:23.852Z","comments":true,"path":"posts/1977272759.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1977272759.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°å¤–éƒ¨ç«¯å£çŠ¶æ€ï¼ˆæŒ‰é”®çŠ¶æ€ï¼‰æ£€æµ‹ã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š STM32ä¸»è¦åº”ç”¨ç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ KEY0 input PE3 KEY0çŠ¶æ€æ£€æµ‹ KEY1 input PE4 KEY1çŠ¶æ€æ£€æµ‹ WK_UP input PA4 WK_UPçŠ¶æ€æ£€æµ‹ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶æ£€æµ‹GPIOå£çš„çŠ¶æ€ï¼Œå¹¶æ§åˆ¶å¤–éƒ¨LEDæŒ‡ç¤ºç¯ã€èœ‚é¸£å™¨ç­‰ç”µè·¯å™¨ä»¶ã€‚ æ ¹æ®ç”µè·¯è¿æ¥å…³ç³»å¯çŸ¥å¦‚ä¸‹é¢„æœŸç»“æœï¼š ç«¯å£ ç”µå¹³çŠ¶æ€ ç°è±¡ è¯´æ˜ PE3 æ£€æµ‹åˆ°ä½ç”µå¹³ KEY0è¢«æŒ‰ä¸‹ æ­¤æ—¶è¯¥ç«¯å£å¤–éƒ¨è¢«æ¥GND PE4 æ£€æµ‹åˆ°ä½ç”µå¹³ KEY1è¢«æŒ‰ä¸‹ åŒä¸Š PA4 æ£€æµ‹åˆ°é«˜ç”µå¹³ WK_UPè¢«æŒ‰ä¸‹ æ­¤æ—¶è¯¥ç«¯å£å¤–éƒ¨è¢«æ¥VCC3.3 PE3 æ£€æµ‹åˆ°é«˜ç”µå¹³ KEY0è¢«æ”¾å¼€ æ­¤æ—¶è¯¥ç«¯å£å¤–éƒ¨æ‚¬ç©º PE4 æ£€æµ‹åˆ°é«˜ç”µå¹³ KEY1è¢«æ”¾å¼€ åŒä¸Š PA4 æ£€æµ‹åˆ°ä½ç”µå¹³ WK_UPè¢«æ”¾å¼€ åŒä¸Š é€šè¿‡ä»¥ä¸Šé¢„æœŸçŠ¶æ€ï¼Œå¯ä»¥è®¾è®¡æ§åˆ¶å¤–éƒ¨LEDæŒ‡ç¤ºç¯ã€èœ‚é¸£å™¨ç­‰ç”µè·¯å™¨ä»¶çš„é€»è¾‘ï¼Œå¦‚â€œä¸€æ§ä¸€â€ã€â€œä¸€æ§å¤šâ€ã€â€œå¤šæ§ä¸€â€ã€â€œé•¿æŒ‰çŸ­æŒ‰æ§åˆ¶â€ç­‰ç­‰ã€‚æ­¤å¤„è¯•éªŒè®¾è®¡é€»è¾‘å…³ç³»é¢„æœŸå¦‚ä¸‹ï¼š æŒ‰é”® çŠ¶æ€ ç°è±¡ KEY0 æ£€æµ‹åˆ°è¢«æŒ‰ä¸‹ BEEPå‘å£° KEY1 æ£€æµ‹åˆ°è¢«æŒ‰ä¸‹ LED1æš—äº®çŠ¶æ€ç¿»è½¬ WK_UP æ£€æµ‹åˆ°è¢«æŒ‰ä¸‹ LED0ã€LED1æš—äº®çŠ¶æ€åŒæ—¶ç¿»è½¬ é©±åŠ¨ key.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// key.c#include &quot;stm32f10x.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot; #include &quot;delay.h&quot;//æŒ‰é”®åˆå§‹åŒ–å‡½æ•°void KEY_Init(void) //IOåˆå§‹åŒ–&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOE,ENABLE); //ä½¿èƒ½PORTA,PORTEæ—¶é’Ÿ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_3; //KEY0-KEY1 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //è®¾ç½®æˆä¸Šæ‹‰è¾“å…¥ï¼ˆå› ä¸ºå¤–éƒ¨ç½®ä½ä¸ºæœ‰æ•ˆæ“ä½œï¼Œæ­¤å¤„åº”ä¸Šæ‹‰ï¼‰ GPIO_Init(GPIOE, &amp;GPIO_InitStructure); //åˆå§‹åŒ–GPIOE4,3 //åˆå§‹åŒ– WK_UP--&gt;GPIOA.0 ä¸‹æ‹‰è¾“å…¥ï¼ˆå› ä¸ºå¤–éƒ¨ç½®é«˜ä¸ºæœ‰æ•ˆæ“ä½œï¼Œæ­¤å¤„åº”ä¸‹æ‹‰ï¼‰ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0è®¾ç½®æˆè¾“å…¥ï¼Œé»˜è®¤ä¸‹æ‹‰ GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//åˆå§‹åŒ–GPIOA.0&#125;//æŒ‰é”®å¤„ç†å‡½æ•°//è¿”å›æŒ‰é”®å€¼//mode:0,ä¸æ”¯æŒè¿ç»­æŒ‰;1,æ”¯æŒè¿ç»­æŒ‰;//0ï¼Œæ²¡æœ‰ä»»ä½•æŒ‰é”®æŒ‰ä¸‹//1ï¼ŒKEY0æŒ‰ä¸‹//2ï¼ŒKEY1æŒ‰ä¸‹//3ï¼ŒKEY3æŒ‰ä¸‹ WK_UP//æ³¨æ„æ­¤å‡½æ•°æœ‰å“åº”ä¼˜å…ˆçº§,KEY0&gt;KEY1&gt;KEY_UP!!u8 KEY_Scan(u8 mode)&#123; static u8 key_up=1;//æŒ‰é”®æŒ‰æ¾å¼€æ ‡å¿— if(mode)key_up=1; //æ”¯æŒè¿æŒ‰ if(key_up&amp;&amp;(KEY0==0||KEY1==0||WK_UP==1)) &#123; delay_ms(10);//å»æŠ–åŠ¨ key_up=0; if(KEY0==0)return KEY0_PRES; else if(KEY1==0)return KEY1_PRES; else if(WK_UP==1)return WKUP_PRES; &#125;else if(KEY0==1&amp;&amp;KEY1==1&amp;&amp;WK_UP==0)key_up=1; return 0;// æ— æŒ‰é”®æŒ‰ä¸‹&#125;/******************* END OF FILE *********/ key.h 1234567891011121314151617181920// key.h#ifndef __KEY_H#define __KEY_H #include &quot;sys.h&quot;#define KEY0 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4)//è¯»å–æŒ‰é”®0(KEY0) #define KEY1 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3)//è¯»å–æŒ‰é”®1(KEY1) #define WK_UP GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)//è¯»å–æŒ‰é”®3(WK_UP) #define KEY0_PRES 1 //KEY0æŒ‰ä¸‹#define KEY1_PRES 2 //KEY1æŒ‰ä¸‹#define WKUP_PRES 3 //KEY_UPæŒ‰ä¸‹(å³WK_UP/KEY_UP)void KEY_Init(void);//IOåˆå§‹åŒ–u8 KEY_Scan(u8); //æŒ‰é”®æ‰«æå‡½æ•° #endif/******************* END OF FILE *********/ main.c 1234567891011121314151617181920212223242526272829303132333435363738//main.c#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;beep.h&quot; int main(void) &#123; vu8 key=0; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– LED_Init(); //åˆå§‹åŒ–ä¸LEDè¿æ¥çš„ç¡¬ä»¶æ¥å£ BEEP_Init(); //åˆå§‹åŒ–èœ‚é¸£å™¨ç«¯å£ KEY_Init(); //åˆå§‹åŒ–ä¸æŒ‰é”®è¿æ¥çš„ç¡¬ä»¶æ¥å£ LED0=0; //å…ˆç‚¹äº®çº¢ç¯ while(1) &#123; key=KEY_Scan(0); //å¾—åˆ°é”®å€¼ if(key) &#123; switch(key) &#123; case WKUP_PRES: //æ§åˆ¶èœ‚é¸£å™¨ BEEP=!BEEP; break; case KEY1_PRES: //æ§åˆ¶LED1ç¿»è½¬ LED1=!LED1; break; case KEY0_PRES: //åŒæ—¶æ§åˆ¶LED0,LED1ç¿»è½¬ LED0=!LED0; LED1=!LED1; break; &#125; &#125;else delay_ms(10); &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ é—²è°ˆ ç« èŠ‚ç›®çš„ æœ¬ç« ä¸»è¦æ˜¯ç†Ÿæ‚‰åŸºç¡€ GPIO ç«¯å£çŠ¶æ€çš„æ£€æµ‹ï¼Œå³ç«¯å£çš„è¾“å…¥ã€‚ ç¨‹åºæ®µåˆ†æ å¯¹ç«¯å£çš„é©±åŠ¨ï¼Œè¿™é‡Œä¸»è¦è¿›è¡Œå¦‚ä¸‹è®¾ç½®ï¼ˆè§ key.c ï¼‰: å¯åŠ¨ç›¸åº”ç«¯å£æ—¶é’Ÿ Clock; åˆå§‹åŒ–ç«¯é…ç½®ï¼ŒåŒ…æ‹¬â€œå…·ä½“å¼•è„š PIN_x â€ã€â€œç«¯å£æ¨¡å¼ Mode â€ã€â€œé€Ÿåº¦é…ç½® Speed â€; å°†ä¸Šè¿°é…ç½®ä½¿ç”¨å®˜æ–¹åº“å‡½æ•°è¿›è¡Œå¯¹å¯¹åº”ç«¯å£å¼•è„šè¿›è¡Œåˆå§‹åŒ–(å‡½æ•° GPIO_Init() ); å› ä¸ºæ˜¯è¾“å…¥æ£€æµ‹ï¼Œä¸éœ€è¦é…ç½®åˆå§‹çŠ¶æ€å€¼ï¼Œè‡ªå®šä¹‰å¯æ‰§è¡Œå‡½æ•°æ˜¯å®ç°æŒ‰é”®æ£€æµ‹ç»“æœä¸å¤–éƒ¨ç”µè·¯é©±åŠ¨çš„æ†ç»‘å…³ç³»; ä¸»å‡½æ•°ä¸­å¯¹è‡ªå®šä¹‰å‡½æ•°è¿›è¡Œè°ƒç”¨å¹¶æ‰§è¡Œï¼Œé©±åŠ¨æŒ‡ç¤ºç¯ã€èœ‚é¸£å™¨ç­‰ç­‰ã€‚","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ2ï¼‰èœ‚é¸£å™¨","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-002","date":"2022-11-07T23:29:18.000Z","updated":"2023-05-14T15:43:25.936Z","comments":true,"path":"posts/3238499939.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3238499939.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œï¼Œå®ç°æœ‰æºèœ‚é¸£å™¨é¸£å«ã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š STM32ä¸»è¦åº”ç”¨ç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ beep output PB8 BEEP é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ï¼Œæ­¤å¤„ç«¯å£é€šè¿‡é—´æ¥æ–¹å¼å®ç°æ§åˆ¶ï¼Œå³é€šè¿‡å°ç”µæµæ”¹å˜æŸä¸€å™¨ä»¶çš„å·¥ä½œçŠ¶æ€ï¼Œç»§è€Œå®ç°å—æ§å™¨ä»¶å¯¹ç›®æ ‡çš„æ§åˆ¶ã€‚ æ­¤å¤„çš„å—æ§å™¨ä»¶ä¸ºNPNå‹ä¸‰æç®¡ï¼ˆS8050ï¼‰ï¼Œæ ¹æ®ç”µè·¯è¿æ¥å…³ç³»å¯çŸ¥å¦‚ä¸‹é¢„æœŸç»“æœï¼š ç«¯å£ ç”µå¹³çŠ¶æ€ ç°è±¡ è¯´æ˜ PB8 è¾“å‡ºé«˜ç”µå¹³ BEEPå‘å£° ä¸‰æç®¡æ»¡è¶³é¥±å’Œæ¡ä»¶ï¼Œç”µè·¯å¯¼é€š PB8 è¾“å‡ºä½ç”µå¹³ BEEPé™é»˜ ä¸‰æç®¡æ»¡è¶³æˆªæ­¢æ¡ä»¶ï¼Œç”µè·¯ä¸é€š é©±åŠ¨ beep.c 12345678910111213141516171819202122// beep.c#include &quot;beep.h&quot;//åˆå§‹åŒ–PB8ä¸ºè¾“å‡ºå£.å¹¶ä½¿èƒ½è¿™ä¸ªIOå£çš„æ—¶é’Ÿ //èœ‚é¸£å™¨åˆå§‹åŒ–void BEEP_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //ä½¿èƒ½GPIOBç«¯å£æ—¶é’Ÿ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; //BEEP--&gt;PB.8 ç«¯å£é…ç½® GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //é€Ÿåº¦ä¸º50MHz GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //æ ¹æ®å‚æ•°åˆå§‹åŒ–GPIOB.8 GPIO_ResetBits(GPIOB,GPIO_Pin_8); //è¾“å‡ºç½®ä½ï¼Œå³å…³é—­èœ‚é¸£å™¨&#125;/******************* END OF FILE *********/ beep.h 12345678910111213// beep.h#ifndef __BEEP_H#define __BEEP_H #include &quot;sys.h&quot;//èœ‚é¸£å™¨ç«¯å£å®šä¹‰#define BEEP PBout(8) // BEEP,èœ‚é¸£å™¨æ¥å£ void BEEP_Init(void); //åˆå§‹åŒ– #endif/******************* END OF FILE *********/ main.c 1234567891011121314151617181920//main.c#include &quot;sys.h&quot; #include &quot;delay.h&quot; #include &quot;beep.h&quot; int main(void) &#123; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– BEEP_Init(); //åˆå§‹åŒ–èœ‚é¸£å™¨ç«¯å£ while(1) &#123; BEEP=0; delay_ms(300);//å»¶æ—¶300ms BEEP=1; delay_ms(300);//å»¶æ—¶300ms &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ é—²è°ˆ ç« èŠ‚ç›®çš„ æœ¬ç« ä¸»è¦æ˜¯ç†Ÿæ‚‰åŸºç¡€ GPIO ç«¯å£çš„é©±åŠ¨ï¼Œä¾æ—§æ˜¯ç«¯å£è¾“å‡ºã€‚ ç¨‹åºæ®µåˆ†æ å¯¹ç«¯å£çš„é©±åŠ¨ï¼Œè¿™é‡Œä¹Ÿæ˜¯ä¸€èˆ¬IOçš„è¾“å‡ºï¼Œç›¸å¯¹äºä¸Šä¸€ç« èŠ‚ ï¼Œåœ¨é€»è¾‘æ§åˆ¶ä¸ŠåŸºæœ¬æ— å·®å¼‚ã€‚ å…³äºä¸‰æç®¡çš„å°çŸ¥è¯† è¯¦æƒ…å¯è§S8050ä¸‰æç®¡å™¨ä»¶ çŸ¥è¯†ç‚¹æ‰€è¿°ã€‚","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ11ï¼‰æ¥å£UART RS485é©±åŠ¨","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-011","date":"2022-11-07T22:59:18.000Z","updated":"2023-04-05T04:12:35.860Z","comments":true,"path":"posts/3798164979.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3798164979.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šSP3485 ï¼ˆç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸RS485ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®çš„ ä¸»è¦å®ç°ä¸²å£é€šä¿¡RS485ç”µå¹³çš„ä¼ è¾“æ•ˆæœã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input PIN_E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input PIN_M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ uart_rxd input PIN_A12 ä¸²å£æ”¶ uart_txd output PIN_B12 ä¸²å£å‘ tx_rde output PIN_A11 ä¸²å£å‘ä½¿èƒ½ç«¯ï¼Œé«˜ç”µå¹³å‘é€ï¼Œä½ç”µå¹³æ¥æ”¶ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd , output txd_rde ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (txd_rde), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule ç®¡è„šçº¦æŸï¼š 1234567#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1uart_txd, PIN_M7uart_rxd, PIN_N5 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1ns / 1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // é©±åŠ¨æ—¶é’Ÿ 50MHz ï¼Œ20ns parameter UART_BPS = 115200; // æ³¢ç‰¹ç‡ 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // å•bitä¼ è¾“è€—æ—¶ BPS_CNT ä¸ªé©±åŠ¨æ—¶é’Ÿå‘¨æœŸ initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule è¿è¡Œç»“æœï¼š æ”¶å‘æ•°æ®ï¼ˆæ•°æ®ä¸ºâ€™h5Aï¼‰ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ10ï¼‰æ¥å£UART RS232é©±åŠ¨","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-010","date":"2022-11-07T22:39:18.000Z","updated":"2023-04-05T04:12:34.266Z","comments":true,"path":"posts/4004091958.html","link":"","permalink":"https://sirius-tblog.github.io/posts/4004091958.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šCH340 ï¼ˆä¸²å£è½¬USB,ç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸USBå·®åˆ†ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®æ ‡å™¨ä»¶ï¼šSP3232 ï¼ˆç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸RS232ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®çš„ ä¸»è¦å®ç°ä¸²å£é€šä¿¡åè®®çš„ä¼ è¾“æ•ˆæœã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input PIN_E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input PIN_M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ uart_rxd input PIN_N5 ä¸²å£æ”¶ uart_txd output PIN_M7 ä¸²å£å‘ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule ç®¡è„šçº¦æŸï¼š 1234567#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1uart_txd, PIN_M7uart_rxd, PIN_N5 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1ns / 1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // é©±åŠ¨æ—¶é’Ÿ 50MHz ï¼Œ20ns parameter UART_BPS = 115200; // æ³¢ç‰¹ç‡ 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // å•bitä¼ è¾“è€—æ—¶ BPS_CNT ä¸ªé©±åŠ¨æ—¶é’Ÿå‘¨æœŸ initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule è¿è¡Œç»“æœï¼š æ”¶å‘æ•°æ®ï¼ˆæ•°æ®ä¸ºâ€™h5Aï¼‰ ç»†èŠ‚ï¼ˆBPS_CNT = CLK_FREQ/UART_BPS = 50000000/115200 = 434ï¼‰ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ9ï¼‰Altera  FIFOæ ¸åº”ç”¨","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-009","date":"2022-11-07T22:19:18.000Z","updated":"2023-04-05T04:12:32.655Z","comments":true,"path":"posts/1307021646.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1307021646.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ ç›®çš„ ä¸»è¦é€šè¿‡FIFOæ ¸ç†Ÿæ‚‰FIFOçš„è¯»å†™åŠIPæ ¸ä½¿ç”¨ã€‚ ç”µè·¯ ç•¥ FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ æ€è·¯ é…ç½®ä½å®½ {width=â€œ400pxâ€} IPé…ç½® {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//demo.vmodule demo( input sys_clk , input sys_rst_n );wire wrreq ; wire [7:0] data ; wire wrempty ; wire wrfull ; wire [7:0] wrusedw ; wire rdreq ; wire [7:0] q ; wire rdempty ; wire rdfull ; wire [7:0] rdusedw ; fifo u_fifo( .wrclk ( sys_clk ), .wrreq ( wrreq ), .data ( data ), .wrempty ( wrempty ), .wrfull ( wrfull ), .wrusedw ( wrusedw ), .rdclk ( sys_clk ), .rdreq ( rdreq ), .q ( q ), .rdempty ( rdempty ), .rdfull ( rdfull ), .rdusedw ( rdusedw ) );fifo_write u_fifo_wr( .clk (sys_clk ), .rst_n (sys_rst_n), .wrreq (wrreq ), .data (data ), .wrempty (wrempty ), .wrfull (wrfull ) );fifo_read u_fifo_rd( .clk (sys_clk ), .rst_n (sys_rst_n), .rdreq (rdreq ), .data (q ), .rdempty (rdempty ), .rdfull (rdfull ) );endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//fifo_write.vmodule fifo_write( input clk , input rst_n , input wrempty, input wrfull , output reg [7:0] data , output reg wrreq );reg [1:0] state; always @(posedge clk or negedge rst_n) begin if(!rst_n) begin wrreq &lt;= 1&#x27;b0; data &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; end else begin case(state) 2&#x27;d0: begin if(wrempty) begin wrreq &lt;= 1&#x27;b1; state &lt;= 2&#x27;d1; end else state &lt;= state; end 2&#x27;d1: begin if(wrfull) begin wrreq &lt;= 1&#x27;b0; data &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; end else begin wrreq &lt;= 1&#x27;b1; data &lt;= data + 1&#x27;d1; end end default: state &lt;= 2&#x27;d0; endcase endendendmodule 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//fifo_read.vmodule fifo_read( input clk , input rst_n , input [7:0] data , input rdfull , input rdempty, output reg rdreq );reg [7:0] data_fifo; reg [1:0] state ; always @(posedge clk or negedge rst_n) begin if(!rst_n) begin rdreq &lt;= 1&#x27;b0; data_fifo &lt;= 8&#x27;d0; end else begin case(state) 2&#x27;d0: begin if(rdfull) begin rdreq &lt;= 1&#x27;b1; state &lt;= 2&#x27;d1; end else state &lt;= state; end 2&#x27;d1: begin if(rdempty) begin rdreq &lt;= 1&#x27;b0; data_fifo &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; end else begin rdreq &lt;= 1&#x27;b1; data_fifo &lt;= data; end end default: state &lt;= 2&#x27;d0; endcase endendendmodule ç®¡è„šçº¦æŸï¼š 12345#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 1234567891011121314151617181920212223//tb_demo.v`timescale 1ns / 1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_fifo_rw ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk)); endmodule è¿è¡Œç»“æœï¼š â€œå¯åŠ¨-å¤ä½é‡Šæ”¾-å†™çŠ¶æ€æœºIDEL-å†™çŠ¶æ€æœºWRITEâ€è¿‡ç¨‹,å¯ä»¥çœ‹åˆ°ç”±ç©ºåˆ°éç©ºçŠ¶æ€ dataã€wremptyã€wrfullã€qã€rdemptyã€rdfullä¸rdusedwã€wrusedwçš„å…³ç³» â€œå†™çŠ¶æ€æœºWRITEâ€é˜¶æ®µçš„FIFOæ ¸çš„çŠ¶æ€å˜åŒ–ï¼Œå¯ä»¥çœ‹åˆ°ç”±éæ»¡åˆ°æ»¡çŠ¶æ€ dataã€wrfullã€rdfullã€qä¸rdusedwã€wrusedwçš„å…³ç³» â€œå†™çŠ¶æ€æœº-è¯»çŠ¶æ€æœºâ€è¿‡ç¨‹çš„FIFOæ ¸çš„çŠ¶æ€å˜åŒ–ï¼Œå¯ä»¥çœ‹åˆ°ç”±æ»¡åˆ°éæ»¡çŠ¶æ€ dataã€wrfullã€rdfullã€qä¸rdusedwã€wrusedwçš„å…³ç³» â€œè¯»çŠ¶æ€æœºREADâ€é˜¶æ®µçš„FIFOæ ¸çš„çŠ¶æ€å˜åŒ–ï¼Œå¯ä»¥çœ‹åˆ°ç”±éç©ºåˆ°ç©ºçŠ¶æ€ dinã€almost_emptyã€emptyä¸rd_countã€wr_countçš„å…³ç³» ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ8ï¼‰Altera  RAMæ ¸åº”ç”¨","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-008","date":"2022-11-07T21:49:18.000Z","updated":"2023-04-05T04:12:30.113Z","comments":true,"path":"posts/1379072265.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1379072265.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ ç›®çš„ ä¸»è¦é€šè¿‡RAMæ ¸ç†Ÿæ‚‰RAMçš„è¯»å†™åŠIPæ ¸ä½¿ç”¨ã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š ç•¥ FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ æ€è·¯ ä½¿ç”¨IPæ ¸æ„å»ºä½å®½ä¸º8ï¼Œæ·±åº¦ä¸º32çš„å•ç«¯å£RAMï¼Œå¹¶è¿›è¡Œè¯»å†™æµ‹è¯•ã€‚ IPé…ç½® {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1234567891011121314151617181920212223242526272829303132//demo.vmodule demo( input sys_clk, input sys_rst_n); wire ram_en; wire ram_wea; wire [4:0] ram_addr ; wire [7:0] ram_wr_data ; wire [7:0] ram_rd_data ;ram_rw inst_rw_ram ( .clk(sys_clk), .rst_n(sys_rst_n), .ram_en(ram_en), .ram_wea(ram_wea), .ram_addr(ram_addr), .ram_wr_data(ram_wr_data), .ram_rd_data(ram_rd_data) );ram_1port inst_IP_ram ( .address ( ram_addr ), .clock ( sys_clk ), .data ( ram_wr_data ), .rden ( ram_en ), .wren ( ram_wea ), .q ( ram_rd_data ) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445//ram_rw.vmodule ram_rw( input clk , input rst_n , output ram_en , output ram_wea , output reg [4:0] ram_addr , output reg [7:0] ram_wr_data, input [7:0] ram_rd_data);reg [5:0] rw_cnt ;assign ram_en = rst_n;assign ram_wea = (rw_cnt &lt;= 6&#x27;d31 &amp;&amp; ram_en == 1&#x27;b1) ? 1&#x27;b1 : 1&#x27;b0;always @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) rw_cnt &lt;= 1&#x27;b0; else if(rw_cnt == 6&#x27;d63) rw_cnt &lt;= 1&#x27;b0; else rw_cnt &lt;= rw_cnt + 1&#x27;b1;endalways @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) ram_wr_data &lt;= 1&#x27;b0; else if(rw_cnt &lt;= 6&#x27;d31) ram_wr_data &lt;= ram_wr_data + 1&#x27;b1; else ram_wr_data &lt;= 1&#x27;b0 ;endalways @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) ram_addr &lt;= 1&#x27;b0; else if(ram_addr == 5&#x27;d31) ram_addr &lt;= 1&#x27;b0; else ram_addr &lt;= ram_addr + 1&#x27;b1;endendmodule ç®¡è„šçº¦æŸï¼š 12345#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 1234567891011121314151617181920212223//tb_demo.v`timescale 1ns / 1psmodule tb_demo(); reg sys_clk; reg sys_rst_n; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_ram_rw ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk)); endmodule è¿è¡Œç»“æœï¼š å†™RAMè¿‡ç¨‹ è¯»RAMè¿‡ç¨‹ [æµ‹è¯•]åªå¯ç”¨RAMå†™ä½¿èƒ½ [æµ‹è¯•]åªå¯ç”¨RAMè¯»ä½¿èƒ½ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ6ï¼‰åŠ¨æ€æ•°ç ç®¡æ˜¾ç¤º","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-006","date":"2022-11-07T20:59:18.000Z","updated":"2023-04-05T04:11:43.006Z","comments":true,"path":"posts/1907837786.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1907837786.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ5ï¼‰é™æ€æ•°ç ç®¡æ˜¾ç¤º","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-005","date":"2022-11-07T20:49:18.000Z","updated":"2023-04-08T10:00:59.150Z","comments":true,"path":"posts/2432118836.html","link":"","permalink":"https://sirius-tblog.github.io/posts/2432118836.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ æ§åˆ¶å¯¹è±¡ï¼š8æ®µæ•°ç ç®¡ã€‚ ç›®çš„ ä¸»è¦å®ç°8æ®µæ•°ç ç®¡æ˜¾ç¤ºçš„æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ seg_led[0] output M11 æ•°ç ç®¡æ®µé€‰a seg_led[1] output N12 æ•°ç ç®¡æ®µé€‰b seg_led[2] output C9 æ•°ç ç®¡æ®µé€‰c seg_led[3] output N13 æ•°ç ç®¡æ®µé€‰d seg_led[4] output M10 æ•°ç ç®¡æ®µé€‰e seg_led[5] output N11 æ•°ç ç®¡æ®µé€‰f seg_led[6] output P11 æ•°ç ç®¡æ®µé€‰g seg_led[7] output D9 æ•°ç ç®¡æ®µé€‰h seg_sel[0] output N16 æ•°ç ç®¡ä½é€‰0 seg_sel[1] output N15 æ•°ç ç®¡ä½é€‰1 seg_sel[2] output P16 æ•°ç ç®¡ä½é€‰2 seg_sel[3] output P15 æ•°ç ç®¡ä½é€‰3 seg_sel[4] output R16 æ•°ç ç®¡ä½é€‰4 seg_sel[5] output T15 æ•°ç ç®¡ä½é€‰5 æ€è·¯ é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1234567891011121314151617181920212223242526272829303132//demo.vmodule demo( input sys_clk, input sys_rst_n, output [5:0] seg_sel, output [7:0] seg_led);parameter TIME_SHOW = 25&#x27;d25000000; //é©»ç•™æ—¶é—´wire increase_flag;seg_display_static inst_seg_display_static( .clk (sys_clk), .rstn (sys_rst_n), .seg_sel(seg_sel), .seg_led(seg_led), .increase_flag(increase_flag));time_count #(.MAX_NUM(TIME_SHOW ))inst_time_count( .clk (sys_clk), .rstn (sys_rst_n), .flag(increase_flag));endmodule æ•°ç ç®¡é™æ€é©±åŠ¨åŠæ˜¾ç¤ºæ ·å¼ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//seg_display_static.vmodule seg_display_static( input clk, input rstn, input increase_flag, output reg [5:0] seg_sel, output reg [7:0] seg_led);reg [3:0] num;//ä½é€‰é©±åŠ¨ï¼Œç¡¬ä»¶è¿æ¥ä¸­ä½ç”µå¹³é©±åŠ¨PNPä¸‰æç®¡å¯¼é€šalways @ (posedge clk or negedge rstn) begin if (!rstn) seg_sel &lt;= 6&#x27;b111111; else seg_sel &lt;= 6&#x27;b000000;endalways @ (posedge clk or negedge rstn) begin if (!rstn) num &lt;= 4&#x27;h0; else if(increase_flag) begin if(num &lt; 4&#x27;hf) num &lt;= num + 1&#x27;b1; else num &lt;= 4&#x27;h0; end else num &lt;= num;endalways @ (posedge clk or negedge rstn) begin if (!rstn) //å…¨ç‚¹äº® seg_led &lt;= 8&#x27;b0000_0000; else begin case(num) //å…±é˜³æå‹é©±åŠ¨ï¼Œä½ç”µå¹³ç‚¹äº® 4&#x27;h0 : seg_led &lt;= 8&#x27;b1100_0000;//&#x27;hC0 4&#x27;h1 : seg_led &lt;= 8&#x27;b1111_1001;//&#x27;hF9 4&#x27;h2 : seg_led &lt;= 8&#x27;b1010_0100;//&#x27;hA4 4&#x27;h3 : seg_led &lt;= 8&#x27;b1011_0000;//&#x27;hB0 4&#x27;h4 : seg_led &lt;= 8&#x27;b1001_1001;//&#x27;h99 4&#x27;h5 : seg_led &lt;= 8&#x27;b1001_0010;//&#x27;h92 4&#x27;h6 : seg_led &lt;= 8&#x27;b1000_0010;//&#x27;h82 4&#x27;h7 : seg_led &lt;= 8&#x27;b1111_1000;//&#x27;hF8 4&#x27;h8 : seg_led &lt;= 8&#x27;b1000_0000;//&#x27;h80 4&#x27;h9 : seg_led &lt;= 8&#x27;b1001_0000;//&#x27;h90 4&#x27;ha : seg_led &lt;= 8&#x27;b1000_1000;//&#x27;h88 4&#x27;hb : seg_led &lt;= 8&#x27;b1000_0011;//&#x27;h83 4&#x27;hc : seg_led &lt;= 8&#x27;b1100_0110;//&#x27;hC6 4&#x27;hd : seg_led &lt;= 8&#x27;b1010_0001;//&#x27;hA1 4&#x27;he : seg_led &lt;= 8&#x27;b1000_0110;//&#x27;h86 4&#x27;hf : seg_led &lt;= 8&#x27;b1000_1110;//&#x27;h8E default : seg_led &lt;= 8&#x27;b1100_0000;//&#x27;hC0 endcase endendendmodule å•ä¸ªæ ·å¼æ˜¾ç¤ºé©»ç•™æ—¶é•¿ 1234567891011121314151617181920212223242526272829//time_count.vmodule time_count( input clk, input rstn, output reg flag);parameter MAX_NUM = 25000000;reg [24:0] cnt;always@(posedge clk or negedge rstn)begin if (!rstn) begin flag &lt;= 1&#x27;b0; cnt &lt;= 24&#x27;d0; end else if(cnt &lt; MAX_NUM - 1&#x27;b1) begin flag &lt;= 1&#x27;b0; cnt &lt;= cnt + 1&#x27;b1; end else begin flag &lt;= 1&#x27;b1; cnt &lt;= 24&#x27;d0; endendendmodule ç®¡è„šçº¦æŸï¼š 123456789101112131415161718192021# demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1seg_sel[0], PIN_N16seg_sel[1], PIN_N15seg_sel[2], PIN_P16seg_sel[3], PIN_P15seg_sel[4], PIN_R16seg_sel[5], PIN_T15seg_led[0], PIN_M11seg_led[1], PIN_N12seg_led[2], PIN_C9seg_led[3], PIN_N13seg_led[4], PIN_M10seg_led[5], PIN_N11seg_led[6], PIN_P11seg_led[7], PIN_D9 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [7:0] seg_led; wire [5:0] seg_sel;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #20 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo #( .TIME_SHOW (25&#x27;d250) //é©»ç•™æ—¶é—´)inst_seg_display_static( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .seg_led (seg_led), .seg_sel(seg_sel));endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ7ï¼‰Altera PLLæ ¸åº”ç”¨","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-007","date":"2022-11-07T20:49:18.000Z","updated":"2023-04-05T04:12:28.309Z","comments":true,"path":"posts/3825430347.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3825430347.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ ç›®çš„ ä¸»è¦é€šè¿‡PLLè¿™ä¸€æ—¶é’ŸIPæ ¸å®ç°å¯¹å®˜æ–¹IPåº”ç”¨çš„è®¤çŸ¥ã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ clk_100M output D1 100MHzæ—¶é’Ÿ clk_100M_pd output F3 100MHzæ—¶é’Ÿ,åç›¸ clk_50M output F1 50MHzæ—¶é’Ÿ clk_25M output F2 25MHzæ—¶é’Ÿ æ€è·¯ é€šè¿‡å‚æ•°é…ç½®PLLæ ¸ï¼Œå®ç°åˆ†é¢‘å’Œå€é¢‘ä»¥åŠç›¸ä½åç§»ã€‚ IPé…ç½® å‚æ•°ï¼šå•ç«¯è¾“å…¥50MHz,ä»4è¾“å‡ºç«¯å£åˆ†åˆ«è¾“å‡º100MHzå€é¢‘é’Ÿã€åç›¸100MHzã€50MHzã€25MHzåˆ†é¢‘ã€‚ IPé›†è·¯å¾„ {width=â€œ400pxâ€} æœç´¢å¹¶é€‰ç”¨IPæ ¸ {width=â€œ400pxâ€} å‘½ååŠé€‰ç”¨ç±»å‹ {width=â€œ400pxâ€} è®¾ç½®è¾“å…¥æ—¶é’ŸåŠæ¨¡å¼ {width=â€œ400pxâ€} å¯ç”¨å¤ä½ç«¯å£åŠé”å®šçŠ¶æ€æ ‡å¿— {width=â€œ400pxâ€} æ— å…³å‚é‡ï¼Œé»˜è®¤ {width=â€œ400pxâ€} æ˜¯å¦å¢åŠ è¾“å…¥æ—¶é’Ÿï¼Œé»˜è®¤å•ç«¯è¾“å…¥ {width=â€œ400pxâ€} æ— å…³å‚é‡ï¼Œé»˜è®¤ {width=â€œ400pxâ€} ç¬¬ä¸€è·¯è¾“å‡ºæ—¶é’Ÿå‚æ•°è®¾ç½® {width=â€œ400pxâ€} ç¬¬äºŒè·¯è¾“å‡ºæ—¶é’Ÿå‚æ•°è®¾ç½® {width=â€œ400pxâ€} ç¬¬ä¸‰è·¯è¾“å‡ºæ—¶é’Ÿå‚æ•°è®¾ç½® {width=â€œ400pxâ€} ç¬¬å››è·¯è¾“å‡ºæ—¶é’Ÿå‚æ•°è®¾ç½® {width=â€œ400pxâ€} ç¬¬äº”è·¯è¾“å‡ºæ—¶é’Ÿå‚æ•°è®¾ç½®ï¼Œä¸éœ€è¦å°±ä¸å¯ç”¨ {width=â€œ400pxâ€} æ·»åŠ mifä»¿çœŸåº“,é»˜è®¤ {width=â€œ400pxâ€} äº§ç”Ÿçš„æ–‡ä»¶ï¼Œæ ¹æ®éœ€è¦é€‰æ‹© {width=â€œ400pxâ€} å°†è®¾ç½®çš„IPæ ¸ç”ŸæˆååŠ å…¥åˆ°å½“å‰å·¥ç¨‹ä¸­ {width=â€œ400pxâ€} IPåŠ å…¥åˆ°å·¥ç¨‹ä¸­ï¼ŒæŸ¥çœ‹è·¯å¾„ {width=â€œ400pxâ€} å·²æ·»åŠ IPæ ¸ç‰¹æ€§æ¦‚å†µä»¥åŠé‡é…ç½®è·¯å¾„ï¼ˆåŒå‡»è¿›å…¥å‚æ•°é…ç½®ç•Œé¢ï¼‰ {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1234567891011121314151617181920212223242526//demo.vmodule demo( input sys_clk, input sys_rst_n, output clk_100M, output clk_100M_pd, output clk_50M, output clk_25M); wire locked; clk_wiz_0 inst_IP_clock ( // Clock out ports .clk_out1(clk_100M), // output clk_out1 .clk_out2(clk_100M_pd), // output clk_out2 .clk_out3(clk_50M), // output clk_out3 .clk_out4(clk_25M), // output clk_out4 // Status and control signals .reset(!sys_rst_n), // input reset .locked(locked), // output locked // Clock in ports .clk_in1(sys_clk)); // input clk_in1endmodule ç®¡è„šçº¦æŸï¼š 12345678910#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1clk_100M, PIN_D1clk_100M_pd, PIN_F3clk_50M, PIN_F1clk_25M, PIN_F2 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 123456789101112131415161718192021222324252627282930313233//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire clk_100M; wire clk_100M_pd; wire clk_50M; wire clk_25M; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_clock_gen ( // Clock out ports .clk_100M(clk_100M), // output clk_out1 .clk_100M_pd(clk_100M_pd), // output clk_out2 .clk_50M(clk_50M), // output clk_out3 .clk_25M(clk_25M), // output clk_out4 // Status and control signals .sys_rst_n(sys_rst_n), // input reset // Clock in ports .sys_clk(sys_clk)); // input clk_in1endmodule è¿è¡Œç»“æœï¼š ä»ä»¿çœŸç»“æœä¸Šçœ‹ï¼ŒLockedæ‹‰é«˜åè¾“å‡ºæ—¶é’Ÿæ‰ç¨³å®šï¼Œä½¿ç”¨æ—¶é’ŸIPæ—¶ï¼Œåº”æ³¨æ„è¿™ä¸€ç‰¹å¾ï¼Œå¾…lockedæ‹‰èµ·æ—¶ä½¿ç”¨è¾“å‡ºçš„æ—¶é’Ÿã€‚ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ4ï¼‰è§¦æ‘¸é”®æ§ç¯","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-004","date":"2022-11-07T20:29:18.000Z","updated":"2023-04-08T10:00:36.087Z","comments":true,"path":"posts/3070638990.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3070638990.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ ç›®çš„ ä¸»è¦å®ç°è§¦æ‘¸å¼ç”µå®¹æŒ‰é”®æ§åˆ¶ç¯çš„å¼€å…³æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ led output D11 LED0ï¼Œé«˜ç”µå¹³ç‚¹äº® touch_key input F8 è§¦æ‘¸é”®ä¿¡å· æ€è·¯ é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718//demo.vmodule demo(input sys_clk,input sys_rst_n,output led,input touch_key);touch_led inst_touch_led(.clk (sys_clk),.rstn (sys_rst_n),.touch_key (touch_key),.led(led));endmodule 1234567891011121314151617181920212223242526272829303132333435//touch_led.vmodule touch_led(input clk,input rstn,input touch_key,output reg led);reg [1:0] touch_key_r;wire touch_en;//check posedgeassign touch_en = (~touch_key_r[1]) &amp; touch_key_r[0];always@(posedge clk or negedge rstn)beginif(!rstn)touch_key_r &lt;= 2&#x27;d0;elsetouch_key_r &lt;= &#123;touch_key_r[0],touch_key&#125;;end//output valuealways@(posedge clk or negedge rstn)beginif(!rstn)led &lt;= 1&#x27;b0;else if(touch_en)led &lt;= ~led;elseled &lt;= led;endendmodule ç®¡è„šçº¦æŸï¼š 1234567# demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1touch_key, PIN_F8led, PIN_D11 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo();reg sys_clk;reg sys_rst_n;wire led;reg key;initialbeginsys_clk = 1&#x27;b0;sys_rst_n = 1&#x27;b0;key = 1&#x27;b0;#20sys_rst_n = 1&#x27;b1;#30 //50ms downkey = 1&#x27;b1;#200 //250ms upkey = 1&#x27;b0;#30 //280ms downkey = 1&#x27;b1;#200 //480ms upkey = 1&#x27;b0;#30 //510ms downkey = 1&#x27;b1;#200 //710ms upkey = 1&#x27;b0;#30 //740ms downkey = 1&#x27;b1;#200 //940ms upkey = 1&#x27;b0;endalways#10 sys_clk = ~sys_clk;demo inst_touch_led(.sys_clk (sys_clk),.sys_rst_n (sys_rst_n),.touch_key (key),.led(led));endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ3ï¼‰æŒ‰é”®æ§èœ‚é¸£å™¨","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-003","date":"2022-11-07T19:59:18.000Z","updated":"2023-04-08T10:00:21.618Z","comments":true,"path":"posts/3652302925.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3652302925.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ ç›®çš„ ä¸»è¦å®ç°ç‚¹è§¦å¼æŒ‰é”®æ§åˆ¶æœ‰æºèœ‚é¸£å™¨å‘å£°æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ beep output D12 BEEPï¼Œé«˜ç”µå¹³é©±åŠ¨ key[0] input E16 KEY0ï¼Œä½ç”µå¹³æŒ‰ä¸‹ æ€è·¯ é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 12345678910111213141516171819202122232425262728293031//demo.vmodule demo( input sys_clk, input sys_rst_n, output beep, input key);wire key_value;wire key_flag;key_debounce inst_key_debounce( .clk (sys_clk), .rstn (sys_rst_n), .key (key), .key_flag (key_flag), .key_value (key_value));beep_ctrl inst_beep_ctrl( .clk (sys_clk), .rstn (sys_rst_n), .key_flag (key_flag), .key_value (key_value), .beep (beep));endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//key_debounce.vmodule key_debounce( input clk, input rstn, input key, output reg key_value, output reg key_flag);reg [31:0] delay_cnt;reg key_reg;//delay timealways@(posedge clk or negedge rstn)begin if(!rstn) begin key_reg &lt;= 1&#x27;b1; delay_cnt &lt;= 32&#x27;d0; end else begin key_reg &lt;= key; if(key_reg!=key) //in shaked delay_cnt &lt;= 32&#x27;d1000000; else if(key_reg==key) begin if(delay_cnt &gt; 32&#x27;d0) delay_cnt &lt;= delay_cnt-1&#x27;b1; else delay_cnt &lt;= delay_cnt; end endend//output valuealways@(posedge clk or negedge rstn)begin if(!rstn) begin key_flag &lt;= 1&#x27;b0; key_value &lt;= 1&#x27;b1; end else begin if(delay_cnt == 32&#x27;d1) begin key_flag &lt;= 1&#x27;b1; key_value &lt;= key; end else begin key_flag &lt;= 1&#x27;b0; key_value &lt;= key; end endendendmodule 123456789101112131415161718192021222324//beep_ctrl.vmodule beep_ctrl( input clk, input rstn, output reg beep, input key_value, input key_flag);always@(posedge clk or negedge rstn)begin if(!rstn) beep &lt;= 1&#x27;b1; else begin if(key_flag&amp;&amp;(~key_value)) beep &lt;= ~beep; else beep &lt;= beep; endendendmodule ç®¡è„šçº¦æŸ(è¡¨å¤´åˆ—å‡ºé¡¹ä¸­ï¼Œé»˜è®¤defaultå€¼åº”åœ¨ä¹‹åçš„åˆ—ä¸­ç•™ç©ºï¼Œå¦‚ä¸‹)ï¼š 1234567# demo.txtTo, Location, Current Strengthsys_clk, PIN_E1,sys_rst_n, PIN_M1,beep, PIN_D12, 12mAkey, PIN_E16, éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire beep; reg key; parameter T=1000000;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 1&#x27;b1; #20 sys_rst_n = 1&#x27;b1; #(30*T) //30ms down key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(170*T) //240ms up key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(170*T) //450ms down key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(30*T) //520ms up key = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_key_beep( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .beep (beep), .key (key));endmodule è¿è¡Œç»“æœ(è”åˆModelsimå·¥å…·)ï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ2ï¼‰æŒ‰é”®æ§ç¯","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-002","date":"2022-11-07T19:29:18.000Z","updated":"2023-04-08T09:59:57.731Z","comments":true,"path":"posts/3020230158.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3020230158.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ ç›®çš„ ä¸»è¦å®ç°ç‚¹è§¦å¼æŒ‰é”®æ§åˆ¶LEDç¯ç‚¹äº®çš„æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ led[0] output D11 LED0ï¼Œé«˜ç”µå¹³ç‚¹äº® led[1] output C11 LED1ï¼Œé«˜ç”µå¹³ç‚¹äº® led[2] output E10 LED2ï¼Œé«˜ç”µå¹³ç‚¹äº® led[3] output F9 LED3ï¼Œé«˜ç”µå¹³ç‚¹äº® key[0] input E16 KEY0ï¼Œä½ç”µå¹³æŒ‰ä¸‹ key[1] input E15 KEY1ï¼Œä½ç”µå¹³æŒ‰ä¸‹ key[2] input M2 KEY2ï¼Œä½ç”µå¹³æŒ‰ä¸‹ key[3] input M16 KEY3ï¼Œä½ç”µå¹³æŒ‰ä¸‹ æ€è·¯ é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 12345678910111213141516171819//demo.vmodule demo( input sys_clk, input sys_rst_n, output [3:0] led, input [3:0] key);key_led inst_key_led( .clk (sys_clk), .rstn (sys_rst_n), .led (led), .key (key));endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//key_led.vmodule key_led( input clk, input rstn, output reg [3:0] led, input [3:0] key);reg [23:0] cnt;reg [1:0] led_ctrl;//delayalways@(posedge clk or negedge rstn)begin if(!rstn) cnt &lt;= 24&#x27;d0; else if(cnt&lt;24&#x27;d10000000) cnt &lt;= cnt+1&#x27;b1; else cnt&lt;=24&#x27;d0;end//controlalways@(posedge clk or negedge rstn)begin if(!rstn) led_ctrl &lt;= 2&#x27;d0; else if(cnt==(24&#x27;d10000000-1&#x27;b1)) led_ctrl &lt;= led_ctrl+1&#x27;b1; else led_ctrl&lt;= led_ctrl;end//keyalways@(posedge clk or negedge rstn)begin if(!rstn) led &lt;= 4&#x27;b0000; else if(key[0]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b1000; 2&#x27;d1 : led &lt;= 4&#x27;b0100; 2&#x27;d2 : led &lt;= 4&#x27;b0010; 2&#x27;d3 : led &lt;= 4&#x27;b0001; default : led &lt;= 4&#x27;b0000; endcase else if(key[1]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b0001; 2&#x27;d1 : led &lt;= 4&#x27;b0010; 2&#x27;d2 : led &lt;= 4&#x27;b0100; 2&#x27;d3 : led &lt;= 4&#x27;b1000; default : led &lt;= 4&#x27;b0000; endcase else if(key[2]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b1111; 2&#x27;d1 : led &lt;= 4&#x27;b0000; 2&#x27;d2 : led &lt;= 4&#x27;b1111; 2&#x27;d3 : led &lt;= 4&#x27;b0000; default : led &lt;= 4&#x27;b0000; endcase else if(key[3]==1&#x27;b0) led &lt;= 4&#x27;b1111; else led &lt;= 4&#x27;b0000;endendmodule ç®¡è„šçº¦æŸï¼š 1234567891011121314#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1led[0], PIN_F9led[1], PIN_E10led[2], PIN_C11led[3], PIN_D11key[0], PIN_E16key[1], PIN_E15key[2], PIN_M2key[3], PIN_M16 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); parameter T=20; reg sys_clk; reg sys_rst_n; wire [3:0] led; reg [3:0] key;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 4&#x27;b1111; #T sys_rst_n = 1&#x27;b1; key[0] = 1&#x27;b0; //down #(40000000*T) //800 key[0] = 1&#x27;b1; //up key[1] = 1&#x27;b0; #(40000000*T) key[1] = 1&#x27;b1; key[2] = 1&#x27;b0; #(40000000*T) key[2] = 1&#x27;b1; key[3] = 1&#x27;b0; #(40000000*T) key[3] = 1&#x27;b1;endalways#(T/2) sys_clk = ~sys_clk; demo inst_key_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led), .key (key));endmodule è¿è¡Œç»“æœ(è”åˆModelsimå·¥å…·)ï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"EP4CE10 Verilogä¾‹ç¨‹ï¼ˆ1ï¼‰æµæ°´ç¯","slug":"study-ic-design/examples-fpga/ep4ce10/ep4ce10-verilog-001","date":"2022-11-07T18:29:18.000Z","updated":"2023-04-08T09:59:26.836Z","comments":true,"path":"posts/3765746710.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3765746710.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­å¼€æ‹“è€…å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šAltera EP4CE10F17C8 ã€‚ ç›®çš„ ä¸»è¦å®ç°LEDç¯æŒ‰é¡ºåºä»¥ä¸€å®šæ—¶é—´é—´éš”é€ä¸ªç‚¹äº®åŠç†„ç­çš„æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ led[0] output D11 LED0ï¼Œé«˜ç”µå¹³ç‚¹äº® led[1] output C11 LED1ï¼Œé«˜ç”µå¹³ç‚¹äº® led[2] output E10 LED2ï¼Œé«˜ç”µå¹³ç‚¹äº® led[3] output F9 LED3ï¼Œé«˜ç”µå¹³ç‚¹äº® æ€è·¯ é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1234567891011121314151617//demo.vmodule demo( input sys_clk, input sys_rst_n, output [3:0] led);flow_led inst_flow_led( .clk (sys_clk), .rstn (sys_rst_n), .led (led));endmodule 12345678910111213141516171819202122232425262728293031//flow_led.vmodule flow_led( input clk, input rstn, output reg [3:0] led);reg [25:0] cnt;always@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) cnt &lt;= 26&#x27;d0; else if(cnt&lt;26&#x27;d10000000)//200ms cnt &lt;= cnt+1&#x27;b1; else cnt = 26&#x27;d0;endalways@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) led &lt;= 4&#x27;b0001; else if(cnt==(26&#x27;d10000000-1&#x27;b1))//200ms led &lt;= &#123;led[2:0],led[3]&#125;; else led &lt;= led;endendmodule ç®¡è„šçº¦æŸï¼š 12345678910#demo.txtTo, Locationsys_clk, PIN_E1sys_rst_n, PIN_M1led[0], PIN_F9led[1], PIN_E10led[2], PIN_C11led[3], PIN_D11 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [3:0] led;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_flow_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led));endmodule è¿è¡Œç»“æœ(è”åˆModelsimå·¥å…·)ï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"}]},{"title":"STM32F1 åº“å‡½æ•°ä¾‹ç¨‹ï¼ˆ1ï¼‰è·‘é©¬ç¯","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vlibrary-001","date":"2022-11-07T18:29:18.000Z","updated":"2023-05-14T15:39:41.652Z","comments":true,"path":"posts/2499769614.html","link":"","permalink":"https://sirius-tblog.github.io/posts/2499769614.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ å¯¹é€šç”¨IOçš„åŸºç¡€æ“ä½œâ€”â€”æ§åˆ¶ç”µå¹³è¾“å‡ºï¼Œå®ç°è·‘é©¬ç¯æ ·å¼å®éªŒã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š STM32ä¸»è¦åº”ç”¨ç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ led0 output PB5 LED0é©±åŠ¨ led1 output PE5 LED1é©±åŠ¨ æ€è·¯ è°ƒç”¨å®˜æ–¹åº“æ–‡ä»¶é©±åŠ¨GPIOå£ç”µå¹³ï¼Œæ ¹æ®ç”µè·¯è¿æ¥å…³ç³»å¯çŸ¥å¦‚ä¸‹é¢„æœŸç»“æœï¼š ç«¯å£ ç”µå¹³çŠ¶æ€ ç°è±¡ è¯´æ˜ PB5 è¾“å‡ºä½ç”µå¹³ LED0ç‚¹äº® LEDä¸¤ç«¯å­˜åœ¨æ­£å‘å‹é™ï¼Œæ»¡è¶³ç‚¹äº®æ¡ä»¶ PE5 è¾“å‡ºä½ç”µå¹³ LED1ç‚¹äº® åŒä¸Š PB5 è¾“å‡ºé«˜ç”µå¹³ LED0ç†„ç­ LEDä¸¤ç«¯æ— æ­£å‘å‹é™ï¼Œä¸æ»¡è¶³ç‚¹äº®æ¡ä»¶ PE5 è¾“å‡ºé«˜ç”µå¹³ LED1ç†„ç­ åŒä¸Š é©±åŠ¨ led.c 1234567891011121314151617181920212223242526// led.c#include &quot;led.h&quot;//åˆå§‹åŒ–PB5å’ŒPE5ä¸ºè¾“å‡ºå£.å¹¶ä½¿èƒ½è¿™ä¸¤ä¸ªå£çš„æ—¶é’Ÿ //LED IOåˆå§‹åŒ–void LED_Init(void)&#123; // å®šä¹‰åˆå§‹åŒ–ç»“æ„ä½“å˜é‡ GPIO_InitTypeDef GPIO_InitStructure; // ä½¿èƒ½PB,PEç«¯å£æ—¶é’Ÿ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE, ENABLE); // PB.5 PE.5 ç«¯å£é…ç½®ï¼ˆç»“æ„ä½“å˜é‡é…å€¼ï¼‰ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //æ¨æŒ½è¾“å‡º GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IOå£é€Ÿåº¦ä¸º50MHz GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //ç»“æ„ä½“å˜é‡åˆå§‹åŒ–GPIOB.5 GPIO_SetBits(GPIOB,GPIO_Pin_5); //PB.5 åˆå§‹åŒ–è¾“å‡ºç½®é«˜ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_Init(GPIOE, &amp;GPIO_InitStructure); //ç»“æ„ä½“å˜é‡åˆå§‹åŒ–GPIOE.5 GPIO_SetBits(GPIOE,GPIO_Pin_5); //PE.5 åˆå§‹åŒ–è¾“å‡ºç½®é«˜ &#125;/******************* END OF FILE *********/ led.h 123456789101112131415// led.h#ifndef __LED_H#define __LED_H #include &quot;sys.h&quot;//LEDç«¯å£å®šä¹‰ï¼ˆä½å¸¦æ“ä½œï¼‰#define LED0 PBout(5)// PB5#define LED1 PEout(5)// PE5 //ç«¯å£åˆå§‹åŒ–å‡½æ•°å®šä¹‰å£°æ˜void LED_Init(void); #endif/******************* END OF FILE *********/ main.c 12345678910111213141516171819 #include &quot;led.h&quot; //å¼•å…¥è‡ªå®šä¹‰çš„å‡½æ•°//main.c int main(void) &#123; delay_init(); //å»¶æ—¶å‡½æ•°åˆå§‹åŒ– LED_Init(); //åˆå§‹åŒ–ä¸LEDè¿æ¥çš„ç¡¬ä»¶æ¥å£ while(1) &#123; LED0=0; LED1=1; delay_ms(300); //å»¶æ—¶300ms LED0=1; LED1=0; delay_ms(300); //å»¶æ—¶300ms &#125; &#125;/******************* END OF FILE *********/ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥ é—²è°ˆ ç« èŠ‚ç›®çš„ æœ¬ç« ä¸»è¦æ˜¯ç†Ÿæ‚‰åŸºç¡€ GPIO ç«¯å£çš„é©±åŠ¨ï¼Œæ¶‰åŠå™¨ä»¶ç‰©ç†å¼•è„šç”µå¹³å˜åŒ–ä»¥åŠé©±åŠ¨æ–¹å‘ã€æ–¹å¼ã€‚ä»¥æœ‰å½¢çš„æŒ‡ç¤ºç¯å˜åŒ–æ¥è¡¨ç°ç«¯å£ç”µå¹³çš„å˜åŒ–ï¼Œè¡¨ç°é€»è¾‘ç¨‹åºå¯¹å™¨ä»¶å¼•è„šçš„æ†ç»‘å…³ç³»ã€‚ ç¨‹åºæ®µåˆ†æ å¯¹ç«¯å£çš„é©±åŠ¨ï¼Œè¿™é‡Œä¸»è¦è¿›è¡Œå¦‚ä¸‹è®¾ç½®ï¼ˆè§ led.c ï¼‰: å¯åŠ¨ç›¸åº”ç«¯å£æ—¶é’Ÿ Clock; åˆå§‹åŒ–ç«¯é…ç½®ï¼ŒåŒ…æ‹¬â€œå…·ä½“å¼•è„š PIN_x â€ã€â€œç«¯å£æ¨¡å¼ Mode â€ã€â€œé€Ÿåº¦é…ç½® Speed â€; å°†ä¸Šè¿°é…ç½®ä½¿ç”¨å®˜æ–¹åº“å‡½æ•°è¿›è¡Œå¯¹å¯¹åº”ç«¯å£å¼•è„šè¿›è¡Œåˆå§‹åŒ–(å‡½æ•° GPIO_Init() ); å¯¹ç›¸åº”ç«¯å£å¼•è„šè¿›è¡Œåˆå§‹çŠ¶æ€å®šä¹‰ï¼Œå¦‚è¾“å‡ºé«˜ç”µå¹³ï¼ˆå‡½æ•° GPIO_SetBits() ï¼‰æˆ–ä½ç”µå‹ï¼ˆå‡½æ•° GPIO_ResetBits() ï¼‰ï¼Œè‡ªå®šä¹‰å‡½æ•°éœ€è¦è¿›è¡Œå£°æ˜å¤„ç†æ–¹å¯è·¨æ–‡ä»¶è°ƒç”¨; ä¸»å‡½æ•°ä¸­å¯¹ç«¯å£è¿›è¡Œé…ç½®é©±åŠ¨ï¼Œå¦‚å¸¸äº®ã€å¸¸æš—ã€é—ªçƒç­‰ç­‰ã€‚","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"STM32F1 å¯„å­˜å™¨ä¾‹ç¨‹ï¼ˆ1ï¼‰è·‘é©¬ç¯","slug":"study-ic-design/examples-mcu/stm32f1/stm32f1-vregister-001","date":"2022-11-07T18:29:18.000Z","updated":"2023-04-05T04:21:12.620Z","comments":true,"path":"posts/861685022.html","link":"","permalink":"https://sirius-tblog.github.io/posts/861685022.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­ç²¾è‹±å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šST STM32F103 ã€‚ ç›®çš„ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input E1 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input M1 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ æ€è·¯ é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1 1 ç®¡è„šçº¦æŸï¼š 12 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 123//tb_demo.c è¿è¡Œç»“æœ(è”åˆModelsimå·¥å…·)ï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 å¯„å­˜å™¨ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-å¯„å­˜å™¨ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%AF%84%E5%AD%98%E5%99%A8%E7%89%88/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"}]},{"title":"ã€æœªå®Œã€‘XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ25ï¼‰DDR3è¯»å†™æµ‹è¯•","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-025","date":"2022-10-29T07:35:18.000Z","updated":"2023-04-05T04:17:01.966Z","comments":true,"path":"posts/1351360347.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1351360347.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šCH340 ï¼ˆä¸²å£è½¬USB,ç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸USBå·®åˆ†ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®æ ‡å™¨ä»¶ï¼šSP3232 ï¼ˆç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸RS232ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®çš„ ä¸»è¦å®ç°ä¸²å£é€šä¿¡åè®®çš„ä¼ è¾“æ•ˆæœã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ uart_rxd input U5 ä¸²å£æ”¶ uart_txd output T6 ä¸²å£å‘ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule ç®¡è„šçº¦æŸï¼š 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // é©±åŠ¨æ—¶é’Ÿ 50MHz ï¼Œ20ns parameter UART_BPS = 115200; // æ³¢ç‰¹ç‡ 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // å•bitä¼ è¾“è€—æ—¶ BPS_CNT ä¸ªé©±åŠ¨æ—¶é’Ÿå‘¨æœŸ initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"ã€æœªå®Œã€‘XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ24ï¼‰USBé€šä¿¡å®éªŒ","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-024","date":"2022-10-29T06:35:18.000Z","updated":"2023-04-05T04:16:58.349Z","comments":true,"path":"posts/3799897035.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3799897035.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šCH340 ï¼ˆä¸²å£è½¬USB,ç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸USBå·®åˆ†ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®æ ‡å™¨ä»¶ï¼šSP3232 ï¼ˆç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸RS232ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®çš„ ä¸»è¦å®ç°ä¸²å£é€šä¿¡åè®®çš„ä¼ è¾“æ•ˆæœã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ uart_rxd input U5 ä¸²å£æ”¶ uart_txd output T6 ä¸²å£å‘ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule ç®¡è„šçº¦æŸï¼š 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // é©±åŠ¨æ—¶é’Ÿ 50MHz ï¼Œ20ns parameter UART_BPS = 115200; // æ³¢ç‰¹ç‡ 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // å•bitä¼ è¾“è€—æ—¶ BPS_CNT ä¸ªé©±åŠ¨æ—¶é’Ÿå‘¨æœŸ initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"ã€æœªå®Œã€‘XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ23ï¼‰åŒè·¯é«˜é€ŸADå®éªŒ","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-023","date":"2022-10-29T05:35:18.000Z","updated":"2023-04-05T04:16:55.252Z","comments":true,"path":"posts/640324073.html","link":"","permalink":"https://sirius-tblog.github.io/posts/640324073.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šCH340 ï¼ˆä¸²å£è½¬USB,ç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸USBå·®åˆ†ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®æ ‡å™¨ä»¶ï¼šSP3232 ï¼ˆç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸RS232ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®çš„ ä¸»è¦å®ç°ä¸²å£é€šä¿¡åè®®çš„ä¼ è¾“æ•ˆæœã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ uart_rxd input U5 ä¸²å£æ”¶ uart_txd output T6 ä¸²å£å‘ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule ç®¡è„šçº¦æŸï¼š 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // é©±åŠ¨æ—¶é’Ÿ 50MHz ï¼Œ20ns parameter UART_BPS = 115200; // æ³¢ç‰¹ç‡ 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // å•bitä¼ è¾“è€—æ—¶ BPS_CNT ä¸ªé©±åŠ¨æ—¶é’Ÿå‘¨æœŸ initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"ã€æœªå®Œã€‘XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ22ï¼‰åŒè·¯é«˜é€ŸDAå®éªŒ","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-022","date":"2022-10-29T04:35:18.000Z","updated":"2023-04-05T04:16:52.418Z","comments":true,"path":"posts/3185038605.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3185038605.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šCH340 ï¼ˆä¸²å£è½¬USB,ç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸USBå·®åˆ†ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®æ ‡å™¨ä»¶ï¼šSP3232 ï¼ˆç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸RS232ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®çš„ ä¸»è¦å®ç°ä¸²å£é€šä¿¡åè®®çš„ä¼ è¾“æ•ˆæœã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ uart_rxd input U5 ä¸²å£æ”¶ uart_txd output T6 ä¸²å£å‘ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule ç®¡è„šçº¦æŸï¼š 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // é©±åŠ¨æ—¶é’Ÿ 50MHz ï¼Œ20ns parameter UART_BPS = 115200; // æ³¢ç‰¹ç‡ 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // å•bitä¼ è¾“è€—æ—¶ BPS_CNT ä¸ªé©±åŠ¨æ—¶é’Ÿå‘¨æœŸ initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"ã€æœªå®Œã€‘XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ21ï¼‰é«˜é€ŸAD/DAå®éªŒ","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-021","date":"2022-10-29T03:35:18.000Z","updated":"2023-04-05T04:16:48.719Z","comments":true,"path":"posts/2112430596.html","link":"","permalink":"https://sirius-tblog.github.io/posts/2112430596.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šCH340 ï¼ˆä¸²å£è½¬USB,ç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸USBå·®åˆ†ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®æ ‡å™¨ä»¶ï¼šSP3232 ï¼ˆç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸RS232ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®çš„ ä¸»è¦å®ç°ä¸²å£é€šä¿¡åè®®çš„ä¼ è¾“æ•ˆæœã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ uart_rxd input U5 ä¸²å£æ”¶ uart_txd output T6 ä¸²å£å‘ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule ç®¡è„šçº¦æŸï¼š 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // é©±åŠ¨æ—¶é’Ÿ 50MHz ï¼Œ20ns parameter UART_BPS = 115200; // æ³¢ç‰¹ç‡ 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // å•bitä¼ è¾“è€—æ—¶ BPS_CNT ä¸ªé©±åŠ¨æ—¶é’Ÿå‘¨æœŸ initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"ã€æœªå®Œã€‘XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ19ï¼‰RTCå®æ—¶æ—¶é’Ÿ","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-019","date":"2022-10-29T02:35:18.000Z","updated":"2023-04-05T04:16:45.269Z","comments":true,"path":"posts/4222622403.html","link":"","permalink":"https://sirius-tblog.github.io/posts/4222622403.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šPCF8563 ï¼ˆå·¥ä¸šçº§å¤šåŠŸèƒ½æ—¶é’Ÿ/æ—¥å†èŠ¯ç‰‡ï¼‰ {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} ç›®çš„ ä¸»è¦å®ç°ä¸²å£é€šä¿¡åè®®çš„ä¼ è¾“æ•ˆæœã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ iic_scl output R6 æ—¶é’Ÿçº¿ iic_sda inout T4 æ•°æ®çº¿ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule ç®¡è„šçº¦æŸï¼š 12345#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN R6 IOSTANDARD LVCMOS33&#125; [get_ports iic_scl] set_property -dict &#123;PACKAGE_PIN T4 IOSTANDARD LVCMOS33&#125; [get_ports iic_sda] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // é©±åŠ¨æ—¶é’Ÿ 50MHz ï¼Œ20ns parameter UART_BPS = 115200; // æ³¢ç‰¹ç‡ 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // å•bitä¼ è¾“è€—æ—¶ BPS_CNT ä¸ªé©±åŠ¨æ—¶é’Ÿå‘¨æœŸ initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"ã€æœªå®Œã€‘XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ18ï¼‰EEPROMè¯»å†™æµ‹è¯•","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-018","date":"2022-10-29T01:35:18.000Z","updated":"2023-04-05T04:16:41.676Z","comments":true,"path":"posts/1648067106.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1648067106.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šAT24C64 ï¼ˆ64Kbitå­˜å‚¨å®¹é‡EEPROMï¼‰ã€‚ {width=â€œ400pxâ€} ###ä¸»è¦å‚æ•° 1.æ¥å£æ€»çº¿ç‰©ç†æ ·å¼ {width=â€œ400pxâ€} 2.æ¥å£åè®®æ—¶åº 3.å™¨ä»¶åœ°å€æ ¼å¼ 4.å†™æ—¶åº 5.è¯»æ—¶åº ç›®çš„ ä¸»è¦å®ç°è®¿é—®EEPROMå­˜å‚¨å™¨ã€‚ EEPROMæ˜¯ä¸€ç§ç”¨äºè®¡ç®—æœºç³»ç»Ÿå¾—éæ˜“å¤±æ€§å­˜å‚¨å™¨å­˜å‚¨ï¼ŒAT24C64é‡‡ç”¨ä¸¤çº¿ä¸²è¡Œæ¥å£çš„åŒå‘æ•°æ®ä¼ è¾“åè®®â€”â€”I2Cåè®®å®ç°è¯»å†™æ“ä½œã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ iic_scl output R6 æ—¶é’Ÿçº¿ iic_sda inout T4 æ•°æ®çº¿ led output R2 LEDæŒ‡ç¤ºç¯ æ€è·¯ {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//demo.vmodule demo( input sys_clk , //ç³»ç»Ÿæ—¶é’Ÿ input sys_rst_n , //ç³»ç»Ÿå¤ä½ //eeprom interface output iic_scl , //eepromçš„æ—¶é’Ÿçº¿scl inout iic_sda , //eepromçš„æ•°æ®çº¿sda //user interface output led //ledæ˜¾ç¤º);//parameter defineparameter SLAVE_ADDR = 7&#x27;b1010000 ; //å™¨ä»¶åœ°å€(SLAVE_ADDR)parameter BIT_CTRL = 1&#x27;b1 ; //å­—åœ°å€ä½æ§åˆ¶å‚æ•°(16b/8b)parameter CLK_FREQ = 26&#x27;d50_000_000; //i2c_driæ¨¡å—çš„é©±åŠ¨æ—¶é’Ÿé¢‘ç‡(CLK_FREQ)parameter I2C_FREQ = 18&#x27;d250_000 ; //I2Cçš„SCLæ—¶é’Ÿé¢‘ç‡parameter L_TIME = 17&#x27;d125_000 ; //ledé—ªçƒæ—¶é—´å‚æ•°//wire definewire dri_clk ; //I2Cæ“ä½œæ—¶é’Ÿwire i2c_exec ; //I2Cè§¦å‘æ§åˆ¶wire [15:0] i2c_addr ; //I2Cæ“ä½œåœ°å€wire [ 7:0] i2c_data_w; //I2Cå†™å…¥çš„æ•°æ®wire i2c_done ; //I2Cæ“ä½œç»“æŸæ ‡å¿—wire i2c_ack ; //I2Cåº”ç­”æ ‡å¿— 0:åº”ç­” 1:æœªåº”ç­”wire i2c_rh_wl ; //I2Cè¯»å†™æ§åˆ¶wire [ 7:0] i2c_data_r; //I2Cè¯»å‡ºçš„æ•°æ®wire rw_done ; //E2PROMè¯»å†™æµ‹è¯•å®Œæˆwire rw_result ; //E2PROMè¯»å†™æµ‹è¯•ç»“æœ 0:å¤±è´¥ 1:æˆåŠŸ //e2promè¯»å†™æµ‹è¯•æ¨¡å—e2prom_rw u_e2prom_rw( .clk (dri_clk ), //æ—¶é’Ÿä¿¡å· .rst_n (sys_rst_n ), //å¤ä½ä¿¡å· //i2c interface .i2c_exec (i2c_exec ), //I2Cè§¦å‘æ‰§è¡Œä¿¡å· .i2c_rh_wl (i2c_rh_wl ), //I2Cè¯»å†™æ§åˆ¶ä¿¡å· .i2c_addr (i2c_addr ), //I2Cå™¨ä»¶å†…åœ°å€ .i2c_data_w (i2c_data_w), //I2Cè¦å†™çš„æ•°æ® .i2c_data_r (i2c_data_r), //I2Cè¯»å‡ºçš„æ•°æ® .i2c_done (i2c_done ), //I2Cä¸€æ¬¡æ“ä½œå®Œæˆ .i2c_ack (i2c_ack ), //I2Cåº”ç­”æ ‡å¿— //user interface .rw_done (rw_done ), //E2PROMè¯»å†™æµ‹è¯•å®Œæˆ .rw_result (rw_result ) //E2PROMè¯»å†™æµ‹è¯•ç»“æœ 0:å¤±è´¥ 1:æˆåŠŸ);//i2cé©±åŠ¨æ¨¡å—i2c_driver #( .SLAVE_ADDR (SLAVE_ADDR), //EEPROMä»æœºåœ°å€ .CLK_FREQ (CLK_FREQ ), //æ¨¡å—è¾“å…¥çš„æ—¶é’Ÿé¢‘ç‡ .I2C_FREQ (I2C_FREQ ) //IIC_SCLçš„æ—¶é’Ÿé¢‘ç‡) u_i2c_driver( .clk (sys_clk ), .rst_n (sys_rst_n ), //i2c interface .i2c_exec (i2c_exec ), //I2Cè§¦å‘æ‰§è¡Œä¿¡å· .bit_ctrl (BIT_CTRL ), //å™¨ä»¶åœ°å€ä½æ§åˆ¶(16b/8b) .i2c_rh_wl (i2c_rh_wl ), //I2Cè¯»å†™æ§åˆ¶ä¿¡å· .i2c_addr (i2c_addr ), //I2Cå™¨ä»¶å†…åœ°å€ .i2c_data_w (i2c_data_w), //I2Cè¦å†™çš„æ•°æ® .i2c_data_r (i2c_data_r), //I2Cè¯»å‡ºçš„æ•°æ® .i2c_done (i2c_done ), //I2Cä¸€æ¬¡æ“ä½œå®Œæˆ .i2c_ack (i2c_ack ), //I2Cåº”ç­”æ ‡å¿— .scl (iic_scl ), //I2Cçš„SCLæ—¶é’Ÿä¿¡å· .sda (iic_sda ), //I2Cçš„SDAä¿¡å· //user interface .dri_clk (dri_clk ) //I2Cæ“ä½œæ—¶é’Ÿ);//ledæŒ‡ç¤ºæ¨¡å—led_alarm #(.L_TIME(L_TIME ) //æ§åˆ¶ledé—ªçƒæ—¶é—´) u_led_alarm( .clk (dri_clk ), .rst_n (sys_rst_n ), .rw_done (rw_done ), .rw_result (rw_result ), .led (led ) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496// i2c_driver.vmodule i2c_driver #( parameter SLAVE_ADDR = 7&#x27;b1010000 , //EEPROMä»æœºåœ°å€ parameter CLK_FREQ = 26&#x27;d50_000_000, //æ¨¡å—è¾“å…¥çš„æ—¶é’Ÿé¢‘ç‡ parameter I2C_FREQ = 18&#x27;d250_000 //IIC_SCLçš„æ—¶é’Ÿé¢‘ç‡ ) ( input clk , input rst_n , //i2c interface input i2c_exec , //I2Cè§¦å‘æ‰§è¡Œä¿¡å· input bit_ctrl , //å­—åœ°å€ä½æ§åˆ¶(16b/8b) input i2c_rh_wl , //I2Cè¯»å†™æ§åˆ¶ä¿¡å· input [15:0] i2c_addr , //I2Cå™¨ä»¶å†…åœ°å€ input [ 7:0] i2c_data_w , //I2Cè¦å†™çš„æ•°æ® output reg [ 7:0] i2c_data_r , //I2Cè¯»å‡ºçš„æ•°æ® output reg i2c_done , //I2Cä¸€æ¬¡æ“ä½œå®Œæˆ output reg i2c_ack , //I2Cåº”ç­”æ ‡å¿— 0:åº”ç­” 1:æœªåº”ç­” output reg scl , //I2Cçš„SCLæ—¶é’Ÿä¿¡å· inout sda , //I2Cçš„SDAä¿¡å· //user interface output reg dri_clk //é©±åŠ¨I2Cæ“ä½œçš„é©±åŠ¨æ—¶é’Ÿ );//localparam definelocalparam st_idle = 8&#x27;b0000_0001; //ç©ºé—²çŠ¶æ€localparam st_sladdr = 8&#x27;b0000_0010; //å‘é€å™¨ä»¶åœ°å€(slave address)localparam st_addr16 = 8&#x27;b0000_0100; //å‘é€16ä½å­—åœ°å€localparam st_addr8 = 8&#x27;b0000_1000; //å‘é€8ä½å­—åœ°å€localparam st_data_wr = 8&#x27;b0001_0000; //å†™æ•°æ®(8 bit)localparam st_addr_rd = 8&#x27;b0010_0000; //å‘é€å™¨ä»¶åœ°å€è¯»localparam st_data_rd = 8&#x27;b0100_0000; //è¯»æ•°æ®(8 bit)localparam st_stop = 8&#x27;b1000_0000; //ç»“æŸI2Cæ“ä½œ//reg definereg sda_dir ; //I2Cæ•°æ®(SDA)æ–¹å‘æ§åˆ¶reg sda_out ; //SDAè¾“å‡ºä¿¡å·reg st_done ; //çŠ¶æ€ç»“æŸreg wr_flag ; //å†™æ ‡å¿—reg [ 6:0] cnt ; //è®¡æ•°reg [ 7:0] cur_state ; //çŠ¶æ€æœºå½“å‰çŠ¶æ€reg [ 7:0] next_state; //çŠ¶æ€æœºä¸‹ä¸€çŠ¶æ€reg [15:0] addr_t ; //åœ°å€reg [ 7:0] data_r ; //è¯»å–çš„æ•°æ®reg [ 7:0] data_wr_t ; //I2Céœ€å†™çš„æ•°æ®çš„ä¸´æ—¶å¯„å­˜reg [ 9:0] clk_cnt ; //åˆ†é¢‘æ—¶é’Ÿè®¡æ•°//wire definewire sda_in ; //SDAè¾“å…¥ä¿¡å·wire [8:0] clk_divide ; //æ¨¡å—é©±åŠ¨æ—¶é’Ÿçš„åˆ†é¢‘ç³»æ•°//SDAæ§åˆ¶assign sda = sda_dir ? sda_out : 1&#x27;bz; //SDAæ•°æ®è¾“å‡ºæˆ–é«˜é˜»assign sda_in = sda ; //SDAæ•°æ®è¾“å…¥assign clk_divide = (CLK_FREQ/I2C_FREQ) &gt;&gt; 2&#x27;d2;//æ¨¡å—é©±åŠ¨æ—¶é’Ÿçš„åˆ†é¢‘ç³»æ•°//ç”ŸæˆI2Cçš„SCLçš„å››å€é¢‘ç‡çš„é©±åŠ¨æ—¶é’Ÿç”¨äºé©±åŠ¨i2cçš„æ“ä½œalways @(posedge clk or negedge rst_n) begin if(!rst_n) begin dri_clk &lt;= 1&#x27;b0; clk_cnt &lt;= 10&#x27;d0; end else if(clk_cnt == clk_divide[8:1] - 1&#x27;d1) begin clk_cnt &lt;= 10&#x27;d0; dri_clk &lt;= ~dri_clk; end else clk_cnt &lt;= clk_cnt + 1&#x27;b1;end//(ä¸‰æ®µå¼çŠ¶æ€æœº)åŒæ­¥æ—¶åºæè¿°çŠ¶æ€è½¬ç§»always @(posedge dri_clk or negedge rst_n) begin if(!rst_n) cur_state &lt;= st_idle; else cur_state &lt;= next_state;end//ç»„åˆé€»è¾‘åˆ¤æ–­çŠ¶æ€è½¬ç§»æ¡ä»¶always @(*) begin next_state = st_idle; case(cur_state) st_idle: begin //ç©ºé—²çŠ¶æ€ if(i2c_exec) begin next_state = st_sladdr; end else next_state = st_idle; end st_sladdr: begin if(st_done) begin if(bit_ctrl) //åˆ¤æ–­æ˜¯16ä½è¿˜æ˜¯8ä½å­—åœ°å€ next_state = st_addr16; else next_state = st_addr8 ; end else next_state = st_sladdr; end st_addr16: begin //å†™16ä½å­—åœ°å€ if(st_done) begin next_state = st_addr8; end else begin next_state = st_addr16; end end st_addr8: begin //8ä½å­—åœ°å€ if(st_done) begin if(wr_flag==1&#x27;b0) //è¯»å†™åˆ¤æ–­ next_state = st_data_wr; else next_state = st_addr_rd; end else begin next_state = st_addr8; end end st_data_wr: begin //å†™æ•°æ®(8 bit) if(st_done) next_state = st_stop; else next_state = st_data_wr; end st_addr_rd: begin //å†™åœ°å€ä»¥è¿›è¡Œè¯»æ•°æ® if(st_done) begin next_state = st_data_rd; end else begin next_state = st_addr_rd; end end st_data_rd: begin //è¯»å–æ•°æ®(8 bit) if(st_done) next_state = st_stop; else next_state = st_data_rd; end st_stop: begin //ç»“æŸI2Cæ“ä½œ if(st_done) next_state = st_idle; else next_state = st_stop ; end default: next_state= st_idle; endcaseend//æ—¶åºç”µè·¯æè¿°çŠ¶æ€è¾“å‡ºalways @(posedge dri_clk or negedge rst_n) begin //å¤ä½åˆå§‹åŒ– if(!rst_n) begin scl &lt;= 1&#x27;b1; sda_out &lt;= 1&#x27;b1; sda_dir &lt;= 1&#x27;b1; i2c_done &lt;= 1&#x27;b0; i2c_ack &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; st_done &lt;= 1&#x27;b0; data_r &lt;= 1&#x27;b0; i2c_data_r&lt;= 1&#x27;b0; wr_flag &lt;= 1&#x27;b0; addr_t &lt;= 1&#x27;b0; data_wr_t &lt;= 1&#x27;b0; end else begin st_done &lt;= 1&#x27;b0 ; cnt &lt;= cnt +1&#x27;b1 ; case(cur_state) st_idle: begin //ç©ºé—²çŠ¶æ€ scl &lt;= 1&#x27;b1; sda_out &lt;= 1&#x27;b1; sda_dir &lt;= 1&#x27;b1; i2c_done&lt;= 1&#x27;b0; cnt &lt;= 7&#x27;b0; if(i2c_exec) begin wr_flag &lt;= i2c_rh_wl ; addr_t &lt;= i2c_addr ; data_wr_t &lt;= i2c_data_w; i2c_ack &lt;= 1&#x27;b0; end end st_sladdr: begin //å†™åœ°å€(å™¨ä»¶åœ°å€å’Œå­—åœ°å€) case(cnt) 7&#x27;d1 : sda_out &lt;= 1&#x27;b0; //å¼€å§‹I2C 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= SLAVE_ADDR[6]; //ä¼ é€å™¨ä»¶åœ°å€ 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= SLAVE_ADDR[5]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= SLAVE_ADDR[4]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= SLAVE_ADDR[3]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= SLAVE_ADDR[2]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= SLAVE_ADDR[1]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= SLAVE_ADDR[0]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: sda_out &lt;= 1&#x27;b0; //0:å†™ 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d35: scl &lt;= 1&#x27;b0; 7&#x27;d36: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d37: scl &lt;= 1&#x27;b1; 7&#x27;d38: begin //ä»æœºåº”ç­” st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //é«˜ç”µå¹³è¡¨ç¤ºæœªåº”ç­” i2c_ack &lt;= 1&#x27;b1; //æ‹‰é«˜åº”ç­”æ ‡å¿—ä½ end 7&#x27;d39: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_addr16: begin case(cnt) 7&#x27;d0 : begin sda_dir &lt;= 1&#x27;b1 ; sda_out &lt;= addr_t[15]; //ä¼ é€å­—åœ°å€ end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= addr_t[14]; 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= addr_t[13]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= addr_t[12]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= addr_t[11]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= addr_t[10]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= addr_t[9]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= addr_t[8]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d34: begin //ä»æœºåº”ç­” st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //é«˜ç”µå¹³è¡¨ç¤ºæœªåº”ç­” i2c_ack &lt;= 1&#x27;b1; //æ‹‰é«˜åº”ç­”æ ‡å¿—ä½ end 7&#x27;d35: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_addr8: begin case(cnt) 7&#x27;d0: begin sda_dir &lt;= 1&#x27;b1 ; sda_out &lt;= addr_t[7]; //å­—åœ°å€ end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= addr_t[6]; 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= addr_t[5]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= addr_t[4]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= addr_t[3]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= addr_t[2]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= addr_t[1]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= addr_t[0]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d34: begin //ä»æœºåº”ç­” st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //é«˜ç”µå¹³è¡¨ç¤ºæœªåº”ç­” i2c_ack &lt;= 1&#x27;b1; //æ‹‰é«˜åº”ç­”æ ‡å¿—ä½ end 7&#x27;d35: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_data_wr: begin //å†™æ•°æ®(8 bit) case(cnt) 7&#x27;d0: begin sda_out &lt;= data_wr_t[7]; //I2Cå†™8ä½æ•°æ® sda_dir &lt;= 1&#x27;b1; end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= data_wr_t[6]; 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= data_wr_t[5]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= data_wr_t[4]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= data_wr_t[3]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= data_wr_t[2]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= data_wr_t[1]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= data_wr_t[0]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d34: begin //ä»æœºåº”ç­” st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //é«˜ç”µå¹³è¡¨ç¤ºæœªåº”ç­” i2c_ack &lt;= 1&#x27;b1; //æ‹‰é«˜åº”ç­”æ ‡å¿—ä½ end 7&#x27;d35: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_addr_rd: begin //å†™åœ°å€ä»¥è¿›è¡Œè¯»æ•°æ® case(cnt) 7&#x27;d0 : begin sda_dir &lt;= 1&#x27;b1; sda_out &lt;= 1&#x27;b1; end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d2 : sda_out &lt;= 1&#x27;b0; //é‡æ–°å¼€å§‹ 7&#x27;d3 : scl &lt;= 1&#x27;b0; 7&#x27;d4 : sda_out &lt;= SLAVE_ADDR[6]; //ä¼ é€å™¨ä»¶åœ°å€ 7&#x27;d5 : scl &lt;= 1&#x27;b1; 7&#x27;d7 : scl &lt;= 1&#x27;b0; 7&#x27;d8 : sda_out &lt;= SLAVE_ADDR[5]; 7&#x27;d9 : scl &lt;= 1&#x27;b1; 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d12: sda_out &lt;= SLAVE_ADDR[4]; 7&#x27;d13: scl &lt;= 1&#x27;b1; 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d16: sda_out &lt;= SLAVE_ADDR[3]; 7&#x27;d17: scl &lt;= 1&#x27;b1; 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d20: sda_out &lt;= SLAVE_ADDR[2]; 7&#x27;d21: scl &lt;= 1&#x27;b1; 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d24: sda_out &lt;= SLAVE_ADDR[1]; 7&#x27;d25: scl &lt;= 1&#x27;b1; 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d28: sda_out &lt;= SLAVE_ADDR[0]; 7&#x27;d29: scl &lt;= 1&#x27;b1; 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: sda_out &lt;= 1&#x27;b1; //1:è¯» 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d35: scl &lt;= 1&#x27;b0; 7&#x27;d36: begin sda_dir &lt;= 1&#x27;b0; sda_out &lt;= 1&#x27;b1; end 7&#x27;d37: scl &lt;= 1&#x27;b1; 7&#x27;d38: begin //ä»æœºåº”ç­” st_done &lt;= 1&#x27;b1; if(sda_in == 1&#x27;b1) //é«˜ç”µå¹³è¡¨ç¤ºæœªåº”ç­” i2c_ack &lt;= 1&#x27;b1; //æ‹‰é«˜åº”ç­”æ ‡å¿—ä½ end 7&#x27;d39: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; end default : ; endcase end st_data_rd: begin //è¯»å–æ•°æ®(8 bit) case(cnt) 7&#x27;d0: sda_dir &lt;= 1&#x27;b0; 7&#x27;d1: begin data_r[7] &lt;= sda_in; scl &lt;= 1&#x27;b1; end 7&#x27;d3: scl &lt;= 1&#x27;b0; 7&#x27;d5: begin data_r[6] &lt;= sda_in ; scl &lt;= 1&#x27;b1 ; end 7&#x27;d7: scl &lt;= 1&#x27;b0; 7&#x27;d9: begin data_r[5] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d11: scl &lt;= 1&#x27;b0; 7&#x27;d13: begin data_r[4] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d15: scl &lt;= 1&#x27;b0; 7&#x27;d17: begin data_r[3] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d19: scl &lt;= 1&#x27;b0; 7&#x27;d21: begin data_r[2] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d23: scl &lt;= 1&#x27;b0; 7&#x27;d25: begin data_r[1] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d27: scl &lt;= 1&#x27;b0; 7&#x27;d29: begin data_r[0] &lt;= sda_in; scl &lt;= 1&#x27;b1 ; end 7&#x27;d31: scl &lt;= 1&#x27;b0; 7&#x27;d32: begin sda_dir &lt;= 1&#x27;b1; sda_out &lt;= 1&#x27;b1; end 7&#x27;d33: scl &lt;= 1&#x27;b1; 7&#x27;d34: st_done &lt;= 1&#x27;b1; //éåº”ç­” 7&#x27;d35: begin scl &lt;= 1&#x27;b0; cnt &lt;= 1&#x27;b0; i2c_data_r &lt;= data_r; end default : ; endcase end st_stop: begin //ç»“æŸI2Cæ“ä½œ case(cnt) 7&#x27;d0: begin sda_dir &lt;= 1&#x27;b1; //ç»“æŸI2C sda_out &lt;= 1&#x27;b0; end 7&#x27;d1 : scl &lt;= 1&#x27;b1; 7&#x27;d3 : sda_out &lt;= 1&#x27;b1; 7&#x27;d15: st_done &lt;= 1&#x27;b1; 7&#x27;d16: begin cnt &lt;= 1&#x27;b0; i2c_done &lt;= 1&#x27;b1; //å‘ä¸Šå±‚æ¨¡å—ä¼ é€’I2Cç»“æŸä¿¡å· end default : ; endcase end endcase endendendmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// e2prom_rw.vmodule e2prom_rw( input clk , //æ—¶é’Ÿä¿¡å· input rst_n , //å¤ä½ä¿¡å· //i2c interface output reg i2c_rh_wl , //I2Cè¯»å†™æ§åˆ¶ä¿¡å· output reg i2c_exec , //I2Cè§¦å‘æ‰§è¡Œä¿¡å· output reg [15:0] i2c_addr , //I2Cå™¨ä»¶å†…åœ°å€ output reg [ 7:0] i2c_data_w , //I2Cè¦å†™çš„æ•°æ® input [ 7:0] i2c_data_r , //I2Cè¯»å‡ºçš„æ•°æ® input i2c_done , //I2Cä¸€æ¬¡æ“ä½œå®Œæˆ input i2c_ack , //I2Cåº”ç­”æ ‡å¿— //user interface output reg rw_done , //E2PROMè¯»å†™æµ‹è¯•å®Œæˆ output reg rw_result //E2PROMè¯»å†™æµ‹è¯•ç»“æœ 0:å¤±è´¥ 1:æˆåŠŸ);//parameter define//EEPROMå†™æ•°æ®éœ€è¦æ·»åŠ é—´éš”æ—¶é—´,è¯»æ•°æ®åˆ™ä¸éœ€è¦parameter WR_WAIT_TIME = 14&#x27;d5000; //å†™å…¥é—´éš”æ—¶é—´parameter MAX_BYTE = 16&#x27;d256 ; //è¯»å†™æµ‹è¯•çš„å­—èŠ‚ä¸ªæ•°//reg definereg [1:0] flow_cnt ; //çŠ¶æ€æµæ§åˆ¶reg [13:0] wait_cnt ; //å»¶æ—¶è®¡æ•°å™¨//EEPROMè¯»å†™æµ‹è¯•,å…ˆå†™åè¯»ï¼Œå¹¶æ¯”è¾ƒè¯»å‡ºçš„å€¼ä¸å†™å…¥çš„å€¼æ˜¯å¦ä¸€è‡´always @(posedge clk or negedge rst_n) begin if(!rst_n) begin flow_cnt &lt;= 2&#x27;b0; i2c_rh_wl &lt;= 1&#x27;b0; i2c_exec &lt;= 1&#x27;b0; i2c_addr &lt;= 16&#x27;b0; i2c_data_w &lt;= 8&#x27;b0; wait_cnt &lt;= 14&#x27;b0; rw_done &lt;= 1&#x27;b0; rw_result &lt;= 1&#x27;b0; end else begin i2c_exec &lt;= 1&#x27;b0; rw_done &lt;= 1&#x27;b0; case(flow_cnt) 2&#x27;d0 : begin wait_cnt &lt;= wait_cnt + 1&#x27;b1; //å»¶æ—¶è®¡æ•° if(wait_cnt == WR_WAIT_TIME - 1&#x27;b1) begin //EEPROMå†™æ“ä½œå»¶æ—¶å®Œæˆ wait_cnt &lt;= 1&#x27;b0; if(i2c_addr == MAX_BYTE) begin //256ä¸ªå­—èŠ‚å†™å…¥å®Œæˆ i2c_addr &lt;= 1&#x27;b0; i2c_rh_wl &lt;= 1&#x27;b1; flow_cnt &lt;= 2&#x27;d2; end else begin flow_cnt &lt;= flow_cnt + 1&#x27;b1; i2c_exec &lt;= 1&#x27;b1; end end end 2&#x27;d1 : begin if(i2c_done == 1&#x27;b1) begin //EEPROMå•æ¬¡å†™å…¥å®Œæˆ flow_cnt &lt;= 2&#x27;d0; i2c_addr &lt;= i2c_addr + 1&#x27;b1; //åœ°å€0~255åˆ†åˆ«å†™å…¥ i2c_data_w &lt;= i2c_data_w + 1&#x27;b1; //æ•°æ®0~255 end end 2&#x27;d2 : begin flow_cnt &lt;= flow_cnt + 1&#x27;b1; i2c_exec &lt;= 1&#x27;b1; end 2&#x27;d3 : begin if(i2c_done == 1&#x27;b1) begin //EEPROMå•æ¬¡è¯»å‡ºå®Œæˆ //è¯»å‡ºçš„å€¼é”™è¯¯æˆ–è€…I2Cæœªåº”ç­”,è¯»å†™æµ‹è¯•å¤±è´¥ if((i2c_addr[7:0] != i2c_data_r) || (i2c_ack == 1&#x27;b1)) begin rw_done &lt;= 1&#x27;b1; rw_result &lt;= 1&#x27;b0; end else if(i2c_addr == MAX_BYTE - 1&#x27;b1) begin //è¯»å†™æµ‹è¯•æˆåŠŸ rw_done &lt;= 1&#x27;b1; rw_result &lt;= 1&#x27;b1; end else begin flow_cnt &lt;= 2&#x27;d2; i2c_addr &lt;= i2c_addr + 1&#x27;b1; end end end default : ; endcase endend endmodule 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// led_alarm.vmodule led_alarm #(parameter L_TIME = 25&#x27;d25_000_000 ) ( input clk , //æ—¶é’Ÿä¿¡å· input rst_n , //å¤ä½ä¿¡å· input rw_done , //é”™è¯¯æ ‡å¿— input rw_result , //E2PROMè¯»å†™æµ‹è¯•å®Œæˆ output reg led //E2PROMè¯»å†™æµ‹è¯•ç»“æœ 0:å¤±è´¥ 1:æˆåŠŸ);//reg definereg rw_done_flag; //è¯»å†™æµ‹è¯•å®Œæˆæ ‡å¿—reg [24:0] led_cnt ; //ledè®¡æ•°//è¯»å†™æµ‹è¯•å®Œæˆæ ‡å¿—always @(posedge clk or negedge rst_n) begin if(!rst_n) rw_done_flag &lt;= 1&#x27;b0; else if(rw_done) rw_done_flag &lt;= 1&#x27;b1;end //é”™è¯¯æ ‡å¿—ä¸º1æ—¶PL_LED0é—ªçƒï¼Œå¦åˆ™PL_LED0å¸¸äº®always @(posedge clk or negedge rst_n) begin if(!rst_n) begin led_cnt &lt;= 25&#x27;d0; led &lt;= 1&#x27;b0; end else begin if(rw_done_flag) begin if(rw_result) //è¯»å†™æµ‹è¯•æ­£ç¡® led &lt;= 1&#x27;b1; //ledç¯å¸¸äº® else begin //è¯»å†™æµ‹è¯•é”™è¯¯ led_cnt &lt;= led_cnt + 25&#x27;d1; if(led_cnt == L_TIME - 1&#x27;b1) begin led_cnt &lt;= 25&#x27;d0; led &lt;= ~led; //ledç¯é—ªçƒ end end end else led &lt;= 1&#x27;b0; //è¯»å†™æµ‹è¯•å®Œæˆä¹‹å‰,ledç¯ç†„ç­ end endendmodule ç®¡è„šçº¦æŸï¼š 123456#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk]set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n]set_property -dict &#123;PACKAGE_PIN R6 IOSTANDARD LVCMOS33&#125; [get_ports iic_scl]set_property -dict &#123;PACKAGE_PIN T4 IOSTANDARD LVCMOS33&#125; [get_ports iic_sda]set_property -dict &#123;PACKAGE_PIN R2 IOSTANDARD LVCMOS15&#125; [get_ports led] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12//tb_demo.v è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ17ï¼‰æ•°å­—é¢‘ç‡è®¡","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-017","date":"2022-10-29T00:35:18.000Z","updated":"2023-04-05T04:16:38.500Z","comments":true,"path":"posts/3335218492.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3335218492.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦å®ç°è¾“å…¥æ—¶é’Ÿçš„é¢‘ç‡æµ‹è¯•ã€‚ ç”µè·¯ æ—  FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ clk_fx input U5 è¢«æµ‹æ—¶é’Ÿ æ€è·¯ åœ¨ä¸€æ¬¡å®é™…é—¸é—¨æ—¶é—´GATE_TIMEä¸­ï¼Œè®¡æ•°å™¨å¯¹è¢«æµ‹ä¿¡å·çš„è®¡æ•°å€¼æœªfx_cntï¼Œå¯¹åŸºå‡†æ—¶é’Ÿçš„é¢‘ç‡ä¸ºfs_cntï¼Œè€ŒåŸºå‡†æ—¶é’Ÿçš„é¢‘ç‡ä¸ºCLK_FSï¼Œåˆ™è¢«æµ‹ä¿¡å·çš„é¢‘ç‡ä¸ºclk_fxï¼Œå³ç”±å…¬å¼ fs_cnt/CLK_FS = GATE_TIME = fx_cnt/clk_fx å¾— clk_fx = fx_cnt*(CLK_FS/fs_cnt) é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021//demo.vmodule demo ( //system clock input clk_fs , // åŸºå‡†æ—¶é’Ÿä¿¡å· input rst_n , // å¤ä½ä¿¡å· input clk_fx // è¢«æµ‹æ—¶é’Ÿä¿¡å·); cymometer #(.CLK_FS(26&#x27;d50000000)) // åŸºå‡†æ—¶é’Ÿé¢‘ç‡å€¼ inst_cymometer ( //system clock .clk_fs (.clk_fs ), // åŸºå‡†æ—¶é’Ÿä¿¡å· .rst_n (.rst_n ), // å¤ä½ä¿¡å· .clk_fx (.clk_fx ), // è¢«æµ‹æ—¶é’Ÿä¿¡å· .data_fx () // è¢«æµ‹æ—¶é’Ÿé¢‘ç‡è¾“å‡º );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163//cymometer.vmodule cymometer #(parameter CLK_FS = 26&#x27;d50000000) // åŸºå‡†æ—¶é’Ÿé¢‘ç‡å€¼ ( //system clock input clk_fs , // åŸºå‡†æ—¶é’Ÿä¿¡å· input rst_n , // å¤ä½ä¿¡å· //cymometer interface input clk_fx , // è¢«æµ‹æ—¶é’Ÿä¿¡å· output reg [19:0] data_fx // è¢«æµ‹æ—¶é’Ÿé¢‘ç‡è¾“å‡º);//parameter definelocalparam MAX = 6&#x27;d32; // å®šä¹‰fs_cntã€fx_cntçš„æœ€å¤§ä½å®½localparam GATE_TIME = 16&#x27;d5_000; // é—¨æ§æ—¶é—´è®¾ç½®//reg definereg gate ; // é—¨æ§ä¿¡å·reg gate_fs ; // åŒæ­¥åˆ°åŸºå‡†æ—¶é’Ÿçš„é—¨æ§ä¿¡å·reg gate_fs_r ; // ç”¨äºåŒæ­¥gateä¿¡å·çš„å¯„å­˜å™¨reg gate_fs_d0 ; // ç”¨äºé‡‡é›†åŸºå‡†æ—¶é’Ÿä¸‹gateä¸‹é™æ²¿reg gate_fs_d1 ; // reg gate_fx_d0 ; // ç”¨äºé‡‡é›†è¢«æµ‹æ—¶é’Ÿä¸‹gateä¸‹é™æ²¿reg gate_fx_d1 ; // reg [ 63:0] data_fx_t ; // reg [ 15:0] gate_cnt ; // é—¨æ§è®¡æ•°reg [MAX-1:0] fs_cnt ; // é—¨æ§æ—¶é—´å†…åŸºå‡†æ—¶é’Ÿçš„è®¡æ•°å€¼reg [MAX-1:0] fs_cnt_temp ; // fs_cnt ä¸´æ—¶å€¼reg [MAX-1:0] fx_cnt ; // é—¨æ§æ—¶é—´å†…è¢«æµ‹æ—¶é’Ÿçš„è®¡æ•°å€¼reg [MAX-1:0] fx_cnt_temp ; // fx_cnt ä¸´æ—¶å€¼//wire definewire neg_gate_fs; // åŸºå‡†æ—¶é’Ÿä¸‹é—¨æ§ä¿¡å·ä¸‹é™æ²¿wire neg_gate_fx; // è¢«æµ‹æ—¶é’Ÿä¸‹é—¨æ§ä¿¡å·ä¸‹é™æ²¿//è¾¹æ²¿æ£€æµ‹ï¼Œæ•è·ä¿¡å·ä¸‹é™æ²¿assign neg_gate_fs = gate_fs_d1 &amp; (~gate_fs_d0);assign neg_gate_fx = gate_fx_d1 &amp; (~gate_fx_d0);//é—¨æ§ä¿¡å·è®¡æ•°å™¨ï¼Œä½¿ç”¨è¢«æµ‹æ—¶é’Ÿè®¡æ•°always @(posedge clk_fx or negedge rst_n) begin if(!rst_n) gate_cnt &lt;= 16&#x27;d0; else if(gate_cnt == GATE_TIME + 5&#x27;d20) gate_cnt &lt;= 16&#x27;d0; else gate_cnt &lt;= gate_cnt + 1&#x27;b1;end//é—¨æ§ä¿¡å·ï¼Œæ‹‰é«˜æ—¶é—´ä¸ºGATE_TIMEä¸ªå®æµ‹æ—¶é’Ÿå‘¨æœŸalways @(posedge clk_fx or negedge rst_n) begin if(!rst_n) gate &lt;= 1&#x27;b0; else if(gate_cnt &lt; 4&#x27;d10) gate &lt;= 1&#x27;b0; else if(gate_cnt &lt; GATE_TIME + 4&#x27;d10) gate &lt;= 1&#x27;b1; else if(gate_cnt &lt;= GATE_TIME + 5&#x27;d20) gate &lt;= 1&#x27;b0; else gate &lt;= 1&#x27;b0;end//å°†é—¨æ§ä¿¡å·åŒæ­¥åˆ°åŸºå‡†æ—¶é’Ÿä¸‹always @(posedge clk_fs or negedge rst_n) begin if(!rst_n) begin gate_fs_r &lt;= 1&#x27;b0; gate_fs &lt;= 1&#x27;b0; end else begin gate_fs_r &lt;= gate; gate_fs &lt;= gate_fs_r; endend//æ‰“æ‹é‡‡é—¨æ§ä¿¡å·çš„ä¸‹é™æ²¿ï¼ˆè¢«æµ‹æ—¶é’Ÿä¸‹ï¼‰always @(posedge clk_fx or negedge rst_n) begin if(!rst_n) begin gate_fx_d0 &lt;= 1&#x27;b0; gate_fx_d1 &lt;= 1&#x27;b0; end else begin gate_fx_d0 &lt;= gate; gate_fx_d1 &lt;= gate_fx_d0; endend//æ‰“æ‹é‡‡é—¨æ§ä¿¡å·çš„ä¸‹é™æ²¿ï¼ˆåŸºå‡†æ—¶é’Ÿä¸‹ï¼‰always @(posedge clk_fs or negedge rst_n) begin if(!rst_n) begin gate_fs_d0 &lt;= 1&#x27;b0; gate_fs_d1 &lt;= 1&#x27;b0; end else begin gate_fs_d0 &lt;= gate_fs; gate_fs_d1 &lt;= gate_fs_d0; endend //é—¨æ§æ—¶é—´å†…å¯¹è¢«æµ‹æ—¶é’Ÿè®¡æ•°always @(posedge clk_fx or negedge rst_n) begin if(!rst_n) begin fx_cnt_temp &lt;= 32&#x27;d0; fx_cnt &lt;= 32&#x27;d0; end else if(gate) fx_cnt_temp &lt;= fx_cnt_temp + 1&#x27;b1; else if(neg_gate_fx) begin fx_cnt_temp &lt;= 32&#x27;d0; fx_cnt &lt;= fx_cnt_temp; endend //é—¨æ§æ—¶é—´å†…å¯¹åŸºå‡†æ—¶é’Ÿè®¡æ•°always @(posedge clk_fs or negedge rst_n) begin if(!rst_n) begin fs_cnt_temp &lt;= 32&#x27;d0; fs_cnt &lt;= 32&#x27;d0; end else if(gate_fs) fs_cnt_temp &lt;= fs_cnt_temp + 1&#x27;b1; else if(neg_gate_fs) begin fs_cnt_temp &lt;= 32&#x27;d0; fs_cnt &lt;= fs_cnt_temp; endend//è®¡ç®—è¢«æµ‹ä¿¡å·é¢‘ç‡always @(posedge clk_fs or negedge rst_n) begin if(!rst_n) data_fx_t &lt;= 64&#x27;d0; else if(gate_fs == 1&#x27;b0) data_fx_t &lt;= CLK_FS * fx_cnt ;endalways @(posedge clk_fs or negedge rst_n) begin if(!rst_n) data_fx &lt;= 20&#x27;d0; else if(gate_fs == 1&#x27;b0) data_fx &lt;= data_fx_t / fs_cnt ;endendmodule ç®¡è„šçº¦æŸï¼š 1234#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk]set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n]set_property -dict &#123;PACKAGE_PIN K16 IOSTANDARD LVCMOS33&#125; [get_ports clk_fx] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12//tb_demo.v è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"ã€æœªå®Œã€‘XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ13ï¼‰RGB-LCDå½©æ¡æ˜¾ç¤ºé©±åŠ¨","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-013","date":"2022-10-28T23:35:18.000Z","updated":"2023-04-05T04:15:29.369Z","comments":true,"path":"posts/1384587248.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1384587248.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šLCDæ˜¾ç¤ºå™¨ï¼ˆRGB-LCDï¼‰ã€‚ ä¸»è¦åº”ç”¨å‚æ•° 1.åˆ†è¾¨ç‡ ç§¯ç‚¹æˆçº¿ï¼Œçº¿è¿æˆé¢ï¼Œæ˜¾ç¤ºå™¨å°±æ˜¯ç”±ä¸€ä¸ªä¸ªå‘å…‰ç‚¹ç»„æˆã€‚è¿™é‡Œçš„ç‚¹ä½œä¸ºæ˜¾ç¤ºå™¨æ˜¾ç¤ºçš„æœ€å°å•å…ƒå…±åŒæ±‡èšæˆäº†ä¸€å—æ˜¾ç¤ºå±ï¼Œ1080Pçš„æ„æ€ï¼Œå°±æ˜¯ä¸€å—LCDæ˜¾ç¤ºå±ä¸Šçš„åƒç´ æ•°é‡æ˜¯1920*1080ä¸ªï¼ˆå³2073600ä¸ªåƒç´ ç‚¹ï¼‰ï¼Œå³ä¸€åˆ—1080ä¸ªåƒç´ ç‚¹ï¼Œä¸€å…±1920åˆ—ã€‚ 2.åƒç´ æ ¼å¼ åƒç´ çš„æ˜¾ç¤ºæ ¼å¼ï¼Œå°±æ˜¯é€šè¿‡ä¸‰åŸè‰²çš„å…‰äº®æ§åˆ¶é…æ¯”æ¥å®Œæˆæ›´å¤šè‰²å½©çš„æ˜¾ç¤ºï¼Œå…‰äº®æ˜¯é€šè¿‡æ§åˆ¶å­—èŠ‚æ¥å®Œæˆçš„ï¼Œæ§åˆ¶å­—èŠ‚å°±æ˜¯å°†å…‰äº®äº®åº¦ç­‰æ¯”ä¾‹åˆ’åˆ†ï¼Œæ§åˆ¶å­—èŠ‚è¶Šå¤šï¼Œå…‰äº®ç­‰çº§åˆ’åˆ†è¶Šç»†ï¼Œèƒ½å¤Ÿäº§ç”Ÿçš„é¢œè‰²é…ç½®æ›´ç»†è…»ã€‚ RGB888æŒ‡çš„æ˜¯çº¢å…‰ï¼ˆRï¼‰ä½¿ç”¨8bitæ§åˆ¶ã€ç»¿å…‰ï¼ˆGï¼‰ä½¿ç”¨8bitæ§åˆ¶ã€è“å…‰ï¼ˆBï¼‰ä½¿ç”¨8bitæ§åˆ¶ï¼Œå…±24bitï¼ˆå³3å­—èŠ‚ï¼‰ï¼Œå³ä¸€ä¸ªåƒç´ ç‚¹çš„æ˜¾ç¤ºä½¿ç”¨3å­—èŠ‚æ¥æ§åˆ¶ï¼› RGB565æŒ‡çš„æ˜¯çº¢å…‰ï¼ˆRï¼‰ä½¿ç”¨5bitæ§åˆ¶ã€ç»¿å…‰ï¼ˆGï¼‰ä½¿ç”¨6bitæ§åˆ¶ã€è“å…‰ï¼ˆBï¼‰ä½¿ç”¨5bitæ§åˆ¶ï¼Œå…±16bitï¼ˆå³2å­—èŠ‚ï¼‰ã€‚ 3.LCDæ¥å£ ä¿¡å·çº¿ è¯´æ˜ R[7:0] çº¢è‰²æ•°æ®çº¿ G[7:0] ç»¿è‰²æ•°æ®çº¿ B[7:0] è“è‰²æ•°æ®çº¿ DE æ•°æ®ä½¿èƒ½ç«¯ VSYNC å‚ç›´åŒæ­¥ä¿¡å·çº¿ HSYNC æ°´å¹³åŒæ­¥ä¿¡å·çº¿ PCLK åƒç´ æ—¶é’Ÿä¿¡å·çº¿ 4.LCDæ—¶é—´å‚æ•° ç›®çš„ ç”µè·¯ FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ æ€è·¯ é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1 1 1 ç®¡è„šçº¦æŸï¼š 1 éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 1 è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ12ï¼‰æ¥å£UART RS232é©±åŠ¨","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-012","date":"2022-10-28T02:20:18.000Z","updated":"2023-04-05T04:15:26.316Z","comments":true,"path":"posts/1836737662.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1836737662.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®æ ‡å™¨ä»¶ï¼šCH340 ï¼ˆä¸²å£è½¬USB,ç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸USBå·®åˆ†ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®æ ‡å™¨ä»¶ï¼šSP3232 ï¼ˆç”µå¹³ç±»å‹è½¬æ¢èŠ¯ç‰‡ï¼ŒTTLç”µå¹³ä¸RS232ç”µå¹³çš„è½¬æ¢ï¼‰ ç›®çš„ ä¸»è¦å®ç°ä¸²å£é€šä¿¡åè®®çš„ä¼ è¾“æ•ˆæœã€‚ ç”µè·¯ {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ uart_rxd input U5 ä¸²å£æ”¶ uart_txd output T6 ä¸²å£å‘ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142//demo.vmodule demo( input sys_clk, input sys_rst_n, input uart_rxd, output uart_txd ); parameter CLK_FREQ = 50000000; parameter UART_BPS = 115200; wire uart_en_w; wire [7:0] uart_data_w; uart_recv #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_recv( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_rxd (uart_rxd), .uart_done (uart_en_w), .uart_dout (uart_data_w) ); uart_send #( .CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) u_uart_send( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .uart_en (uart_en_w), .uart_din (uart_data_w), .tx_flag (tx_flag), .uart_txd (uart_txd) );endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//uart_send.vmodule uart_send( input sys_clk, input sys_rst_n, input uart_en, input [7:0] uart_din, output reg tx_flag, output reg uart_txd ); parameter CLK_FREQ = 50000000; //Source Clockparameter UART_BPS = 9600; //Buad Ratelocalparam BPS_CNT = CLK_FREQ/UART_BPS; // reg uart_en_d0; reg uart_en_d1; reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg [ 7:0] tx_data; wire en_flag;assign en_flag = (~uart_en_d1) &amp; uart_en_d0; always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_en_d0 &lt;= 1&#x27;b0; uart_en_d1 &lt;= 1&#x27;b0; end else begin uart_en_d0 &lt;= uart_en; uart_en_d1 &lt;= uart_en_d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else if (en_flag) //start of process begin tx_flag &lt;= 1&#x27;b1; tx_data &lt;= uart_din; //Load Data end else if ((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) //end of process begin tx_flag &lt;= 1&#x27;b0; tx_data &lt;= 8&#x27;d0; end else begin tx_flag &lt;= tx_flag; tx_data &lt;= tx_data; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if (tx_flag) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) uart_txd &lt;= 1&#x27;b1; //IDEL else if (tx_flag) case(bit_cnt) 4&#x27;d0: uart_txd &lt;= 1&#x27;b0; //start 4&#x27;d1: uart_txd &lt;= tx_data[0]; //LSB 4&#x27;d2: uart_txd &lt;= tx_data[1]; 4&#x27;d3: uart_txd &lt;= tx_data[2]; 4&#x27;d4: uart_txd &lt;= tx_data[3]; 4&#x27;d5: uart_txd &lt;= tx_data[4]; 4&#x27;d6: uart_txd &lt;= tx_data[5]; 4&#x27;d7: uart_txd &lt;= tx_data[6]; 4&#x27;d8: uart_txd &lt;= tx_data[7]; //MSB 4&#x27;d9: uart_txd &lt;= 1&#x27;b1; //stop default: ; endcase else uart_txd &lt;= 1&#x27;b1; //IDELendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//uart_recv.vmodule uart_recv( input sys_clk, input sys_rst_n, input uart_rxd, output reg uart_done, output reg [7:0] uart_dout );parameter CLK_FREQ = 50000000; parameter UART_BPS = 9600; localparam BPS_CNT = CLK_FREQ/UART_BPS; reg uart_rxd_d0;reg uart_rxd_d1;reg [15:0] clk_cnt; reg [ 3:0] bit_cnt; reg rx_flag; reg [ 7:0] rxdata; wire start_flag;assign start_flag = uart_rxd_d1 &amp; (~uart_rxd_d0); always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_rxd_d0 &lt;= 1&#x27;b0; uart_rxd_d1 &lt;= 1&#x27;b0; end else begin uart_rxd_d0 &lt;= uart_rxd; uart_rxd_d1 &lt;= uart_rxd_d0; end endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) rx_flag &lt;= 1&#x27;b0; else begin if(start_flag) rx_flag &lt;= 1&#x27;b1; else if((bit_cnt == 4&#x27;d9)&amp;&amp;(clk_cnt == BPS_CNT/2)) rx_flag &lt;= 1&#x27;b0; else rx_flag &lt;= rx_flag; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; end else if ( rx_flag ) begin if (clk_cnt &lt; BPS_CNT - 1) begin clk_cnt &lt;= clk_cnt + 1&#x27;b1; bit_cnt &lt;= bit_cnt; end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= bit_cnt + 1&#x27;b1; end end else begin clk_cnt &lt;= 16&#x27;d0; bit_cnt &lt;= 4&#x27;d0; endendalways @(posedge sys_clk or negedge sys_rst_n) begin if ( !sys_rst_n) rxdata &lt;= 8&#x27;d0; else if(rx_flag) if (clk_cnt == BPS_CNT/2) begin case ( bit_cnt ) 4&#x27;d1 : rxdata[0] &lt;= uart_rxd_d1; //LSB 4&#x27;d2 : rxdata[1] &lt;= uart_rxd_d1; 4&#x27;d3 : rxdata[2] &lt;= uart_rxd_d1; 4&#x27;d4 : rxdata[3] &lt;= uart_rxd_d1; 4&#x27;d5 : rxdata[4] &lt;= uart_rxd_d1; 4&#x27;d6 : rxdata[5] &lt;= uart_rxd_d1; 4&#x27;d7 : rxdata[6] &lt;= uart_rxd_d1; 4&#x27;d8 : rxdata[7] &lt;= uart_rxd_d1; //MSB default:; endcase end else rxdata &lt;= rxdata; else rxdata &lt;= 8&#x27;d0;endalways @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end else if(bit_cnt == 4&#x27;d9) begin uart_dout &lt;= rxdata; //collect Data uart_done &lt;= 1&#x27;b1; //valid end else begin uart_dout &lt;= 8&#x27;d0; uart_done &lt;= 1&#x27;b0; end endendmodule ç®¡è„šçº¦æŸï¼š 123456#demo.xdccreate_clock -period 20.000 -name clk [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN U5 IOSTANDARD LVCMOS33&#125; [get_ports uart_rxd] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS33&#125; [get_ports uart_txd] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; reg uart_rxd; wire uart_txd; always #10 sys_clk = ~sys_clk; parameter CLK_FREQ = 50000000; // é©±åŠ¨æ—¶é’Ÿ 50MHz ï¼Œ20ns parameter UART_BPS = 115200; // æ³¢ç‰¹ç‡ 115200 bps localparam BPS_CNT = CLK_FREQ/UART_BPS; // å•bitä¼ è¾“è€—æ—¶ BPS_CNT ä¸ªé©±åŠ¨æ—¶é’Ÿå‘¨æœŸ initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; uart_rxd = 1&#x27;b1; //IDEL #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //START #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit0 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit1 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit2 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit3 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit4 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit5 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //bit6 #(BPS_CNT*20) uart_rxd = 1&#x27;b0; //bit7 #(BPS_CNT*20) uart_rxd = 1&#x27;b1; //STOP and IDEL end demo #(.CLK_FREQ (CLK_FREQ), .UART_BPS (UART_BPS)) inst_uart ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk), .uart_txd(uart_txd), .uart_rxd(uart_rxd)); endmodule è¿è¡Œç»“æœï¼š ç•¥ ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ11ï¼‰Xilinx FIFOæ ¸åº”ç”¨","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-011","date":"2022-10-28T01:59:18.000Z","updated":"2023-04-05T04:15:22.431Z","comments":true,"path":"posts/1239873178.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1239873178.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦é€šè¿‡FIFOæ ¸ç†Ÿæ‚‰FIFOçš„è¯»å†™åŠIPæ ¸ä½¿ç”¨ã€‚ ç”µè·¯ ç•¥ FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ æ€è·¯ é…ç½®ä½å®½ {width=â€œ400pxâ€} IPé…ç½® {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//demo.vmodule demo( input sys_clk, input sys_rst_n, output wire almost_empty, output wire almost_full, output wire fifo_rd_en, output wire [7:0]fifo_dout, output wire fifo_wr_en, output wire [7:0] fifo_din, output wire fifo_empty, output wire fifo_full, output wire [7 : 0] fifo_rd_data_count, output wire [7 : 0] fifo_wr_data_count);fifo_read inst_fifo_read( . clk (sys_clk), . rst_n (sys_rst_n), . almost_empty (almost_empty), . almost_full (almost_full), . rd_en (fifo_rd_en), . rd_data (fifo_dout));fifo_write inst_fifo_write( . clk (sys_clk), . rst_n (sys_rst_n), . almost_empty (almost_empty), . almost_full (almost_full), . wr_en (fifo_wr_en), . wr_data (fifo_din));fifo_generator_0 your_instance_name ( .wr_clk(sys_clk), // input wire wr_clk .rd_clk(sys_clk), // input wire rd_clk .din(fifo_din), // input wire [7 : 0] din .wr_en(fifo_wr_en), // input wire wr_en .rd_en(fifo_rd_en), // input wire rd_en .dout(fifo_dout), // output wire [7 : 0] dout .full(fifo_full), // output wire full .almost_full(almost_full), // output wire almost_full .empty(fifo_empty), // output wire empty .almost_empty(almost_empty), // output wire almost_empty .rd_data_count(fifo_rd_data_count), // output wire [7 : 0] rd_data_count .wr_data_count(fifo_wr_data_count) // output wire [7 : 0] wr_data_count);endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//fifo_write.vmodule fifo_write( input clk, input rst_n, input almost_empty, input almost_full, output reg wr_en, output reg [7:0] wr_data);reg [1:0] state;reg almost_empty_d0,almost_empty_d1;reg [3:0] delay_cnt;always@(posedge clk or negedge rst_n)begin if(!rst_n) begin almost_empty_d0 &lt;= 1&#x27;b0; almost_empty_d1 &lt;= 1&#x27;b0; end else begin almost_empty_d0 &lt;= almost_empty; almost_empty_d1 &lt;= almost_empty_d0; endendalways@(posedge clk or negedge rst_n)begin if(!rst_n) begin wr_en &lt;= 1&#x27;b0; wr_data &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; delay_cnt &lt;= 4&#x27;d0; end else begin case(state) 2&#x27;d0 : begin //IDEL if(almost_empty_d1) state &lt;= 2&#x27;d1; else state &lt;= state; end 2&#x27;d1 : begin //DELAY if(delay_cnt==4&#x27;d10) begin delay_cnt &lt;= 4&#x27;d0; state &lt;= 2&#x27;d2; wr_en &lt;= 1&#x27;b1; end else delay_cnt &lt;= delay_cnt+4&#x27;d1; end 2&#x27;d2 : begin //WRITE if(almost_full) begin wr_en &lt;= 1&#x27;b0; wr_data &lt;= 8&#x27;d0; state &lt;= 2&#x27;d0; end else begin wr_en &lt;= 1&#x27;b1; wr_data &lt;= wr_data+1&#x27;b1; end end default:state &lt;= 2&#x27;d0; endcase endendendmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//fifo_read.vmodule fifo_read( input clk, input rst_n, input almost_empty, input almost_full, output reg rd_en, input [7:0] rd_data);reg [1:0] state;reg almost_full_d0,almost_full_d1;reg [3:0] delay_cnt;always@(posedge clk or negedge rst_n)begin if(!rst_n) begin almost_full_d0 &lt;= 1&#x27;b0; almost_full_d1 &lt;= 1&#x27;b0; end else begin almost_full_d0 &lt;= almost_full; almost_full_d1 &lt;= almost_full_d0; endendalways@(posedge clk or negedge rst_n)begin if(!rst_n) begin rd_en &lt;= 1&#x27;b0; state &lt;= 2&#x27;d0; delay_cnt &lt;= 4&#x27;d0; end else begin case(state) 2&#x27;d0 : begin //IDEL if(almost_full_d1) state &lt;= 2&#x27;d1; else state &lt;= state; end 2&#x27;d1 : begin //DELAY if(delay_cnt==4&#x27;d10) begin delay_cnt &lt;= 4&#x27;d0; state &lt;= 2&#x27;d2; end else delay_cnt &lt;= delay_cnt+4&#x27;d1; end 2&#x27;d2 : begin //READ if(almost_empty) begin rd_en &lt;= 1&#x27;b0; state &lt;= 2&#x27;d0; end else begin rd_en &lt;= 1&#x27;b1; end end default:state &lt;= 2&#x27;d0; endcase endendendmodule ç®¡è„šçº¦æŸï¼š 1234#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #30 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; wire almost_empty;wire almost_full;wire fifo_rd_en;wire [7:0]fifo_dout;wire fifo_wr_en;wire [7:0] fifo_din;wire fifo_empty;wire fifo_full;wire [7 : 0] fifo_rd_data_count;wire [7 : 0] fifo_wr_data_count;demo inst_demo ( .sys_clk(sys_clk), // input wire rd_clk .sys_rst_n(sys_rst_n), // input wire rd_clk .fifo_din(fifo_din), // input wire [7 : 0] din .fifo_wr_en(fifo_wr_en), // input wire wr_en .fifo_rd_en(fifo_rd_en), // input wire rd_en .fifo_dout(fifo_dout), // output wire [7 : 0] dout .fifo_full(fifo_full), // output wire full .almost_full(almost_full), // output wire almost_full .fifo_empty(fifo_empty), // output wire empty .almost_empty(almost_empty), // output wire almost_empty .fifo_rd_data_count(fifo_rd_data_count), // output wire [7 : 0] rd_data_count .fifo_wr_data_count(fifo_wr_data_count) // output wire [7 : 0] wr_data_count);endmodule è¿è¡Œç»“æœï¼š â€œå¯åŠ¨-å¤ä½é‡Šæ”¾-å†™çŠ¶æ€æœºIDEL-å†™çŠ¶æ€æœºDELAY-å†™çŠ¶æ€æœºWRITEâ€è¿‡ç¨‹ â€œå†™çŠ¶æ€æœºWRITEâ€é˜¶æ®µçš„FIFOæ ¸çš„çŠ¶æ€å˜åŒ–ï¼Œå¯ä»¥çœ‹åˆ°ç”±ç©ºåˆ°éç©ºçŠ¶æ€ dinã€almost_emptyã€emptyä¸rd_countã€wr_countçš„å…³ç³» â€œå†™çŠ¶æ€æœºWRITEâ€é˜¶æ®µçš„FIFOæ ¸çš„çŠ¶æ€å˜åŒ–ï¼Œå¯ä»¥çœ‹åˆ°ç”±éæ»¡åˆ°æ»¡çŠ¶æ€ dinã€almost_fullã€fullä¸rd_countã€wr_countçš„å…³ç³» â€œå†™çŠ¶æ€æœº-è¯»çŠ¶æ€æœºâ€è¿‡ç¨‹çš„FIFOæ ¸çš„çŠ¶æ€å˜åŒ–ï¼Œå¯ä»¥çœ‹åˆ°ç”±æ»¡åˆ°éæ»¡çŠ¶æ€ dinã€almost_fullã€fullä¸rd_countã€wr_countçš„å…³ç³» â€œè¯»çŠ¶æ€æœºREADâ€é˜¶æ®µçš„FIFOæ ¸çš„çŠ¶æ€å˜åŒ–ï¼Œå¯ä»¥çœ‹åˆ°ç”±éç©ºåˆ°ç©ºçŠ¶æ€ dinã€almost_emptyã€emptyä¸rd_countã€wr_countçš„å…³ç³» ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ10ï¼‰Xilinx RAMæ ¸åº”ç”¨","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-010","date":"2022-10-28T01:00:18.000Z","updated":"2023-04-05T04:15:19.200Z","comments":true,"path":"posts/2451945340.html","link":"","permalink":"https://sirius-tblog.github.io/posts/2451945340.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦é€šè¿‡RAMæ ¸ç†Ÿæ‚‰RAMçš„è¯»å†™åŠIPæ ¸ä½¿ç”¨ã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ æ€è·¯ ä½¿ç”¨IPæ ¸æ„å»ºä½å®½ä¸º8ï¼Œæ·±åº¦ä¸º32çš„å•ç«¯å£RAMï¼Œå¹¶è¿›è¡Œè¯»å†™æµ‹è¯•ã€‚ IPé…ç½® {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718192021222324252627282930313233//demo.vmodule demo( input sys_clk, input sys_rst_n); wire ram_en; wire ram_wea; wire [4:0] ram_addr ; wire [7:0] ram_wr_data ; wire [7:0] ram_rd_data ;ram_rw inst_rw_ram ( .clk(sys_clk), .rst_n(sys_rst_n), .ram_en(ram_en), .ram_wea(ram_wea), .ram_addr(ram_addr), .ram_wr_data(ram_wr_data), .ram_rd_data(ram_rd_data) );blk_mem_gen_0 inst_IP_ram ( .clka(sys_clk), // input wire clka .ena(ram_en), // input wire ena .wea(ram_wea), // input wire [0 : 0] wea .addra(ram_addr), // input wire [4 : 0] addra .dina(ram_wr_data), // input wire [7 : 0] dina .douta(ram_rd_data) // output wire [7 : 0] douta);endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445//ram_rw.vmodule ram_rw( input clk , input rst_n , output ram_en , output ram_wea , output reg [4:0] ram_addr , output reg [7:0] ram_wr_data, input [7:0] ram_rd_data);reg [5:0] rw_cnt ;assign ram_en = rst_n;assign ram_wea = (rw_cnt &lt;= 6&#x27;d31 &amp;&amp; ram_en == 1&#x27;b1) ? 1&#x27;b1 : 1&#x27;b0;always @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) rw_cnt &lt;= 1&#x27;b0; else if(rw_cnt == 6&#x27;d63) rw_cnt &lt;= 1&#x27;b0; else rw_cnt &lt;= rw_cnt + 1&#x27;b1;endalways @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) ram_wr_data &lt;= 1&#x27;b0; else if(rw_cnt &lt;= 6&#x27;d31) ram_wr_data &lt;= ram_wr_data + 1&#x27;b1; else ram_wr_data &lt;= 1&#x27;b0 ;endalways @(posedge clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) ram_addr &lt;= 1&#x27;b0; else if(ram_addr == 5&#x27;d31) ram_addr &lt;= 1&#x27;b0; else ram_addr &lt;= ram_addr + 1&#x27;b1;endendmodule ç®¡è„šçº¦æŸï¼š 123#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_ram_rw ( .sys_rst_n(sys_rst_n), .sys_clk(sys_clk)); endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ9ï¼‰Xilinx PLLæ ¸åº”ç”¨","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-009","date":"2022-10-28T00:47:18.000Z","updated":"2023-04-05T04:15:15.928Z","comments":true,"path":"posts/2382141945.html","link":"","permalink":"https://sirius-tblog.github.io/posts/2382141945.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦é€šè¿‡PLLè¿™ä¸€æ—¶é’ŸIPæ ¸å®ç°å¯¹å®˜æ–¹IPåº”ç”¨çš„è®¤çŸ¥ã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ clk_100M output M16 100MHzæ—¶é’Ÿ clk_100M_pd output L15 100MHzæ—¶é’Ÿ,åç›¸ clk_50M output M15 50MHzæ—¶é’Ÿ clk_25M output L14 25MHzæ—¶é’Ÿ æ€è·¯ é€šè¿‡å‚æ•°é…ç½®PLLæ ¸ï¼Œå®ç°åˆ†é¢‘å’Œå€é¢‘ä»¥åŠç›¸ä½åç§»ã€‚ IPé…ç½® å‚æ•°ï¼šå•ç«¯è¾“å…¥50MHz,ä»4è¾“å‡ºç«¯å£åˆ†åˆ«è¾“å‡º100MHzå€é¢‘é’Ÿã€åç›¸100MHzã€50MHzã€25MHzåˆ†é¢‘ã€‚ {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1234567891011121314151617181920212223242526//demo.vmodule demo( input sys_clk, input sys_rst_n, output clk_100M, output clk_100M_pd, output clk_50M, output clk_25M); wire locked; clk_wiz_0 inst_IP_clock ( // Clock out ports .clk_out1(clk_100M), // output clk_out1 .clk_out2(clk_100M_pd), // output clk_out2 .clk_out3(clk_50M), // output clk_out3 .clk_out4(clk_25M), // output clk_out4 // Status and control signals .reset(!sys_rst_n), // input reset .locked(locked), // output locked // Clock in ports .clk_in1(sys_clk)); // input clk_in1endmodule ç®¡è„šçº¦æŸï¼š 1234567#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS33&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U2 IOSTANDARD LVCMOS33&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN M16 IOSTANDARD LVCMOS33&#125; [get_ports clk_100m] set_property -dict &#123;PACKAGE_PIN L15 IOSTANDARD LVCMOS33&#125; [get_ports clk_100m_pd] set_property -dict &#123;PACKAGE_PIN M15 IOSTANDARD LVCMOS33&#125; [get_ports clk_50m] set_property -dict &#123;PACKAGE_PIN L14 IOSTANDARD LVCMOS33&#125; [get_ports clk_25m] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031//tb_demo.vmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire clk_100M; wire clk_100M_pd; wire clk_50M; wire clk_25M; always #10 sys_clk = ~sys_clk; initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1; end demo inst_clock_gen ( // Clock out ports .clk_out1(clk_100M), // output clk_out1 .clk_out2(clk_100M_pd), // output clk_out2 .clk_out3(clk_50M), // output clk_out3 .clk_out4(clk_25M), // output clk_out4 // Status and control signals .reset(!sys_rst_n), // input reset // Clock in ports .clk_in1(sys_clk)); // input clk_in1endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ8ï¼‰åŠ¨æ€æ•°ç ç®¡","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-008","date":"2022-10-28T00:39:18.000Z","updated":"2023-04-05T04:15:11.091Z","comments":true,"path":"posts/314178488.html","link":"","permalink":"https://sirius-tblog.github.io/posts/314178488.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ æ§åˆ¶å¯¹è±¡ï¼š8æ®µæ•°ç ç®¡ã€‚ ç›®çš„ ä¸»è¦ä»¥æœ‰é™ç«¯å£å®ç°å¤šç»„8æ®µæ•°ç ç®¡æ˜¾ç¤ºçš„æ•ˆæœã€‚","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ7ï¼‰é™æ€æ•°ç ç®¡æ˜¾ç¤º","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-007","date":"2022-10-28T00:35:18.000Z","updated":"2023-04-05T04:15:08.000Z","comments":true,"path":"posts/2686831974.html","link":"","permalink":"https://sirius-tblog.github.io/posts/2686831974.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ æ§åˆ¶å¯¹è±¡ï¼š8æ®µæ•°ç ç®¡ã€‚ {width=â€œ400pxâ€} ç›®çš„ ä¸»è¦å®ç°8æ®µæ•°ç ç®¡æ˜¾ç¤ºçš„æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š {width=â€œ400pxâ€} {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U2 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ seg_led[0] output H15 æ•°ç ç®¡æ®µé€‰a seg_led[1] output G16 æ•°ç ç®¡æ®µé€‰b seg_led[2] output L13 æ•°ç ç®¡æ®µé€‰c seg_led[3] output G15 æ•°ç ç®¡æ®µé€‰d seg_led[4] output K13 æ•°ç ç®¡æ®µé€‰e seg_led[5] output G13 æ•°ç ç®¡æ®µé€‰f seg_led[6] output H14 æ•°ç ç®¡æ®µé€‰g seg_led[7] output J14 æ•°ç ç®¡æ®µé€‰h seg_sel[0] output J15 æ•°ç ç®¡ä½é€‰0 seg_sel[1] output H17 æ•°ç ç®¡ä½é€‰1 seg_sel[2] output H13 æ•°ç ç®¡ä½é€‰2 seg_sel[3] output G17 æ•°ç ç®¡ä½é€‰3 seg_sel[4] output H18 æ•°ç ç®¡ä½é€‰4 seg_sel[5] output G18 æ•°ç ç®¡ä½é€‰5 æ€è·¯ {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1234567891011121314151617181920212223242526272829303132//demo.vmodule demo( input sys_clk, input sys_rst_n, output [5:0] seg_sel, output [7:0] seg_led);parameter TIME_SHOW = 25&#x27;d25000000; //é©»ç•™æ—¶é—´wire increase_flag;seg_display_static inst_seg_display_static( .clk (sys_clk), .rstn (sys_rst_n), .seg_sel(seg_sel), .seg_led(seg_led), .increase_flag(increase_flag));time_count #(.MAX_NUM(TIME_SHOW ))inst_time_count( .clk (sys_clk), .rstn (sys_rst_n), .flag(increase_flag));endmodule æ•°ç ç®¡é™æ€é©±åŠ¨åŠæ˜¾ç¤ºæ ·å¼ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//seg_display_static.vmodule seg_display_static( input clk, input rstn, input increase_flag, output reg [5:0] seg_sel, output reg [7:0] seg_led);reg [3:0] num;//ä½é€‰é©±åŠ¨ï¼Œç¡¬ä»¶è¿æ¥ä¸­ä½ç”µå¹³é©±åŠ¨PNPä¸‰æç®¡å¯¼é€šalways @ (posedge clk or negedge rstn) begin if (!rstn) seg_sel &lt;= 6&#x27;b111111; else seg_sel &lt;= 6&#x27;b000000;endalways @ (posedge clk or negedge rstn) begin if (!rstn) num &lt;= 4&#x27;h0; else if(increase_flag) begin if(num &lt; 4&#x27;hf) num &lt;= num + 1&#x27;b1; else num &lt;= 4&#x27;h0; end else num &lt;= num;endalways @ (posedge clk or negedge rstn) begin if (!rstn) //å…¨ç‚¹äº® seg_led &lt;= 8&#x27;b0000_0000; else begin case(num) //å…±é˜³æå‹é©±åŠ¨ï¼Œä½ç”µå¹³ç‚¹äº® 4&#x27;h0 : seg_led &lt;= 8&#x27;b1100_0000;//&#x27;hC0 4&#x27;h1 : seg_led &lt;= 8&#x27;b1111_1001;//&#x27;hF9 4&#x27;h2 : seg_led &lt;= 8&#x27;b1010_0100;//&#x27;hA4 4&#x27;h3 : seg_led &lt;= 8&#x27;b1011_0000;//&#x27;hB0 4&#x27;h4 : seg_led &lt;= 8&#x27;b1001_1001;//&#x27;h99 4&#x27;h5 : seg_led &lt;= 8&#x27;b1001_0010;//&#x27;h92 4&#x27;h6 : seg_led &lt;= 8&#x27;b1000_0010;//&#x27;h82 4&#x27;h7 : seg_led &lt;= 8&#x27;b1111_1000;//&#x27;hF8 4&#x27;h8 : seg_led &lt;= 8&#x27;b1000_0000;//&#x27;h80 4&#x27;h9 : seg_led &lt;= 8&#x27;b1001_0000;//&#x27;h90 4&#x27;ha : seg_led &lt;= 8&#x27;b1000_1000;//&#x27;h88 4&#x27;hb : seg_led &lt;= 8&#x27;b1000_0011;//&#x27;h83 4&#x27;hc : seg_led &lt;= 8&#x27;b1100_0110;//&#x27;hC6 4&#x27;hd : seg_led &lt;= 8&#x27;b1010_0001;//&#x27;hA1 4&#x27;he : seg_led &lt;= 8&#x27;b1000_0110;//&#x27;h86 4&#x27;hf : seg_led &lt;= 8&#x27;b1000_1110;//&#x27;h8E default : seg_led &lt;= 8&#x27;b1100_0000;//&#x27;hC0 endcase endendendmodule å•ä¸ªæ ·å¼æ˜¾ç¤ºé©»ç•™æ—¶é•¿ 123456789101112131415161718192021222324252627282930//time_count.vmodule time_count( input clk, input rstn, output reg flag);parameter MAX_NUM = 25000000;reg [24:0] cnt;always@(posedge clk or negedge rstn)begin if (!rstn) begin flag &lt;= 1&#x27;b0; cnt &lt;= 24&#x27;d0; end else if(cnt &lt; MAX_NUM - 1&#x27;b1) begin flag &lt;= 1&#x27;b0; cnt &lt;= cnt + 1&#x27;b1; end else begin flag &lt;= 1&#x27;b1; cnt &lt;= 24&#x27;d0; endendendmodule ç®¡è„šçº¦æŸï¼š 12345678910111213141516171819#demo.xdcset_property IOSTANDARD LVCMOS33[get_ports sys_clk] set_property IOSTANDARD LVCMOS33 [get_ports sys_rst_n] set_property PACKAGE_PIN U2 [get_ports sys_rst_n] set_property PACKAGE_PIN R4 [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN G18 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[5]&#125;] set_property -dict &#123;PACKAGE_PIN H18 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[4]&#125;] set_property -dict &#123;PACKAGE_PIN G17 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[3]&#125;] set_property -dict &#123;PACKAGE_PIN H13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[2]&#125;] set_property -dict &#123;PACKAGE_PIN H17 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[1]&#125;] set_property -dict &#123;PACKAGE_PIN J15 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_sel[0]&#125;] set_property -dict &#123;PACKAGE_PIN H15 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[0]&#125;] set_property -dict &#123;PACKAGE_PIN G16 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[1]&#125;] set_property -dict &#123;PACKAGE_PIN L13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[2]&#125;] set_property -dict &#123;PACKAGE_PIN G15 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[3]&#125;] set_property -dict &#123;PACKAGE_PIN K13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[4]&#125;] set_property -dict &#123;PACKAGE_PIN G13 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[5]&#125;] set_property -dict &#123;PACKAGE_PIN H14 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[6]&#125;] set_property -dict &#123;PACKAGE_PIN J14 IOSTANDARD LVCMOS33&#125; [get_ports &#123;seg_led[7]&#125;] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 1234567891011121314151617181920212223242526272829303132//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [7:0] seg_led; wire [5:0] seg_sel;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #20 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo #( .TIME_SHOW (25&#x27;d250) //é©»ç•™æ—¶é—´)inst_seg_display_static( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .seg_led (seg_led), .seg_sel(seg_sel));endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ6ï¼‰å‘¼å¸ç¯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-006","date":"2022-10-28T00:27:18.000Z","updated":"2023-04-05T04:15:05.114Z","comments":true,"path":"posts/2356580398.html","link":"","permalink":"https://sirius-tblog.github.io/posts/2356580398.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦å®ç°ç¯å…‰ç”±æš—æ¸äº®ã€ç”±äº®æ¸æš—çš„æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U7 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ led output V9 LED0ï¼Œé«˜ç”µå¹³ç‚¹äº® æ€è·¯ {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 12345678910111213141516//demo.vmodule demo( input sys_clk, input sys_rst_n, output led);breath_led inst_breath_led( .clk (sys_clk), .rstn (sys_rst_n), .led(led));endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//breath_led.vmodule breath_led( input clk, input rstn, output led);reg [15:0] period_cnt;reg [15:0] duty_cycle;reg inc_dec_flag;//outputassign led = (period_cnt &gt;= duty_cycle) ? 1&#x27;b1 : 1&#x27;b0;always@(posedge clk or negedge rstn)begin if(!rstn) period_cnt &lt;= 16&#x27;d0; else if(period_cnt == 16&#x27;d50000) period_cnt &lt;= 16&#x27;d0; else period_cnt &lt;= period_cnt+1&#x27;b1;end//output valuealways@(posedge clk or negedge rstn)begin if(!rstn) begin duty_cycle &lt;= 16&#x27;d0; inc_dec_flag &lt;= 1&#x27;b0; end else begin if(period_cnt == 16&#x27;d50000) begin if(inc_dec_flag == 1&#x27;b0) begin if(duty_cycle == 16&#x27;d50000) inc_dec_flag &lt;= 1&#x27;b1; else duty_cycle &lt;= duty_cycle + 16&#x27;d25; end else begin if(duty_cycle == 16&#x27;d0) inc_dec_flag &lt;= 1&#x27;b0; else duty_cycle &lt;= duty_cycle - 16&#x27;d25; end end endendendmodule ç®¡è„šçº¦æŸï¼š 1234#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports led] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire led;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #20 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo breath_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led(led));endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ5ï¼‰è§¦æ‘¸é”®æ§ç¯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-005","date":"2022-10-28T00:20:18.000Z","updated":"2023-04-05T04:13:09.761Z","comments":true,"path":"posts/1138237653.html","link":"","permalink":"https://sirius-tblog.github.io/posts/1138237653.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦å®ç°è§¦æ‘¸å¼ç”µå®¹æŒ‰é”®æ§åˆ¶ç¯çš„å¼€å…³æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U7 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ led output V9 LED0ï¼Œé«˜ç”µå¹³ç‚¹äº® touch_key input V8 è§¦æ‘¸é”®ä¿¡å· æ€è·¯ {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 123456789101112131415161718//demo.vmodule demo( input sys_clk, input sys_rst_n, output led, input touch_key);touch_led inst_touch_led( .clk (sys_clk), .rstn (sys_rst_n), .touch_key (touch_key), .led(led));endmodule 1234567891011121314151617181920212223242526272829303132333435//touch_led.vmodule touch_led( input clk, input rstn, input touch_key, output reg led);reg [1:0] touch_key_r;wire touch_en;//check posedgeassign touch_en = (~touch_key_r[1]) &amp; touch_key_r[0];always@(posedge clk or negedge rstn)begin if(!rstn) touch_key_r &lt;= 2&#x27;d0; else touch_key_r &lt;= &#123;touch_key_r[0],touch_key&#125;;end//output valuealways@(posedge clk or negedge rstn)begin if(!rstn) led &lt;= 1&#x27;b0; else if(touch_en) led &lt;= ~led; else led &lt;= led;endendmodule ç®¡è„šçº¦æŸï¼š 12345#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN V8 IOSTANDARD LVCMOS15&#125; [get_ports touch_key] set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports led] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire led; reg key;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 1&#x27;b0; #20 sys_rst_n = 1&#x27;b1; #30 //50ms down key = 1&#x27;b1; #200 //250ms up key = 1&#x27;b0; #30 //280ms down key = 1&#x27;b1; #200 //480ms up key = 1&#x27;b0; #30 //510ms down key = 1&#x27;b1; #200 //710ms up key = 1&#x27;b0; #30 //740ms down key = 1&#x27;b1; #200 //940ms up key = 1&#x27;b0;endalways#10 sys_clk = ~sys_clk; demo inst_touch_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .touch_key (key), .led(led));endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ4ï¼‰æŒ‰é”®æ§èœ‚é¸£å™¨","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-004","date":"2022-10-28T00:15:18.000Z","updated":"2023-04-05T04:13:17.138Z","comments":true,"path":"posts/66328353.html","link":"","permalink":"https://sirius-tblog.github.io/posts/66328353.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦å®ç°ç‚¹è§¦å¼æŒ‰é”®æ§åˆ¶æœ‰æºèœ‚é¸£å™¨å‘å£°æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š {width=â€œ400pxâ€} {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U7 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ beep output V7 BEEPï¼Œé«˜ç”µå¹³é©±åŠ¨ key input T4 KEY0ï¼Œä½ç”µå¹³æŒ‰ä¸‹ æ€è·¯ {width=â€œ400pxâ€} {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 12345678910111213141516171819202122232425262728293031//demo.vmodule demo( input sys_clk, input sys_rst_n, output beep, input key);wire key_value;wire key_flag;key_debounce inst_key_debounce( .clk (sys_clk), .rstn (sys_rst_n), .key (key), .key_flag (key_flag), .key_value (key_value));beep_ctrl inst_beep_ctrl( .clk (sys_clk), .rstn (sys_rst_n), .key_flag (key_flag), .key_value (key_value), .beep (beep));endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//key_debounce.vmodule key_debounce( input clk, input rstn, input key, output reg key_value, output reg key_flag);reg [31:0] delay_cnt;reg key_reg;//delay timealways@(posedge clk or negedge rstn)begin if(!rstn) begin key_reg &lt;= 1&#x27;b1; delay_cnt &lt;= 32&#x27;d0; end else begin key_reg &lt;= key; if(key_reg!=key) //in shaked delay_cnt &lt;= 32&#x27;d1000000; else if(key_reg==key) begin if(delay_cnt &gt; 32&#x27;d0) delay_cnt &lt;= delay_cnt-1&#x27;b1; else delay_cnt &lt;= delay_cnt; end endend//output valuealways@(posedge clk or negedge rstn)begin if(!rstn) begin key_flag &lt;= 1&#x27;b0; key_value &lt;= 1&#x27;b1; end else begin if(delay_cnt == 32&#x27;d1) begin key_flag &lt;= 1&#x27;b1; key_value &lt;= key; end else begin key_flag &lt;= 1&#x27;b0; key_value &lt;= key; end endendendmodule 123456789101112131415161718192021222324//beep_ctrl.vmodule beep_ctrl( input clk, input rstn, output reg beep, input key_value, input key_flag);always@(posedge clk or negedge rstn)begin if(!rstn) beep &lt;= 1&#x27;b1; else begin if(key_flag&amp;&amp;(~key_value)) beep &lt;= ~beep; else beep &lt;= beep; endendendmodule ç®¡è„šçº¦æŸï¼š 12345#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n] set_property -dict &#123;PACKAGE_PIN T4 IOSTANDARD LVCMOS15&#125; [get_ports key] set_property -dict &#123;PACKAGE_PIN V7 IOSTANDARD LVCMOS15&#125; [get_ports beep] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//tb_demo.v`timescale 1 ns/ 1 nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire beep; reg key; parameter T=1000000;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 1&#x27;b1; #20 sys_rst_n = 1&#x27;b1; #(30*T) //30ms down key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(170*T) //240ms up key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(170*T) //450ms down key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(10*T) //shake key = 1&#x27;b1; #(10*T) //shake key = 1&#x27;b0; #(30*T) //520ms up key = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_key_beep( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .beep (beep), .key (key));endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ3ï¼‰æŒ‰é”®æ§ç¯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-003","date":"2022-10-27T23:55:18.000Z","updated":"2023-04-05T04:13:22.701Z","comments":true,"path":"posts/3244215014.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3244215014.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦å®ç°ç‚¹è§¦å¼æŒ‰é”®æ§åˆ¶LEDç¯ç‚¹äº®çš„æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š {width=â€œ400pxâ€} {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U7 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ led[0] output V9 LED0ï¼Œé«˜ç”µå¹³ç‚¹äº® led[1] output Y8 LED1ï¼Œé«˜ç”µå¹³ç‚¹äº® led[2] output Y7 LED2ï¼Œé«˜ç”µå¹³ç‚¹äº® led[3] output W7 LED3ï¼Œé«˜ç”µå¹³ç‚¹äº® key[0] input T4 KEY0ï¼Œä½ç”µå¹³æŒ‰ä¸‹ key[1] input T3 KEY1ï¼Œä½ç”µå¹³æŒ‰ä¸‹ key[2] input R6 KEY2ï¼Œä½ç”µå¹³æŒ‰ä¸‹ key[3] input T6 KEY3ï¼Œä½ç”µå¹³æŒ‰ä¸‹ æ€è·¯ {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 12345678910111213141516171819//demo.vmodule demo( input sys_clk, input sys_rst_n, output [3:0] led, input [3:0] key);key_led inst_key_led( .clk (sys_clk), .rstn (sys_rst_n), .led (led), .key (key));endmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//key_led.vmodule key_led( input clk, input rstn, output reg [3:0] led, input [3:0] key);reg [23:0] cnt;reg [1:0] led_ctrl;//delayalways@(posedge clk or negedge rstn)begin if(!rstn) cnt &lt;= 24&#x27;d0; else if(cnt&lt;24&#x27;d10000000) cnt &lt;= cnt+1&#x27;b1; else cnt&lt;=24&#x27;d0;end//controlalways@(posedge clk or negedge rstn)begin if(!rstn) led_ctrl &lt;= 2&#x27;d0; else if(cnt==(24&#x27;d10000000-1&#x27;b1)) led_ctrl &lt;= led_ctrl+1&#x27;b1; else led_ctrl&lt;= led_ctrl;end//keyalways@(posedge clk or negedge rstn)begin if(!rstn) led &lt;= 4&#x27;b0000; else if(key[0]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b1000; 2&#x27;d1 : led &lt;= 4&#x27;b0100; 2&#x27;d2 : led &lt;= 4&#x27;b0010; 2&#x27;d3 : led &lt;= 4&#x27;b0001; default : led &lt;= 4&#x27;b0000; endcase else if(key[1]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b0001; 2&#x27;d1 : led &lt;= 4&#x27;b0010; 2&#x27;d2 : led &lt;= 4&#x27;b0100; 2&#x27;d3 : led &lt;= 4&#x27;b1000; default : led &lt;= 4&#x27;b0000; endcase else if(key[2]==1&#x27;b0) case(led_ctrl) 2&#x27;d0 : led &lt;= 4&#x27;b1111; 2&#x27;d1 : led &lt;= 4&#x27;b0000; 2&#x27;d2 : led &lt;= 4&#x27;b1111; 2&#x27;d3 : led &lt;= 4&#x27;b0000; default : led &lt;= 4&#x27;b0000; endcase else if(key[3]==1&#x27;b0) led &lt;= 4&#x27;b1111; else led &lt;= 4&#x27;b0000;endendmodule ç®¡è„šçº¦æŸï¼š 1234567891011#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk]set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n]set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports led[0]]set_property -dict &#123;PACKAGE_PIN Y8 IOSTANDARD LVCMOS15&#125; [get_ports led[1]]set_property -dict &#123;PACKAGE_PIN Y7 IOSTANDARD LVCMOS15&#125; [get_ports led[2]] set_property -dict &#123;PACKAGE_PIN W7 IOSTANDARD LVCMOS15&#125; [get_ports led[3]]set_property -dict &#123;PACKAGE_PIN T4 IOSTANDARD LVCMOS15&#125; [get_ports key[0]] set_property -dict &#123;PACKAGE_PIN T3 IOSTANDARD LVCMOS15&#125; [get_ports key[1]] set_property -dict &#123;PACKAGE_PIN R6 IOSTANDARD LVCMOS15&#125; [get_ports key[2]] set_property -dict &#123;PACKAGE_PIN T6 IOSTANDARD LVCMOS15&#125; [get_ports key[3]] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); parameter T=20; reg sys_clk; reg sys_rst_n; wire [3:0] led; reg [3:0] key;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; key = 4&#x27;b1111; #T sys_rst_n = 1&#x27;b1; key[0] = 1&#x27;b0; //down #(40000000*T) //800 key[0] = 1&#x27;b1; //up key[1] = 1&#x27;b0; #(40000000*T) key[1] = 1&#x27;b1; key[2] = 1&#x27;b0; #(40000000*T) key[2] = 1&#x27;b1; key[3] = 1&#x27;b0; #(40000000*T) key[3] = 1&#x27;b1;endalways#(T/2) sys_clk = ~sys_clk; demo inst_key_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led), .key (key));endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ2ï¼‰æµæ°´ç¯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-002","date":"2022-10-27T23:29:18.000Z","updated":"2023-04-05T04:13:28.452Z","comments":true,"path":"posts/3427372113.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3427372113.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦å®ç°LEDç¯æŒ‰é¡ºåºä»¥ä¸€å®šæ—¶é—´é—´éš”é€ä¸ªç‚¹äº®åŠç†„ç­çš„æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U7 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ led[0] output V9 LED0ï¼Œé«˜ç”µå¹³ç‚¹äº® led[1] output Y8 LED1ï¼Œé«˜ç”µå¹³ç‚¹äº® led[2] output Y7 LED2ï¼Œé«˜ç”µå¹³ç‚¹äº® led[3] output W7 LED3ï¼Œé«˜ç”µå¹³ç‚¹äº® æ€è·¯ {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1234567891011121314151617//demo.vmodule demo( input sys_clk, input sys_rst_n, output [3:0] led);flow_led inst_flow_led( .clk (sys_clk), .rstn (sys_rst_n), .led (led));endmodule 12345678910111213141516171819202122232425262728293031//flow_led.vmodule flow_led( input clk, input rstn, output reg [3:0] led);reg [25:0] cnt;always@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) cnt &lt;= 26&#x27;d0; else if(cnt&lt;26&#x27;d10000000)//200ms cnt &lt;= cnt+1&#x27;b1; else cnt = 26&#x27;d0;endalways@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) led &lt;= 4&#x27;b0001; else if(cnt==(26&#x27;d10000000-1&#x27;b1))//200ms led &lt;= &#123;led[2:0],led[3]&#125;; else led &lt;= led;endendmodule ç®¡è„šçº¦æŸï¼š 1234567#demo.xdcset_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n]set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports led[0]] set_property -dict &#123;PACKAGE_PIN Y8 IOSTANDARD LVCMOS15&#125; [get_ports led[1]] set_property -dict &#123;PACKAGE_PIN Y7 IOSTANDARD LVCMOS15&#125; [get_ports led[2]] set_property -dict &#123;PACKAGE_PIN W7 IOSTANDARD LVCMOS15&#125; [get_ports led[3]] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 12345678910111213141516171819202122232425//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [3:0] led;initial begin sys_clk = 1&#x27;b0; sys_rst_n = 1&#x27;b0; #200 sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_flow_led( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led));endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]},{"title":"XC7A35T Verilog ä¾‹ç¨‹ï¼ˆ1ï¼‰é—ªç¯","slug":"study-ic-design/examples-fpga/xc7a35t/xc7a35t-verilog-001","date":"2022-10-27T18:29:18.000Z","updated":"2023-04-05T04:13:02.651Z","comments":true,"path":"posts/3954518670.html","link":"","permalink":"https://sirius-tblog.github.io/posts/3954518670.html","excerpt":"","text":"è¯´æ˜ï¼šç¡¬ä»¶ç¯å¢ƒåŠä¾‹ç¨‹å‚è€ƒâ€œæ­£ç‚¹åŸå­è¾¾èŠ¬å¥‡å¼€å‘æ¿â€ï¼Œéƒ¨åˆ†å†…å®¹ä¼šæœ‰æ”¹åŠ¨ã€‚ å™¨ä»¶ ä¸»èŠ¯ç‰‡ï¼šXilinx XC7A35TFGG484 ã€‚ ç›®çš„ ä¸»è¦å®ç°LEDç¯ç‚¹äº®å¹¶äº¤æ›¿é—ªçƒçš„æ•ˆæœã€‚ ç”µè·¯ ç¡¬ä»¶è¿æ¥å…³ç³»ï¼š {width=â€œ400pxâ€} FPGAç®¡è„šåˆ†é…ï¼š ä¿¡å· æ–¹å‘ ç®¡è„š è¯´æ˜ sys_clk input R4 æ­¤å¤„æ—¶é’Ÿ50MHz sys_rst_n input U7 æ­¤å¤„å¤ä½ä½æœ‰æ•ˆ led[0] output V9 LED0ï¼Œé«˜ç”µå¹³ç‚¹äº® led[1] output Y8 LED1ï¼Œé«˜ç”µå¹³ç‚¹äº® æ€è·¯ {width=â€œ400pxâ€} é©±åŠ¨ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼š 1234567891011121314151617//demo.vmodule demo( input sys_clk, input sys_rst_n, output [1:0] led);led_twinkle inst_led_twinkle( .clk (sys_clk), .rstn (sys_rst_n), .led (led));endmodule 1234567891011121314151617181920212223//led_twinkle.vmodule led_twinkle( input clk, input rstn, output [1:0] led);reg [25:0] cnt;always@(posedge clk or negedge rstn)//50MHz clkbegin if(!rstn) cnt &lt;= 26&#x27;d0; else if(cnt&lt;26&#x27;d50000000)//1s cnt &lt;= cnt+1&#x27;b1; else cnt = 26&#x27;d0;endassign led = (cnt&lt;26&#x27;d25000000)?2&#x27;b01:2&#x27;b10;endmodule ç®¡è„šçº¦æŸï¼š 12345#demo.xdcset_property -dict &#123;PACKAGE_PIN Y8 IOSTANDARD LVCMOS15&#125; [get_ports &#123;led[1]&#125;] set_property -dict &#123;PACKAGE_PIN V9 IOSTANDARD LVCMOS15&#125; [get_ports &#123;led[0]&#125;] set_property -dict &#123;PACKAGE_PIN R4 IOSTANDARD LVCMOS15&#125; [get_ports sys_clk] set_property -dict &#123;PACKAGE_PIN U7 IOSTANDARD LVCMOS15&#125; [get_ports sys_rst_n] éªŒè¯ åŠŸèƒ½ä»¿çœŸTestBenchï¼š 1234567891011121314151617181920212223//tb_demo.v`timescale 1ns/1nsmodule tb_demo(); reg sys_clk; reg sys_rst_n; wire [1:0] led;initial beginsys_clk = 1&#x27;b0;sys_rst_n = 1&#x27;b0;#200sys_rst_n = 1&#x27;b1;endalways#10 sys_clk = ~sys_clk; demo inst_led_twinkle( .sys_clk (sys_clk), .sys_rst_n (sys_rst_n), .led (led));endmodule è¿è¡Œç»“æœï¼š ä¸Šæ¿ è¿è¡Œç»“æœï¼š ç•¥","categories":[{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]}],"categories":[{"name":"MCU ä¾‹ç¨‹","slug":"MCU-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/"},{"name":"STM32F1 åº“å‡½æ•°ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-åº“å‡½æ•°ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%BA%93%E5%87%BD%E6%95%B0%E7%89%88/"},{"name":"Altera-FPGA ä¾‹ç¨‹","slug":"Altera-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"EP4CE10 å‹","slug":"Altera-FPGA-ä¾‹ç¨‹/EP4CE10-å‹","permalink":"https://sirius-tblog.github.io/categories/Altera-FPGA-%E4%BE%8B%E7%A8%8B/EP4CE10-%E5%9E%8B/"},{"name":"STM32F1 å¯„å­˜å™¨ç‰ˆ","slug":"MCU-ä¾‹ç¨‹/STM32F1-å¯„å­˜å™¨ç‰ˆ","permalink":"https://sirius-tblog.github.io/categories/MCU-%E4%BE%8B%E7%A8%8B/STM32F1-%E5%AF%84%E5%AD%98%E5%99%A8%E7%89%88/"},{"name":"Xilinx-FPGA ä¾‹ç¨‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/"},{"name":"XC7A35T å‹","slug":"Xilinx-FPGA-ä¾‹ç¨‹/XC7A35T-å‹","permalink":"https://sirius-tblog.github.io/categories/Xilinx-FPGA-%E4%BE%8B%E7%A8%8B/XC7A35T-%E5%9E%8B/"}],"tags":[{"name":"ç¡¬ä»¶ç”µè·¯","slug":"ç¡¬ä»¶ç”µè·¯","permalink":"https://sirius-tblog.github.io/tags/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF/"},{"name":"ä¾‹ç¨‹","slug":"ä¾‹ç¨‹","permalink":"https://sirius-tblog.github.io/tags/%E4%BE%8B%E7%A8%8B/"},{"name":"STMicroelectronics(ST)","slug":"STMicroelectronics-ST","permalink":"https://sirius-tblog.github.io/tags/STMicroelectronics-ST/"},{"name":"MCU","slug":"MCU","permalink":"https://sirius-tblog.github.io/tags/MCU/"},{"name":"STM32F1","slug":"STM32F1","permalink":"https://sirius-tblog.github.io/tags/STM32F1/"},{"name":"Altera","slug":"Altera","permalink":"https://sirius-tblog.github.io/tags/Altera/"},{"name":"FPGA","slug":"FPGA","permalink":"https://sirius-tblog.github.io/tags/FPGA/"},{"name":"EP4CE10","slug":"EP4CE10","permalink":"https://sirius-tblog.github.io/tags/EP4CE10/"},{"name":"Xilinx","slug":"Xilinx","permalink":"https://sirius-tblog.github.io/tags/Xilinx/"},{"name":"XC7A35T","slug":"XC7A35T","permalink":"https://sirius-tblog.github.io/tags/XC7A35T/"}]}